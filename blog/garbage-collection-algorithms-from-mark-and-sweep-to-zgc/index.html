<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>Garbage Collection Algorithms: From Mark-and-Sweep to ZGC · Leonardo Benicio</title><meta name=description content="A comprehensive exploration of garbage collection algorithms, from classic mark-and-sweep to modern concurrent collectors like G1, Shenandoah, and ZGC. Learn how automatic memory management works and the trade-offs that shape collector design."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/garbage-collection-algorithms-from-mark-and-sweep-to-zgc/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="Garbage Collection Algorithms: From Mark-and-Sweep to ZGC · Leonardo Benicio"><meta property="og:description" content="A comprehensive exploration of garbage collection algorithms, from classic mark-and-sweep to modern concurrent collectors like G1, Shenandoah, and ZGC. Learn how automatic memory management works and the trade-offs that shape collector design."><meta property="og:url" content="https://blog.lbenicio.dev/blog/garbage-collection-algorithms-from-mark-and-sweep-to-zgc/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/garbage-collection-algorithms-mark-sweep-to-zgc.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Garbage Collection Algorithms: From Mark-and-Sweep to ZGC · Leonardo Benicio"><meta name=twitter:description content="A comprehensive exploration of garbage collection algorithms, from classic mark-and-sweep to modern concurrent collectors like G1, Shenandoah, and ZGC. Learn how automatic memory management works and the trade-offs that shape collector design."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/garbage-collection-algorithms-from-mark-and-sweep-to-zgc/","name":"Garbage Collection Algorithms From Mark and Sweep to Zgc","position":3}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Garbage Collection Algorithms From Mark and Sweep to Zgc</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Garbage Collection Algorithms From Mark and Sweep to Zgc</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">Garbage Collection Algorithms: From Mark-and-Sweep to ZGC</h1><div class="c277478 c3ecea6 c8fb24a">2022-11-22
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/garbage-collection-algorithms-mark-sweep-to-zgc.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">A comprehensive exploration of garbage collection algorithms, from classic mark-and-sweep to modern concurrent collectors like G1, Shenandoah, and ZGC. Learn how automatic memory management works and the trade-offs that shape collector design.</p></header><div class="content"><p>Manual memory management is powerful but error-prone. Forget to free memory and you leak; free too early and you corrupt. Garbage collection promises to solve this by automatically reclaiming unused memory. But this convenience comes with costs and trade-offs that every systems programmer should understand. This post explores garbage collection from first principles to cutting-edge concurrent collectors.</p><h2 id="1-why-garbage-collection">1. Why Garbage Collection?</h2><p>Consider the challenges of manual memory management:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>process_request</span>(Request<span style=color:#ff7b72;font-weight:700>*</span> req) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> buffer <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#a5d6ff>1024</span>);
</span></span><span style=display:flex><span>    Result<span style=color:#ff7b72;font-weight:700>*</span> result <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>compute</span>(req, buffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (result<span style=color:#ff7b72;font-weight:700>-&gt;</span>error) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Oops! Forgot to free buffer
</span></span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>send_response</span>(result);
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>free</span>(buffer);
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>free</span>(result);  <span style=color:#8b949e;font-style:italic>// Did compute() allocate this? Or is it static?
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Common bugs include:</p><ul><li><strong>Memory leaks:</strong> Forgetting to free allocated memory</li><li><strong>Use-after-free:</strong> Accessing memory after it&rsquo;s been freed</li><li><strong>Double-free:</strong> Freeing the same memory twice</li><li><strong>Dangling pointers:</strong> Holding references to freed memory</li></ul><p>Garbage collection eliminates these bugs by automatically determining when memory is no longer reachable and reclaiming it. The programmer allocates; the runtime frees.</p><h3 id="11-the-basic-idea">1.1 The Basic Idea</h3><p>A garbage collector&rsquo;s job is simple in concept:</p><ol><li>Find all objects that the program can still access (live objects)</li><li>Reclaim memory from objects that can&rsquo;t be accessed (garbage)</li></ol><p>The challenge is doing this efficiently without stopping the program for too long.</p><h3 id="12-reachability">1.2 Reachability</h3><p>An object is live if it&rsquo;s reachable from a set of root references:</p><ul><li>Local variables on the stack</li><li>Global/static variables</li><li>CPU registers</li><li>JNI references (in Java)</li></ul><p>Any object reachable from roots, directly or through a chain of references, is live. Everything else is garbage.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Roots
</span></span><span style=display:flex><span>  │
</span></span><span style=display:flex><span>  ├──▶ Object A ──▶ Object B ──▶ Object C
</span></span><span style=display:flex><span>  │         │
</span></span><span style=display:flex><span>  │         └──▶ Object D
</span></span><span style=display:flex><span>  │
</span></span><span style=display:flex><span>  └──▶ Object E
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object F (unreachable - garbage)
</span></span><span style=display:flex><span>Object G ──▶ Object H (unreachable cycle - garbage)
</span></span></code></pre></div><h2 id="2-reference-counting">2. Reference Counting</h2><p>The simplest approach: track how many references point to each object.</p><h3 id="21-basic-algorithm">2.1 Basic Algorithm</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Object</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>ref_count <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1</span>  <span style=color:#8b949e;font-style:italic># Creator holds a reference</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>add_ref</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>ref_count <span style=color:#ff7b72;font-weight:700>+=</span> <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>release</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>ref_count <span style=color:#ff7b72;font-weight:700>-=</span> <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> self<span style=color:#ff7b72;font-weight:700>.</span>ref_count <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> child <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>children:
</span></span><span style=display:flex><span>                child<span style=color:#ff7b72;font-weight:700>.</span>release()
</span></span><span style=display:flex><span>            free(self)
</span></span></code></pre></div><p>When you copy a reference, increment the count. When a reference goes away, decrement it. When the count hits zero, the object is garbage.</p><h3 id="22-advantages">2.2 Advantages</h3><ul><li><strong>Immediate reclamation:</strong> Objects are freed as soon as they become garbage</li><li><strong>Incremental:</strong> Work is spread across program execution</li><li><strong>Simple to implement:</strong> No need for complex graph traversal</li><li><strong>Predictable pauses:</strong> No stop-the-world collections</li></ul><h3 id="23-the-cycle-problem">2.3 The Cycle Problem</h3><p>Reference counting&rsquo;s fatal flaw:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span>a <span style=color:#ff7b72;font-weight:700>=</span> Object()  <span style=color:#8b949e;font-style:italic># a.ref_count = 1</span>
</span></span><span style=display:flex><span>b <span style=color:#ff7b72;font-weight:700>=</span> Object()  <span style=color:#8b949e;font-style:italic># b.ref_count = 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a<span style=color:#ff7b72;font-weight:700>.</span>child <span style=color:#ff7b72;font-weight:700>=</span> b   <span style=color:#8b949e;font-style:italic># b.ref_count = 2</span>
</span></span><span style=display:flex><span>b<span style=color:#ff7b72;font-weight:700>.</span>child <span style=color:#ff7b72;font-weight:700>=</span> a   <span style=color:#8b949e;font-style:italic># a.ref_count = 2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>None</span>      <span style=color:#8b949e;font-style:italic># a.ref_count = 1 (still &gt; 0!)</span>
</span></span><span style=display:flex><span>b <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>None</span>      <span style=color:#8b949e;font-style:italic># b.ref_count = 1 (still &gt; 0!)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Both objects are garbage but won&#39;t be collected</span>
</span></span></code></pre></div><p>Cycles create mutual references that keep objects alive forever.</p><h3 id="24-solutions-to-cycles">2.4 Solutions to Cycles</h3><p><strong>Weak references:</strong> References that don&rsquo;t contribute to the count.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span>a<span style=color:#ff7b72;font-weight:700>.</span>child <span style=color:#ff7b72;font-weight:700>=</span> b           <span style=color:#8b949e;font-style:italic># Strong reference, increments count</span>
</span></span><span style=display:flex><span>b<span style=color:#ff7b72;font-weight:700>.</span>parent <span style=color:#ff7b72;font-weight:700>=</span> weak(a)    <span style=color:#8b949e;font-style:italic># Weak reference, doesn&#39;t increment</span>
</span></span></code></pre></div><p><strong>Cycle detection:</strong> Periodically run a tracing collector to find cycles. Python uses this approach.</p><p><strong>Cycle-aware designs:</strong> Structure data to avoid cycles (trees instead of graphs).</p><h3 id="25-reference-counting-overhead">2.5 Reference Counting Overhead</h3><p>Even without cycles, reference counting has costs:</p><ul><li><strong>Space:</strong> Every object needs a count field</li><li><strong>Time:</strong> Every reference assignment updates counts</li><li><strong>Cache pollution:</strong> Count updates touch memory across the heap</li><li><strong>Thread safety:</strong> Atomic operations needed for concurrent access</li></ul><p>Despite these issues, reference counting is used in:</p><ul><li>Python (with cycle detection)</li><li>Swift (with automatic reference counting, ARC)</li><li>Rust&rsquo;s <code>Rc</code> and <code>Arc</code> types</li><li>C++ <code>shared_ptr</code></li></ul><h2 id="3-mark-and-sweep">3. Mark-and-Sweep</h2><p>The classic tracing collector: mark live objects, sweep away the rest.</p><h3 id="31-mark-phase">3.1 Mark Phase</h3><p>Starting from roots, traverse all reachable objects and mark them:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>mark</span>(roots):
</span></span><span style=display:flex><span>    worklist <span style=color:#ff7b72;font-weight:700>=</span> list(roots)
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> worklist:
</span></span><span style=display:flex><span>        obj <span style=color:#ff7b72;font-weight:700>=</span> worklist<span style=color:#ff7b72;font-weight:700>.</span>pop()
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> obj<span style=color:#ff7b72;font-weight:700>.</span>marked:
</span></span><span style=display:flex><span>            obj<span style=color:#ff7b72;font-weight:700>.</span>marked <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>True</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> child <span style=color:#ff7b72;font-weight:700>in</span> obj<span style=color:#ff7b72;font-weight:700>.</span>references:
</span></span><span style=display:flex><span>                worklist<span style=color:#ff7b72;font-weight:700>.</span>append(child)
</span></span></code></pre></div><p>This is essentially a graph traversal (DFS or BFS).</p><h3 id="32-sweep-phase">3.2 Sweep Phase</h3><p>Walk through all objects; free unmarked ones:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>sweep</span>(heap):
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> obj <span style=color:#ff7b72;font-weight:700>in</span> heap<span style=color:#ff7b72;font-weight:700>.</span>all_objects():
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> obj<span style=color:#ff7b72;font-weight:700>.</span>marked:
</span></span><span style=display:flex><span>            obj<span style=color:#ff7b72;font-weight:700>.</span>marked <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>False</span>  <span style=color:#8b949e;font-style:italic># Reset for next collection</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>            heap<span style=color:#ff7b72;font-weight:700>.</span>free(obj)
</span></span></code></pre></div><h3 id="33-stop-the-world">3.3 Stop-the-World</h3><p>Basic mark-and-sweep requires stopping the program during collection. Why?</p><ul><li>During marking, we need a consistent view of the heap</li><li>If the program modifies references while we&rsquo;re marking, we might miss live objects</li><li>During sweep, we can&rsquo;t have the program allocating in memory we&rsquo;re freeing</li></ul><p>This pause is called &ldquo;stop-the-world&rdquo; (STW) and is the primary challenge in GC design.</p><h3 id="34-advantages-and-disadvantages">3.4 Advantages and Disadvantages</h3><p><strong>Advantages:</strong></p><ul><li>Handles cycles naturally</li><li>No per-object overhead (mark bit can be external)</li><li>Well-understood algorithm</li></ul><p><strong>Disadvantages:</strong></p><ul><li>Stop-the-world pauses</li><li>Must traverse entire live set</li><li>Heap becomes fragmented over time</li></ul><h2 id="4-mark-compact">4. Mark-Compact</h2><p>Mark-and-sweep leaves holes in memory. Mark-compact adds a compaction phase.</p><h3 id="41-the-compaction-process">4.1 The Compaction Process</h3><p>After marking, slide all live objects to one end of the heap:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Before compaction:
</span></span><span style=display:flex><span>[Live][    ][Live][Live][    ][    ][Live]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After compaction:
</span></span><span style=display:flex><span>[Live][Live][Live][Live][                ]
</span></span><span style=display:flex><span>                        ↑
</span></span><span style=display:flex><span>                    Free pointer
</span></span></code></pre></div><h3 id="42-challenges">4.2 Challenges</h3><p>Compaction requires updating all references to point to new locations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>compact</span>(heap):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Calculate new addresses</span>
</span></span><span style=display:flex><span>    new_addr <span style=color:#ff7b72;font-weight:700>=</span> heap<span style=color:#ff7b72;font-weight:700>.</span>start
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> obj <span style=color:#ff7b72;font-weight:700>in</span> heap<span style=color:#ff7b72;font-weight:700>.</span>all_objects():
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> obj<span style=color:#ff7b72;font-weight:700>.</span>marked:
</span></span><span style=display:flex><span>            obj<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr <span style=color:#ff7b72;font-weight:700>=</span> new_addr
</span></span><span style=display:flex><span>            new_addr <span style=color:#ff7b72;font-weight:700>+=</span> obj<span style=color:#ff7b72;font-weight:700>.</span>size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Update all references</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> obj <span style=color:#ff7b72;font-weight:700>in</span> heap<span style=color:#ff7b72;font-weight:700>.</span>all_objects():
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> obj<span style=color:#ff7b72;font-weight:700>.</span>marked:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> ref <span style=color:#ff7b72;font-weight:700>in</span> obj<span style=color:#ff7b72;font-weight:700>.</span>references:
</span></span><span style=display:flex><span>                ref<span style=color:#ff7b72;font-weight:700>.</span>update(ref<span style=color:#ff7b72;font-weight:700>.</span>target<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Move objects</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> obj <span style=color:#ff7b72;font-weight:700>in</span> heap<span style=color:#ff7b72;font-weight:700>.</span>all_objects():
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> obj<span style=color:#ff7b72;font-weight:700>.</span>marked:
</span></span><span style=display:flex><span>            move(obj, obj<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr)
</span></span></code></pre></div><p>This requires multiple passes over the heap, making it slower than simple mark-sweep.</p><h3 id="43-benefits">4.3 Benefits</h3><ul><li><strong>No fragmentation:</strong> Memory is always contiguous</li><li><strong>Fast allocation:</strong> Just bump a pointer</li><li><strong>Better cache locality:</strong> Related objects can be placed together</li></ul><h3 id="44-variations">4.4 Variations</h3><p><strong>Lisp 2 algorithm:</strong> Three passes - compute addresses, update references, move objects.</p><p><strong>Threading:</strong> Uses reference fields as a linked list during compaction (saves space).</p><p><strong>Sliding vs. arbitrary:</strong> Sliding preserves allocation order; arbitrary can optimize layout.</p><h2 id="5-copying-collection">5. Copying Collection</h2><p>Instead of compacting in place, copy live objects to a new space.</p><h3 id="51-semi-space-collector">5.1 Semi-Space Collector</h3><p>Divide memory into two equal halves (semispaces):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────┬─────────────────┐
</span></span><span style=display:flex><span>│   From-space    │    To-space     │
</span></span><span style=display:flex><span>│   (active)      │   (reserved)    │
</span></span><span style=display:flex><span>└─────────────────┴─────────────────┘
</span></span></code></pre></div><p>Collection process:</p><ol><li>Copy all live objects from &ldquo;from-space&rdquo; to &ldquo;to-space&rdquo;</li><li>Update all references to point to new locations</li><li>Swap the roles of the two spaces</li></ol><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>collect</span>():
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>global</span> from_space, to_space
</span></span><span style=display:flex><span>    scan <span style=color:#ff7b72;font-weight:700>=</span> to_space<span style=color:#ff7b72;font-weight:700>.</span>start
</span></span><span style=display:flex><span>    free <span style=color:#ff7b72;font-weight:700>=</span> to_space<span style=color:#ff7b72;font-weight:700>.</span>start
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Copy roots</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> root <span style=color:#ff7b72;font-weight:700>in</span> roots:
</span></span><span style=display:flex><span>        root<span style=color:#ff7b72;font-weight:700>.</span>target <span style=color:#ff7b72;font-weight:700>=</span> copy(root<span style=color:#ff7b72;font-weight:700>.</span>target)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Breadth-first copy</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> scan <span style=color:#ff7b72;font-weight:700>&lt;</span> free:
</span></span><span style=display:flex><span>        obj <span style=color:#ff7b72;font-weight:700>=</span> object_at(scan)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> ref <span style=color:#ff7b72;font-weight:700>in</span> obj<span style=color:#ff7b72;font-weight:700>.</span>references:
</span></span><span style=display:flex><span>            ref<span style=color:#ff7b72;font-weight:700>.</span>target <span style=color:#ff7b72;font-weight:700>=</span> copy(ref<span style=color:#ff7b72;font-weight:700>.</span>target)
</span></span><span style=display:flex><span>        scan <span style=color:#ff7b72;font-weight:700>+=</span> obj<span style=color:#ff7b72;font-weight:700>.</span>size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Swap spaces</span>
</span></span><span style=display:flex><span>    from_space, to_space <span style=color:#ff7b72;font-weight:700>=</span> to_space, from_space
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>copy</span>(obj):
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> obj<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> obj<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    new_obj <span style=color:#ff7b72;font-weight:700>=</span> allocate_in_to_space(obj<span style=color:#ff7b72;font-weight:700>.</span>size)
</span></span><span style=display:flex><span>    copy_contents(obj, new_obj)
</span></span><span style=display:flex><span>    obj<span style=color:#ff7b72;font-weight:700>.</span>forwarding_addr <span style=color:#ff7b72;font-weight:700>=</span> new_obj
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> new_obj
</span></span></code></pre></div><h3 id="52-cheneys-algorithm">5.2 Cheney&rsquo;s Algorithm</h3><p>The elegant BFS copying algorithm shown above. Uses the to-space itself as the work queue—no additional memory needed.</p><h3 id="53-trade-offs">5.3 Trade-offs</h3><p><strong>Advantages:</strong></p><ul><li>Very fast allocation (bump pointer)</li><li>Compacts automatically</li><li>Only touches live objects (fast if most objects are garbage)</li><li>Simple implementation</li></ul><p><strong>Disadvantages:</strong></p><ul><li>Wastes half the memory (only half is usable at any time)</li><li>Copies everything, even long-lived objects</li><li>Bad for large heaps (long pause to copy everything)</li></ul><h2 id="6-generational-collection">6. Generational Collection</h2><p>Observation: most objects die young. This &ldquo;generational hypothesis&rdquo; is remarkably consistent across languages and applications.</p><h3 id="61-the-generational-hypothesis">6.1 The Generational Hypothesis</h3><p>Studies show:</p><ul><li>80-98% of objects die within one GC cycle of allocation</li><li>Objects that survive multiple collections tend to live forever</li><li>Allocating and collecting short-lived objects should be fast</li></ul><h3 id="62-generational-design">6.2 Generational Design</h3><p>Divide the heap into generations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌──────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                    Old Generation                 │
</span></span><span style=display:flex><span>│   (large, collected infrequently)                │
</span></span><span style=display:flex><span>├──────────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│  Young Generation                                 │
</span></span><span style=display:flex><span>│  ┌────────────────┬───────────┬───────────┐     │
</span></span><span style=display:flex><span>│  │     Eden       │ Survivor0 │ Survivor1 │     │
</span></span><span style=display:flex><span>│  │ (new objects)  │           │           │     │
</span></span><span style=display:flex><span>│  └────────────────┴───────────┴───────────┘     │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────┘
</span></span></code></pre></div><p><strong>Young generation:</strong> Small, collected frequently. Most objects die here.</p><p><strong>Old generation:</strong> Large, collected infrequently. Long-lived objects promoted here.</p><h3 id="63-minor-vs-major-collections">6.3 Minor vs. Major Collections</h3><p><strong>Minor GC (young generation):</strong></p><ol><li>Allocate in Eden until full</li><li>Copy survivors to a survivor space</li><li>Objects surviving multiple minor GCs are promoted to old generation</li><li>Fast because most objects are garbage</li></ol><p><strong>Major GC (full heap):</strong></p><ol><li>Triggered when old generation fills up</li><li>Collects both young and old generations</li><li>Much slower, but infrequent</li></ol><h3 id="64-the-write-barrier-problem">6.4 The Write Barrier Problem</h3><p>Old objects can reference young objects:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span>oldObject.field<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>newObject;<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Inter-generational reference</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p>When collecting the young generation, we must know about these references, or we&rsquo;ll incorrectly collect live young objects.</p><p><strong>Remembered sets:</strong> Track references from old to young generation.</p><p><strong>Card marking:</strong> Divide heap into &ldquo;cards.&rdquo; Mark cards as dirty when they contain modified references.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Old generation cards:
</span></span><span style=display:flex><span>[Clean][Dirty][Clean][Clean][Dirty][Clean]
</span></span><span style=display:flex><span>           │                   │
</span></span><span style=display:flex><span>           └───────────────────┘
</span></span><span style=display:flex><span>           These cards have references to young gen
</span></span></code></pre></div><p>During minor GC, only scan dirty cards for roots into young generation.</p><h3 id="65-write-barrier-implementation">6.5 Write Barrier Implementation</h3><p>Every reference store checks if it creates an inter-generational reference:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_barrier</span>(Object<span style=color:#ff7b72;font-weight:700>*</span> obj, Object<span style=color:#ff7b72;font-weight:700>*</span> ref, Object<span style=color:#ff7b72;font-weight:700>*</span> new_value) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Store the reference
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>*</span>ref <span style=color:#ff7b72;font-weight:700>=</span> new_value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// If old-to-young reference, remember it
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>is_old</span>(obj) <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> <span style=color:#d2a8ff;font-weight:700>is_young</span>(new_value)) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>mark_card_dirty</span>(obj);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This adds overhead to every reference assignment, but enables much faster minor collections.</p><h2 id="7-concurrent-and-incremental-collection">7. Concurrent and Incremental Collection</h2><p>Stop-the-world pauses are problematic for interactive and real-time applications. Concurrent collectors run alongside the application.</p><h3 id="71-the-tri-color-abstraction">7.1 The Tri-Color Abstraction</h3><p>Concurrent collectors use three colors to track marking progress:</p><ul><li><strong>White:</strong> Not yet seen (potential garbage)</li><li><strong>Gray:</strong> Seen but children not yet scanned</li><li><strong>Black:</strong> Scanned (definitely live)</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Initial:
</span></span><span style=display:flex><span>Roots ──▶ [White] ──▶ [White] ──▶ [White]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After starting:
</span></span><span style=display:flex><span>Roots ──▶ [Gray] ──▶ [White] ──▶ [White]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After scanning gray:
</span></span><span style=display:flex><span>Roots ──▶ [Black] ──▶ [Gray] ──▶ [White]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After completion:
</span></span><span style=display:flex><span>Roots ──▶ [Black] ──▶ [Black] ──▶ [Black]
</span></span></code></pre></div><p>Collection completes when no gray objects remain. All white objects are garbage.</p><h3 id="72-the-mutator-problem">7.2 The Mutator Problem</h3><p>While the collector runs, the application (the &ldquo;mutator&rdquo;) can change references:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Collector has marked A black, B is white</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>A.field<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>B;<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Now black A points to white B</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>C.field<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#79c0ff>null</span>;<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// C was the only other reference to B</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// B is now reachable only through A, but A is black and won&#39;t be rescanned</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// B remains white and will be incorrectly collected!</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p>This is the &ldquo;lost object&rdquo; problem. Two conditions must both be true:</p><ol><li>A black object gets a reference to a white object</li><li>All gray paths to the white object are destroyed</li></ol><h3 id="73-barrier-solutions">7.3 Barrier Solutions</h3><p><strong>Write barrier (snapshot-at-beginning):</strong> Record old values before overwriting.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_barrier</span>(Object<span style=color:#ff7b72;font-weight:700>**</span> field, Object<span style=color:#ff7b72;font-weight:700>*</span> new_value) {
</span></span><span style=display:flex><span>    Object<span style=color:#ff7b72;font-weight:700>*</span> old_value <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>field;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (old_value <span style=color:#ff7b72;font-weight:700>!=</span> null <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> <span style=color:#d2a8ff;font-weight:700>is_white</span>(old_value)) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>mark_gray</span>(old_value);  <span style=color:#8b949e;font-style:italic>// Keep old value alive
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>*</span>field <span style=color:#ff7b72;font-weight:700>=</span> new_value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Write barrier (incremental update):</strong> Mark new values when stored in black objects.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_barrier</span>(Object<span style=color:#ff7b72;font-weight:700>*</span> obj, Object<span style=color:#ff7b72;font-weight:700>**</span> field, Object<span style=color:#ff7b72;font-weight:700>*</span> new_value) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>*</span>field <span style=color:#ff7b72;font-weight:700>=</span> new_value;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>is_black</span>(obj) <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> new_value <span style=color:#ff7b72;font-weight:700>!=</span> null <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> <span style=color:#d2a8ff;font-weight:700>is_white</span>(new_value)) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>mark_gray</span>(new_value);  <span style=color:#8b949e;font-style:italic>// Or mark obj gray to rescan
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="74-incremental-vs-concurrent">7.4 Incremental vs. Concurrent</h3><p><strong>Incremental:</strong> Collector runs in small steps between mutator execution (same thread).</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>[Mutator][GC][Mutator][GC][Mutator][GC][Mutator]
</span></span></code></pre></div><p><strong>Concurrent:</strong> Collector runs on separate threads, truly parallel with mutator.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Thread 1: [Mutator][Mutator][Mutator][Mutator]
</span></span><span style=display:flex><span>Thread 2: [   GC   ][   GC   ][   GC   ]
</span></span></code></pre></div><p>Concurrent collectors are more complex but achieve lower pause times.</p><h2 id="8-the-cms-collector">8. The CMS Collector</h2><p>The Concurrent Mark Sweep (CMS) collector was Java&rsquo;s first production concurrent collector.</p><h3 id="81-phases">8.1 Phases</h3><ol><li><p><strong>Initial Mark (STW):</strong> Mark objects directly reachable from roots. Short pause.</p></li><li><p><strong>Concurrent Mark:</strong> Traverse object graph concurrently with application. Uses write barriers to track changes.</p></li><li><p><strong>Remark (STW):</strong> Fix up references changed during concurrent mark. Short pause.</p></li><li><p><strong>Concurrent Sweep:</strong> Sweep garbage concurrently. Add to free lists.</p></li></ol><h3 id="82-strengths-and-weaknesses">8.2 Strengths and Weaknesses</h3><p><strong>Strengths:</strong></p><ul><li>Short pause times (usually &lt; 200ms)</li><li>Good for interactive applications</li><li>Well-tested, mature collector</li></ul><p><strong>Weaknesses:</strong></p><ul><li>No compaction (fragmentation over time)</li><li>&ldquo;Concurrent mode failure&rdquo; when old gen fills during marking</li><li>Higher CPU overhead (collector threads compete with application)</li><li>Deprecated in Java 9, removed in Java 14</li></ul><h3 id="83-failure-modes">8.3 Failure Modes</h3><p><strong>Concurrent mode failure:</strong> Old generation fills before concurrent collection completes. Falls back to full STW collection.</p><p><strong>Promotion failure:</strong> Not enough contiguous space in old gen for promoted objects. Also triggers full GC.</p><p>These failures cause long pauses, defeating CMS&rsquo;s purpose.</p><h2 id="9-the-g1-collector">9. The G1 Collector</h2><p>Garbage-First (G1) became Java&rsquo;s default collector in Java 9. It aims for predictable pause times.</p><h3 id="91-region-based-heap">9.1 Region-Based Heap</h3><p>G1 divides the heap into equal-sized regions (1-32 MB):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
</span></span><span style=display:flex><span>│ E │ E │ S │ O │ O │ O │ H │ H │   │   │
</span></span><span style=display:flex><span>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
</span></span><span style=display:flex><span>E = Eden, S = Survivor, O = Old, H = Humongous (large objects)
</span></span></code></pre></div><p>Regions can change roles. No fixed-size generations.</p><h3 id="92-collection-sets">9.2 Collection Sets</h3><p>G1 doesn&rsquo;t collect the entire heap at once. It selects a &ldquo;collection set&rdquo; of regions to evacuate:</p><ul><li>Young collection: All young regions</li><li>Mixed collection: Young regions + some old regions with most garbage</li></ul><p>This is the &ldquo;garbage first&rdquo; insight: collect regions with the most garbage for best efficiency.</p><h3 id="93-remembered-sets">9.3 Remembered Sets</h3><p>Each region maintains a remembered set (RSet) of references from outside the region:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Region A               Region B
</span></span><span style=display:flex><span>┌─────────────┐       ┌─────────────┐
</span></span><span style=display:flex><span>│   Object    │──────▶│   Object    │
</span></span><span style=display:flex><span>│             │       │             │
</span></span><span style=display:flex><span>│   RSet: {}  │       │ RSet: {A}   │
</span></span><span style=display:flex><span>└─────────────┘       └─────────────┘
</span></span></code></pre></div><p>RSets enable collecting a region without scanning the entire heap. The trade-off is memory overhead (5-20% of heap).</p><h3 id="94-concurrent-marking">9.4 Concurrent Marking</h3><p>G1&rsquo;s marking is similar to CMS:</p><ol><li><strong>Initial Mark (STW, piggybacks on young GC)</strong></li><li><strong>Concurrent Mark:</strong> SATB (snapshot-at-beginning) write barrier</li><li><strong>Remark (STW):</strong> Process SATB buffers</li><li><strong>Cleanup (STW):</strong> Identify empty regions, sort regions by garbage ratio</li></ol><h3 id="95-pause-time-goals">9.5 Pause Time Goals</h3><p>G1 accepts a pause time target (e.g., 200ms):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span>java -XX:MaxGCPauseMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>200</span> MyApp
</span></span></code></pre></div><p>G1 adjusts the collection set size to meet this target. Fewer regions = shorter pause, less memory reclaimed.</p><h3 id="96-performance-characteristics">9.6 Performance Characteristics</h3><ul><li><strong>Pause times:</strong> More predictable than CMS, typically 50-200ms</li><li><strong>Throughput:</strong> Slightly lower than Parallel GC due to write barriers</li><li><strong>Memory:</strong> Higher footprint due to remembered sets</li><li><strong>Best for:</strong> Large heaps (4GB+), applications needing predictable latency</li></ul><h2 id="10-shenandoah">10. Shenandoah</h2><p>Shenandoah aims for ultra-low pause times (&lt; 10ms) regardless of heap size.</p><h3 id="101-key-innovation-concurrent-compaction">10.1 Key Innovation: Concurrent Compaction</h3><p>Unlike G1, Shenandoah compacts concurrently with the application:</p><ol><li>Objects are copied while the application runs</li><li>References are updated concurrently</li><li>Forwarding pointers enable concurrent access to moved objects</li></ol><h3 id="102-the-brooks-pointer">10.2 The Brooks Pointer</h3><p>Every object has an indirection pointer (Brooks pointer):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Brooks Pointer │ Object Data       │
</span></span><span style=display:flex><span>│ (self or fwd)  │                   │
</span></span><span style=display:flex><span>└────────────────────────────────────┘
</span></span></code></pre></div><p>Normally points to itself. During evacuation, points to the new location:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Old location:
</span></span><span style=display:flex><span>┌────────────────────────────────────┐
</span></span><span style=display:flex><span>│ ──────────────────┐ Object Data    │
</span></span><span style=display:flex><span>└───────────────────│────────────────┘
</span></span><span style=display:flex><span>                    │
</span></span><span style=display:flex><span>                    ▼
</span></span><span style=display:flex><span>New location:      ┌────────────────────────────────────┐
</span></span><span style=display:flex><span>                   │ (self)         │ Object Data       │
</span></span><span style=display:flex><span>                   └────────────────────────────────────┘
</span></span></code></pre></div><p>All reads go through the Brooks pointer. This adds overhead but enables concurrent evacuation.</p><h3 id="103-load-reference-barrier">10.3 Load Reference Barrier</h3><p>Every reference load checks and potentially updates the reference:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Object<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>load_reference</span>(Object<span style=color:#ff7b72;font-weight:700>**</span> ref) {
</span></span><span style=display:flex><span>    Object<span style=color:#ff7b72;font-weight:700>*</span> obj <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>ref;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>is_forwarded</span>(obj)) {
</span></span><span style=display:flex><span>        Object<span style=color:#ff7b72;font-weight:700>*</span> new_obj <span style=color:#ff7b72;font-weight:700>=</span> obj<span style=color:#ff7b72;font-weight:700>-&gt;</span>brooks_pointer;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>*</span>ref <span style=color:#ff7b72;font-weight:700>=</span> new_obj;  <span style=color:#8b949e;font-style:italic>// Update reference in place
</span></span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> new_obj;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> obj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This &ldquo;self-healing&rdquo; ensures references are updated as they&rsquo;re used.</p><h3 id="104-phases">10.4 Phases</h3><ol><li><strong>Initial Mark (STW):</strong> ~1ms</li><li><strong>Concurrent Mark:</strong> Traverse heap</li><li><strong>Final Mark (STW):</strong> ~1ms</li><li><strong>Concurrent Cleanup:</strong> Reclaim empty regions</li><li><strong>Concurrent Evacuation:</strong> Copy and update references</li><li><strong>Init Update Refs (STW):</strong> ~1ms</li><li><strong>Concurrent Update Refs:</strong> Update remaining references</li><li><strong>Final Update Refs (STW):</strong> ~1ms</li></ol><p>Total STW time: typically 4-10ms regardless of heap size!</p><h3 id="105-trade-offs">10.5 Trade-offs</h3><p><strong>Strengths:</strong></p><ul><li>Ultra-low pause times</li><li>Scales to huge heaps</li><li>Full compaction</li></ul><p><strong>Weaknesses:</strong></p><ul><li>Lower throughput (barrier overhead)</li><li>More CPU usage</li><li>Memory overhead (Brooks pointers)</li></ul><h2 id="11-zgc">11. ZGC</h2><p>Z Garbage Collector (ZGC) targets sub-millisecond pauses for multi-terabyte heaps.</p><h3 id="111-colored-pointers">11.1 Colored Pointers</h3><p>ZGC uses pointer coloring instead of object headers:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>64-bit pointer:
</span></span><span style=display:flex><span>┌──────────┬───┬───┬───┬───┬────────────────────────────────┐
</span></span><span style=display:flex><span>│ Unused   │ F │ R │ M1│ M0│     Object Address (42 bits)   │
</span></span><span style=display:flex><span>│ (16 bits)│   │   │   │   │                                │
</span></span><span style=display:flex><span>└──────────┴───┴───┴───┴───┴────────────────────────────────┘
</span></span><span style=display:flex><span>F = Finalizable, R = Remapped, M1/M0 = Marked bits
</span></span></code></pre></div><p>The color bits encode GC state. The same object can be accessed through different &ldquo;views&rdquo; based on pointer color.</p><h3 id="112-load-barrier">11.2 Load Barrier</h3><p>Like Shenandoah, ZGC uses a load barrier:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Object<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>load_reference</span>(Object<span style=color:#ff7b72;font-weight:700>**</span> ref) {
</span></span><span style=display:flex><span>    Object<span style=color:#ff7b72;font-weight:700>*</span> obj <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>ref;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>needs_barrier</span>(obj)) {
</span></span><span style=display:flex><span>        obj <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>slow_path</span>(obj, ref);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> obj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The barrier checks pointer color. If the color is wrong for the current GC phase, it fixes the reference.</p><h3 id="113-multi-mapping">11.3 Multi-Mapping</h3><p>ZGC maps the same physical memory at multiple virtual addresses:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Virtual Address Space:
</span></span><span style=display:flex><span>┌────────────────────────┐  ◄── &#34;Marked0&#34; view
</span></span><span style=display:flex><span>│                        │
</span></span><span style=display:flex><span>├────────────────────────┤  ◄── &#34;Marked1&#34; view
</span></span><span style=display:flex><span>│                        │
</span></span><span style=display:flex><span>├────────────────────────┤  ◄── &#34;Remapped&#34; view
</span></span><span style=display:flex><span>│                        │
</span></span><span style=display:flex><span>└────────────────────────┘
</span></span><span style=display:flex><span>         │ │ │
</span></span><span style=display:flex><span>         ▼ ▼ ▼
</span></span><span style=display:flex><span>    Same physical memory
</span></span></code></pre></div><p>This enables changing an object&rsquo;s &ldquo;color&rdquo; by changing which view you use, without modifying the object.</p><h3 id="114-concurrent-operations">11.4 Concurrent Operations</h3><p>Almost everything in ZGC is concurrent:</p><ul><li>Marking</li><li>Relocation set selection</li><li>Reference processing</li><li>Object relocation</li><li>Root scanning (mostly)</li></ul><p>STW pauses are only for:</p><ul><li>Root scanning start/end (&lt; 1ms)</li><li>A few internal bookkeeping operations</li></ul><h3 id="115-performance">11.5 Performance</h3><ul><li><strong>Pause times:</strong> &lt; 1ms, typically 200-500μs</li><li><strong>Heap sizes:</strong> Tested to 16TB</li><li><strong>Throughput:</strong> Comparable to G1, less than Parallel GC</li><li><strong>Memory:</strong> Requires 64-bit, uses more virtual address space</li></ul><h3 id="116-use-cases">11.6 Use Cases</h3><p>ZGC excels for:</p><ul><li>Large heap applications (hundreds of GB to TB)</li><li>Latency-critical services</li><li>Applications that can&rsquo;t tolerate pause time variance</li></ul><h2 id="12-comparison-of-modern-collectors">12. Comparison of Modern Collectors</h2><table><thead><tr><th>Collector</th><th>Pause Time</th><th>Throughput</th><th>Memory Overhead</th><th>Best For</th></tr></thead><tbody><tr><td>Parallel</td><td>High (seconds)</td><td>Highest</td><td>Low</td><td>Batch processing</td></tr><tr><td>G1</td><td>Medium (50-200ms)</td><td>Good</td><td>Medium (RSets)</td><td>General purpose</td></tr><tr><td>Shenandoah</td><td>Low (&lt; 10ms)</td><td>Lower</td><td>Medium (Brooks)</td><td>Latency-sensitive</td></tr><tr><td>ZGC</td><td>Ultra-low (&lt; 1ms)</td><td>Lower</td><td>Higher (multi-map)</td><td>Large heaps, strict latency</td></tr></tbody></table><h3 id="121-choosing-a-collector">12.1 Choosing a Collector</h3><p><strong>Use Parallel GC when:</strong></p><ul><li>Throughput is the only concern</li><li>Pauses are acceptable (batch jobs)</li><li>Heap is moderate size (&lt; 4GB)</li></ul><p><strong>Use G1 when:</strong></p><ul><li>Balanced throughput and latency needed</li><li>Heap is large (4GB+)</li><li>Pause time predictability matters</li></ul><p><strong>Use Shenandoah when:</strong></p><ul><li>Pause times must be &lt; 10ms</li><li>Some throughput can be sacrificed</li><li>Heap is large but not huge</li></ul><p><strong>Use ZGC when:</strong></p><ul><li>Pause times must be &lt; 1ms</li><li>Heap is very large (100GB+)</li><li>Running on modern 64-bit hardware</li></ul><h2 id="13-gc-in-other-languages">13. GC in Other Languages</h2><h3 id="131-gos-gc">13.1 Go&rsquo;s GC</h3><p>Go uses a concurrent, tri-color mark-and-sweep collector:</p><ul><li><strong>Non-generational:</strong> Treats all objects equally</li><li><strong>Non-compacting:</strong> Uses size-segregated allocation to reduce fragmentation</li><li><strong>Very low pauses:</strong> Typically &lt; 1ms</li><li><strong>Write barriers:</strong> Hybrid barrier for concurrent marking</li></ul><p>Go optimizes for low latency over throughput, matching its target of network services.</p><h3 id="132-nets-gc">13.2 .NET&rsquo;s GC</h3><p>.NET has a sophisticated generational collector:</p><ul><li><strong>Three generations:</strong> Gen0 (short-lived), Gen1 (medium), Gen2 (long-lived)</li><li><strong>Server vs. Workstation:</strong> Different configurations for different workloads</li><li><strong>Background GC:</strong> Concurrent collection of Gen2</li><li><strong>Large Object Heap:</strong> Separate heap for large objects (> 85KB)</li></ul><h3 id="133-pythons-gc">13.3 Python&rsquo;s GC</h3><p>Python combines reference counting with generational cycle detection:</p><ul><li><strong>Reference counting:</strong> Immediate reclamation, no cycles</li><li><strong>Cycle detector:</strong> Generational tracing for cycles</li><li><strong>GIL interaction:</strong> GC runs under the Global Interpreter Lock</li></ul><p>The reference counting base makes Python&rsquo;s GC deterministic for most objects.</p><h3 id="134-rust-no-gc">13.4 Rust: No GC</h3><p>Rust proves that some applications don&rsquo;t need GC:</p><ul><li><strong>Ownership system:</strong> Compiler tracks lifetimes</li><li><strong>Automatic deallocation:</strong> Drop trait called at scope exit</li><li><strong>No runtime overhead:</strong> Memory management resolved at compile time</li></ul><p>The trade-off is programmer effort and learning curve.</p><h2 id="14-tuning-garbage-collection">14. Tuning Garbage Collection</h2><h3 id="141-measuring-gc-performance">14.1 Measuring GC Performance</h3><p>Key metrics to monitor:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># JVM GC logging</span>
</span></span><span style=display:flex><span>java -Xlog:gc*:file<span style=color:#ff7b72;font-weight:700>=</span>gc.log:time,uptime:filecount<span style=color:#ff7b72;font-weight:700>=</span>5,filesize<span style=color:#ff7b72;font-weight:700>=</span>10M MyApp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Important metrics:</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Pause times (p50, p99, max)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Throughput (time not in GC)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Allocation rate</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Promotion rate</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Live data size</span>
</span></span></code></pre></div><h3 id="142-common-tuning-parameters">14.2 Common Tuning Parameters</h3><p><strong>Heap sizing:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span>-Xms4g -Xmx4g          <span style=color:#8b949e;font-style:italic># Fixed heap size (recommended for production)</span>
</span></span><span style=display:flex><span>-XX:MaxRAMPercentage<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>75</span> <span style=color:#8b949e;font-style:italic># Use 75% of container memory</span>
</span></span></code></pre></div><p><strong>Generation sizing (G1):</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span>-XX:NewRatio<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>2</span>          <span style=color:#8b949e;font-style:italic># Old gen is 2x young gen</span>
</span></span><span style=display:flex><span>-XX:G1NewSizePercent<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>5</span>  <span style=color:#8b949e;font-style:italic># Min young gen as % of heap</span>
</span></span><span style=display:flex><span>-XX:G1MaxNewSizePercent<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>60</span>  <span style=color:#8b949e;font-style:italic># Max young gen</span>
</span></span></code></pre></div><p><strong>Pause time targets:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span>-XX:MaxGCPauseMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>200</span>      <span style=color:#8b949e;font-style:italic># G1, ZGC, Shenandoah</span>
</span></span><span style=display:flex><span>-XX:GCPauseIntervalMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>500</span> <span style=color:#8b949e;font-style:italic># Minimum time between pauses</span>
</span></span></code></pre></div><h3 id="143-tuning-philosophy">14.3 Tuning Philosophy</h3><ol><li><strong>Start with defaults:</strong> Modern collectors are well-tuned</li><li><strong>Measure, don&rsquo;t guess:</strong> Use GC logs and metrics</li><li><strong>Understand the workload:</strong> Allocation rate, object lifetimes, live set size</li><li><strong>Make one change at a time:</strong> Isolate effects</li><li><strong>Test under production load:</strong> Synthetic benchmarks can be misleading</li></ol><h3 id="144-common-issues-and-solutions">14.4 Common Issues and Solutions</h3><p><strong>Long young GC pauses:</strong></p><ul><li>Reduce young generation size</li><li>Check for large object allocation</li><li>Verify promotion rate isn&rsquo;t too high</li></ul><p><strong>Frequent full GCs:</strong></p><ul><li>Increase heap size</li><li>Check for memory leaks</li><li>Tune old generation size</li></ul><p><strong>High GC CPU usage:</strong></p><ul><li>Reduce allocation rate</li><li>Use object pooling</li><li>Consider off-heap storage</li></ul><h2 id="15-advanced-topics">15. Advanced Topics</h2><h3 id="151-finalizers-and-phantom-references">15.1 Finalizers and Phantom References</h3><p>Java&rsquo;s finalization is problematic:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#ff7b72>protected</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>finalize</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// Don&#39;t do this!</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// - Unpredictable timing</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// - Can resurrect objects</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// - Delays collection</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Use <code>Cleaner</code> or <code>PhantomReference</code> instead:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span>Cleaner<span style=color:#6e7681> </span>cleaner<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>Cleaner.create();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>cleaner.register(object,<span style=color:#6e7681> </span>()<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>-&gt;</span><span style=color:#6e7681> </span>cleanup());<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id="152-off-heap-memory">15.2 Off-Heap Memory</h3><p>Avoid GC overhead by allocating outside the heap:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span>ByteBuffer<span style=color:#6e7681> </span>buffer<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>ByteBuffer.allocateDirect(1024<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#6e7681> </span>1024);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Memory is off-heap, managed by OS</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p>Libraries like Chronicle Map and MapDB use off-heap storage for large data sets.</p><h3 id="153-escape-analysis-and-allocation-elimination">15.3 Escape Analysis and Allocation Elimination</h3><p>JIT compilers can eliminate allocations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>process</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>Point<span style=color:#6e7681> </span>p<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Point(1,<span style=color:#6e7681> </span>2);<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Might not allocate!</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>p.x<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span>p.y;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>If <code>p</code> doesn&rsquo;t escape the method, the JIT can:</p><ul><li><strong>Scalar replacement:</strong> Replace object with its fields</li><li><strong>Stack allocation:</strong> Allocate on stack instead of heap</li><li><strong>Elimination:</strong> Remove allocation entirely if unused</li></ul><h3 id="154-numa-aware-gc">15.4 NUMA-Aware GC</h3><p>On NUMA systems, memory access latency varies:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────┐     ┌─────────────┐
</span></span><span style=display:flex><span>│   CPU 0     │     │   CPU 1     │
</span></span><span style=display:flex><span>│  Local Mem  │────▶│  Remote Mem │ Slower!
</span></span><span style=display:flex><span>└─────────────┘     └─────────────┘
</span></span></code></pre></div><p>NUMA-aware collectors try to:</p><ul><li>Allocate objects on the local node</li><li>Keep related objects on the same node</li><li>Balance collector threads across nodes</li></ul><p>G1 and ZGC have experimental NUMA support.</p><h2 id="16-the-future-of-gc">16. The Future of GC</h2><h3 id="161-generational-zgc">16.1 Generational ZGC</h3><p>Coming in Java 21+, generational ZGC adds generations to ZGC:</p><ul><li>Young generation collected more frequently</li><li>Old generation collected concurrently</li><li>Better throughput than non-generational ZGC</li><li>Same ultra-low pause times</li></ul><h3 id="162-value-types">16.2 Value Types</h3><p>Project Valhalla brings value types to Java:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span>value<span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Point</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>x;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>y;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Value types are:</p><ul><li>Allocated inline (no object header)</li><li>Passed by value (no references)</li><li>No identity (can&rsquo;t synchronize)</li></ul><p>This dramatically reduces allocation rate and GC pressure for many workloads.</p><h3 id="163-gc-for-persistent-memory">16.3 GC for Persistent Memory</h3><p>NVM (Non-Volatile Memory) changes GC requirements:</p><ul><li>Objects survive process restarts</li><li>Must handle crash consistency</li><li>Different performance characteristics than DRAM</li></ul><p>Research is ongoing for GC designs that handle persistent heaps.</p><h3 id="164-machine-learning-for-gc">16.4 Machine Learning for GC</h3><p>ML can optimize GC decisions:</p><ul><li>Predict object lifetimes for better tenuring</li><li>Optimize collection timing based on allocation patterns</li><li>Tune parameters automatically based on workload</li></ul><p>Early research shows promising results, but production adoption is limited.</p><h2 id="17-real-world-gc-war-stories">17. Real-World GC War Stories</h2><p>Understanding theory is valuable, but seeing how GC affects real systems cements the knowledge. Here are instructive examples from production environments.</p><h3 id="171-the-twitter-fail-whale">17.1 The Twitter Fail Whale</h3><p>In Twitter&rsquo;s early days, long GC pauses contributed to their infamous &ldquo;Fail Whale&rdquo; error page. Their Ruby application used a stop-the-world collector that would pause for seconds under load.</p><p>The solution involved multiple strategies:</p><ul><li>Moving to a concurrent JVM-based service architecture</li><li>Implementing aggressive caching to reduce object allocation</li><li>Breaking monolithic services into smaller, more manageable heaps</li><li>Careful tuning of young generation sizes to match object lifetimes</li></ul><p>The lesson: GC pause times scale with live data. Smaller heaps mean shorter pauses.</p><h3 id="172-linkedins-g1-migration">17.2 LinkedIn&rsquo;s G1 Migration</h3><p>LinkedIn documented their migration from CMS to G1 for their large-scale Java services. Key findings:</p><ul><li>G1 reduced tail latency variance significantly</li><li>Full GC events dropped from weekly to nearly never</li><li>Memory overhead increased due to remembered sets</li><li>Initial tuning was critical—default settings weren&rsquo;t optimal</li></ul><p>They recommended:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># LinkedIn&#39;s G1 starting configuration</span>
</span></span><span style=display:flex><span>-XX:+UseG1GC
</span></span><span style=display:flex><span>-XX:MaxGCPauseMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>100</span>
</span></span><span style=display:flex><span>-XX:G1HeapRegionSize<span style=color:#ff7b72;font-weight:700>=</span>32m
</span></span><span style=display:flex><span>-XX:InitiatingHeapOccupancyPercent<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>35</span>
</span></span></code></pre></div><h3 id="173-discords-jvm-to-go-migration">17.3 Discord&rsquo;s JVM to Go Migration</h3><p>Discord migrated their Read States service from JVM to Go specifically due to GC issues:</p><ul><li>The service had 250 million messages to track</li><li>JVM GC pauses caused latency spikes every few minutes</li><li>Large heap size (300GB) made pauses unavoidable</li></ul><p>Go&rsquo;s GC, designed for low latency, provided:</p><ul><li>Sub-millisecond pauses</li><li>More predictable performance</li><li>Lower memory overhead for their data structure patterns</li></ul><p>This illustrates that sometimes the right fix isn&rsquo;t tuning—it&rsquo;s changing the platform.</p><h3 id="174-azuls-pauseless-gc">17.4 Azul&rsquo;s Pauseless GC</h3><p>Azul Systems built specialized hardware and software for pauseless GC:</p><ul><li>Custom CPU with hardware read barriers</li><li>C4 collector with concurrent marking and compaction</li><li>Pauses consistently under 1ms for heaps over 100GB</li></ul><p>While expensive, Azul proved that GC pauses aren&rsquo;t inevitable—they&rsquo;re engineering trade-offs.</p><h2 id="18-gc-friendly-programming-patterns">18. GC-Friendly Programming Patterns</h2><p>Good code works with the GC, not against it. These patterns reduce allocation pressure and improve collection efficiency.</p><h3 id="181-object-pooling">18.1 Object Pooling</h3><p>Instead of allocating new objects, reuse them:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>ConnectionPool</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>final</span><span style=color:#6e7681> </span>Queue<span style=color:#ff7b72;font-weight:700>&lt;</span>Connection<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>pool<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ConcurrentLinkedQueue<span style=color:#ff7b72;font-weight:700>&lt;&gt;</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>Connection<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>acquire</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>Connection<span style=color:#6e7681> </span>conn<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>pool.poll();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(conn<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span><span style=color:#79c0ff>null</span>)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>            </span>conn<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Connection();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>conn;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>release</span>(Connection<span style=color:#6e7681> </span>conn)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>conn.reset();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>pool.offer(conn);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Pooling is especially effective for:</p><ul><li>Large objects (reduce allocation cost)</li><li>Frequently allocated objects (reduce GC pressure)</li><li>Objects with expensive initialization</li></ul><h3 id="182-avoiding-boxing">18.2 Avoiding Boxing</h3><p>Primitive boxing creates garbage:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Bad: Creates Integer objects</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>Integer<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>values<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ArrayList<span style=color:#ff7b72;font-weight:700>&lt;&gt;</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>0;<span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#6e7681> </span>1000000;<span style=color:#6e7681> </span>i<span style=color:#ff7b72;font-weight:700>++</span>)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>values.add(i);<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Autoboxing creates Integer</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Better: Use primitive collections</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>IntList<span style=color:#6e7681> </span>values<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>IntArrayList();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>0;<span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#6e7681> </span>1000000;<span style=color:#6e7681> </span>i<span style=color:#ff7b72;font-weight:700>++</span>)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>values.add(i);<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// No boxing</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Libraries like Eclipse Collections, FastUtil, and Trove provide primitive collections.</p><h3 id="183-string-optimization">18.3 String Optimization</h3><p>Strings are allocation-heavy:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Bad: Creates many intermediate strings</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>String<span style=color:#6e7681> </span>result<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(String<span style=color:#6e7681> </span>s<span style=color:#6e7681> </span>:<span style=color:#6e7681> </span>strings)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>result<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+=</span><span style=color:#6e7681> </span>s;<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// New String each iteration</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Better: StringBuilder</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>StringBuilder<span style=color:#6e7681> </span>sb<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringBuilder();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(String<span style=color:#6e7681> </span>s<span style=color:#6e7681> </span>:<span style=color:#6e7681> </span>strings)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>sb.append(s);<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Modifies buffer in place</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>String<span style=color:#6e7681> </span>result<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>sb.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Even better: String.join() or Stream.collect()</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>String<span style=color:#6e7681> </span>result<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>String.join(<span style=color:#a5d6ff>&#34;&#34;</span>,<span style=color:#6e7681> </span>strings);<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id="184-lazy-initialization">18.4 Lazy Initialization</h3><p>Don&rsquo;t allocate until needed:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LazyHolder</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span>ExpensiveObject<span style=color:#6e7681> </span>obj;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>ExpensiveObject<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>get</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(obj<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span><span style=color:#79c0ff>null</span>)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>            </span>obj<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ExpensiveObject();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>obj;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>For thread safety, use double-checked locking or holder class pattern.</p><h3 id="185-off-heap-data-structures">18.5 Off-Heap Data Structures</h3><p>For large data sets, consider off-heap storage:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// On-heap: 1 million entries = ~40MB + GC pressure</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>Map<span style=color:#ff7b72;font-weight:700>&lt;</span>Long,<span style=color:#6e7681> </span>Long<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>onHeap<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>HashMap<span style=color:#ff7b72;font-weight:700>&lt;&gt;</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Off-heap: Same data, no GC impact</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>Chronicle<span style=color:#6e7681> </span>chronicle<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>ChronicleMapBuilder<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>.of(Long.class,<span style=color:#6e7681> </span>Long.class)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>.entries(1_000_000)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>.create();<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Libraries like Chronicle Map, MapDB, and RocksDB provide off-heap alternatives.</p><h3 id="186-allocation-free-algorithms">18.6 Allocation-Free Algorithms</h3><p>Some algorithms can avoid allocation entirely:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Allocating version</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>Integer<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>findPrimes</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>max)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>Integer<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>primes<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ArrayList<span style=color:#ff7b72;font-weight:700>&lt;&gt;</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// ... populate list</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>primes;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Allocation-free version</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>forEachPrime</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>max,<span style=color:#6e7681> </span>IntConsumer<span style=color:#6e7681> </span>consumer)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// ... call consumer.accept() for each prime</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>The callback pattern moves allocation to the caller&rsquo;s choice.</p><h2 id="19-debugging-gc-issues">19. Debugging GC Issues</h2><p>When GC becomes a problem, systematic debugging is essential.</p><h3 id="191-gc-logging-best-practices">19.1 GC Logging Best Practices</h3><p>Enable comprehensive logging:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Java 11+ unified logging</span>
</span></span><span style=display:flex><span>java -Xlog:gc*<span style=color:#ff7b72;font-weight:700>=</span>info:file<span style=color:#ff7b72;font-weight:700>=</span>gc.log:time,uptime,level,tags:filecount<span style=color:#ff7b72;font-weight:700>=</span>10,filesize<span style=color:#ff7b72;font-weight:700>=</span>100m
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Key patterns to grep:</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - &#34;Pause&#34; - STW events</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - &#34;Concurrent&#34; - Background work</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - &#34;Allocation Failure&#34; - Why GC triggered</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - &#34;Promotion Failure&#34; - Tenuring problems</span>
</span></span></code></pre></div><h3 id="192-key-metrics-to-monitor">19.2 Key Metrics to Monitor</h3><p>Track these in production:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Using JMX</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(GarbageCollectorMXBean<span style=color:#6e7681> </span>gc<span style=color:#6e7681> </span>:<span style=color:#6e7681> </span>ManagementFactory.getGarbageCollectorMXBeans())<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>System.out.println(gc.getName()<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;: &#34;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>gc.getCollectionCount()<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34; collections, &#34;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>gc.getCollectionTime()<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34; ms total&#34;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Important metrics:</p><ul><li><strong>GC frequency:</strong> Collections per minute</li><li><strong>GC duration:</strong> p50, p99, max pause times</li><li><strong>Throughput:</strong> Time not spent in GC</li><li><strong>Allocation rate:</strong> MB/s of new allocations</li><li><strong>Promotion rate:</strong> MB/s promoted to old generation</li><li><strong>Live data size:</strong> Old gen occupancy after full GC</li></ul><h3 id="193-heap-dump-analysis">19.3 Heap Dump Analysis</h3><p>When you suspect a leak:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Trigger heap dump</span>
</span></span><span style=display:flex><span>jcmd &lt;pid&gt; GC.heap_dump /tmp/heap.hprof
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Analyze with Eclipse MAT, VisualVM, or YourKit</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Look for:</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Dominator trees (what holds most memory)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Leak suspects (unexpected retainers)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Duplicate objects (repeated allocations)</span>
</span></span></code></pre></div><h3 id="194-allocation-profiling">19.4 Allocation Profiling</h3><p>Find allocation hotspots:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Java Flight Recorder</span>
</span></span><span style=display:flex><span>java -XX:+FlightRecorder -XX:StartFlightRecording<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>duration</span><span style=color:#ff7b72;font-weight:700>=</span>60s,filename<span style=color:#ff7b72;font-weight:700>=</span>profile.jfr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># async-profiler for allocation profiling</span>
</span></span><span style=display:flex><span>./profiler.sh -e alloc -f alloc.html &lt;pid&gt;
</span></span></code></pre></div><h3 id="195-common-gc-anti-patterns">19.5 Common GC Anti-Patterns</h3><p><strong>Humongous allocations in G1:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// G1 region size = 32MB</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>byte</span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>huge<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span><span style=color:#ff7b72>byte</span><span style=color:#ff7b72;font-weight:700>[</span>33<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#6e7681> </span>1024<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#6e7681> </span>1024<span style=color:#ff7b72;font-weight:700>]</span>;<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Humongous allocation!</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// These are expensive and can cause fragmentation</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p><strong>Finalizer abuse:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Finalizers delay collection by at least one GC cycle</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>protected</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>finalize</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>closeResource();<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Don&#39;t do this!</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Use try-with-resources instead</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>(Resource<span style=color:#6e7681> </span>r<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Resource())<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// ...</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p><strong>Reference leaks:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Common leak: static collections</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>static</span><span style=color:#6e7681> </span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>Object<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>cache<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ArrayList<span style=color:#ff7b72;font-weight:700>&lt;&gt;</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>process</span>(Object<span style=color:#6e7681> </span>o)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>cache.add(o);<span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Never removed! Memory leak.</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h2 id="20-gc-across-different-workloads">20. GC Across Different Workloads</h2><p>Different applications have different GC needs. Here&rsquo;s how to think about GC for various workload types.</p><h3 id="201-batch-processing">20.1 Batch Processing</h3><p>Characteristics:</p><ul><li>Large data volumes</li><li>Throughput matters more than latency</li><li>Predictable workload patterns</li></ul><p>Recommendations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Maximize throughput with Parallel GC</span>
</span></span><span style=display:flex><span>-XX:+UseParallelGC
</span></span><span style=display:flex><span>-XX:ParallelGCThreads<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>8</span>
</span></span><span style=display:flex><span>-Xms16g -Xmx16g
</span></span></code></pre></div><h3 id="202-web-services">20.2 Web Services</h3><p>Characteristics:</p><ul><li>Request-response patterns</li><li>Latency-sensitive</li><li>Variable load</li></ul><p>Recommendations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># G1 for balanced performance</span>
</span></span><span style=display:flex><span>-XX:+UseG1GC
</span></span><span style=display:flex><span>-XX:MaxGCPauseMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>50</span>
</span></span><span style=display:flex><span>-XX:G1HeapRegionSize<span style=color:#ff7b72;font-weight:700>=</span>16m
</span></span></code></pre></div><h3 id="203-trading-systems">20.3 Trading Systems</h3><p>Characteristics:</p><ul><li>Ultra-low latency required</li><li>Predictable worst-case performance</li><li>Often Java + native code</li></ul><p>Recommendations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># ZGC for minimal pauses</span>
</span></span><span style=display:flex><span>-XX:+UseZGC
</span></span><span style=display:flex><span>-XX:SoftMaxHeapSize<span style=color:#ff7b72;font-weight:700>=</span>8g
</span></span><span style=display:flex><span>-XX:ZCollectionInterval<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>0</span>  <span style=color:#8b949e;font-style:italic># Only collect when needed</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Or completely avoid GC in hot path</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Pre-allocate all objects</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Use primitive arrays</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># - Off-heap data structures</span>
</span></span></code></pre></div><h3 id="204-big-data-spark-flink">20.4 Big Data (Spark, Flink)</h3><p>Characteristics:</p><ul><li>Very large heaps</li><li>Mix of long-lived and short-lived data</li><li>Managed frameworks with their own memory management</li></ul><p>Recommendations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Often use aggressive young gen sizing</span>
</span></span><span style=display:flex><span>-XX:+UseG1GC
</span></span><span style=display:flex><span>-XX:NewRatio<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>1</span>  <span style=color:#8b949e;font-style:italic># Equal young and old</span>
</span></span><span style=display:flex><span>-XX:MaxGCPauseMillis<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>200</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Spark-specific: configure off-heap memory</span>
</span></span><span style=display:flex><span>spark.memory.offHeap.enabled<span style=color:#ff7b72;font-weight:700>=</span>true
</span></span><span style=display:flex><span>spark.memory.offHeap.size<span style=color:#ff7b72;font-weight:700>=</span>8g
</span></span></code></pre></div><h2 id="21-summary">21. Summary</h2><p>Garbage collection has evolved from simple mark-and-sweep to sophisticated concurrent collectors:</p><ul><li><strong>Reference counting</strong> is simple but can&rsquo;t handle cycles</li><li><strong>Mark-and-sweep</strong> handles cycles but fragments memory</li><li><strong>Copying collection</strong> compacts but wastes space</li><li><strong>Generational collection</strong> exploits the weak generational hypothesis</li><li><strong>Concurrent collectors</strong> minimize pause times at the cost of throughput</li></ul><p>Modern collectors like G1, Shenandoah, and ZGC offer different trade-offs:</p><ul><li><strong>G1:</strong> Balanced performance, predictable pauses, good default choice</li><li><strong>Shenandoah:</strong> Sub-10ms pauses, concurrent compaction</li><li><strong>ZGC:</strong> Sub-millisecond pauses, scales to terabytes</li></ul><p>Key insights for practitioners:</p><ol><li><strong>Choose the right collector:</strong> Match GC to workload characteristics</li><li><strong>Measure before tuning:</strong> GC logs are your friend</li><li><strong>Reduce allocation rate:</strong> The best GC is no GC</li><li><strong>Understand trade-offs:</strong> Latency vs. throughput vs. memory</li><li><strong>Write GC-friendly code:</strong> Pooling, primitive collections, lazy initialization</li></ol><p>Garbage collection remains an active research area. As applications demand ever-larger heaps and ever-lower latencies, collectors continue to evolve. Understanding GC internals helps you write better code, tune more effectively, and choose the right tools for your applications.</p><p>The collector that runs invisibly in the background is the result of decades of computer science research. Appreciate it—and understand it—every time you allocate an object without worrying about when to free it.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/systems/>systems</a>, <a href=/categories/performance/>performance</a></div><div>Tags:
<a href=/tags/garbage-collection/>#garbage-collection</a>, <a href=/tags/memory/>#memory</a>, <a href=/tags/jvm/>#jvm</a>, <a href=/tags/performance/>#performance</a>, <a href=/tags/gc/>#gc</a>, <a href=/tags/algorithms/>#algorithms</a>, <a href=/tags/concurrency/>#concurrency</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>