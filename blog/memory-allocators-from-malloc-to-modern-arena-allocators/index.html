<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>Memory Allocators: From malloc to Modern Arena Allocators · Leonardo Benicio</title><meta name=description content="A deep dive into memory allocation strategies, from the classic malloc implementations to modern arena allocators, jemalloc, tcmalloc, and custom allocators that power high-performance systems."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/memory-allocators-from-malloc-to-modern-arena-allocators/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="Memory Allocators: From malloc to Modern Arena Allocators · Leonardo Benicio"><meta property="og:description" content="A deep dive into memory allocation strategies, from the classic malloc implementations to modern arena allocators, jemalloc, tcmalloc, and custom allocators that power high-performance systems."><meta property="og:url" content="https://blog.lbenicio.dev/blog/memory-allocators-from-malloc-to-modern-arena-allocators/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/memory-allocators-malloc-to-arena.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Memory Allocators: From malloc to Modern Arena Allocators · Leonardo Benicio"><meta name=twitter:description content="A deep dive into memory allocation strategies, from the classic malloc implementations to modern arena allocators, jemalloc, tcmalloc, and custom allocators that power high-performance systems."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/memory-allocators-from-malloc-to-modern-arena-allocators/","name":"Memory Allocators From Malloc to Modern Arena Allocators","position":3}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Memory Allocators From Malloc to Modern Arena Allocators</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Memory Allocators From Malloc to Modern Arena Allocators</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">Memory Allocators: From malloc to Modern Arena Allocators</h1><div class="c277478 c3ecea6 c8fb24a">2023-09-14
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/memory-allocators-malloc-to-arena.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">A deep dive into memory allocation strategies, from the classic malloc implementations to modern arena allocators, jemalloc, tcmalloc, and custom allocators that power high-performance systems.</p></header><div class="content"><p>Memory allocation is one of those fundamental operations that most programmers take for granted. You call <code>malloc()</code>, memory appears; you call <code>free()</code>, it goes away. But beneath this simple interface lies a fascinating world of algorithms, trade-offs, and optimizations that can make or break your application&rsquo;s performance. This post explores memory allocation from first principles to modern high-performance allocators.</p><h2 id="1-why-memory-allocation-matters">1. Why Memory Allocation Matters</h2><p>Consider a web server handling thousands of requests per second. Each request might allocate dozens of objects: strings, buffers, data structures. If each allocation takes 1 microsecond, and a request needs 50 allocations, that&rsquo;s 50 microseconds just in allocation overhead—potentially more than the actual request processing time.</p><p>Memory allocation affects:</p><ul><li><strong>Latency:</strong> Allocation time directly impacts response times</li><li><strong>Throughput:</strong> Contention on allocator locks limits parallelism</li><li><strong>Memory efficiency:</strong> Fragmentation wastes precious RAM</li><li><strong>Cache performance:</strong> Allocation patterns affect data locality</li><li><strong>Predictability:</strong> Allocation time variance affects tail latencies</li></ul><p>Understanding allocators helps you choose the right one, configure it properly, or even build custom allocators for specific workloads.</p><h2 id="2-the-allocators-challenge">2. The Allocator&rsquo;s Challenge</h2><p>An allocator must solve several competing problems:</p><h3 id="21-the-fundamental-operations">2.1 The Fundamental Operations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>size_t</span> size);    <span style=color:#8b949e;font-style:italic>// Allocate &#39;size&#39; bytes
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr);          <span style=color:#8b949e;font-style:italic>// Release memory
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>realloc</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr, <span style=color:#ff7b72>size_t</span> size);  <span style=color:#8b949e;font-style:italic>// Resize allocation
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>calloc</span>(<span style=color:#ff7b72>size_t</span> n, <span style=color:#ff7b72>size_t</span> size);    <span style=color:#8b949e;font-style:italic>// Allocate and zero
</span></span></span></code></pre></div><p>These operations seem simple, but consider the constraints:</p><ul><li><strong>Size variety:</strong> Allocations range from 1 byte to gigabytes</li><li><strong>Lifetime uncertainty:</strong> Objects live milliseconds to hours</li><li><strong>No compaction:</strong> Unlike managed languages, C/C++ can&rsquo;t move objects</li><li><strong>Thread safety:</strong> Multiple threads allocate concurrently</li><li><strong>Performance:</strong> Both allocation and deallocation must be fast</li></ul><h3 id="22-fragmentation-the-central-problem">2.2 Fragmentation: The Central Problem</h3><p>Fragmentation is the allocator&rsquo;s nemesis. Two types exist:</p><p><strong>External fragmentation:</strong> Free memory exists but is scattered in pieces too small to satisfy requests.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Memory: [USED][FREE:8][USED][FREE:16][USED][FREE:8][USED]
</span></span><span style=display:flex><span>Request: 32 bytes
</span></span><span style=display:flex><span>Result: FAILURE (despite 32 free bytes total)
</span></span></code></pre></div><p><strong>Internal fragmentation:</strong> Allocated blocks contain unused space due to alignment or size class rounding.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Request: 17 bytes
</span></span><span style=display:flex><span>Allocated: 32 bytes (next size class)
</span></span><span style=display:flex><span>Waste: 15 bytes internal fragmentation
</span></span></code></pre></div><p>Every allocator design involves trade-offs between these fragmentation types, speed, and memory overhead.</p><h2 id="3-classic-algorithms">3. Classic Algorithms</h2><h3 id="31-first-fit">3.1 First-Fit</h3><p>Search the free list for the first block large enough:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>first_fit</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> current <span style=color:#ff7b72;font-weight:700>=</span> free_list;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (current) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> size) {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> current;  <span style=color:#8b949e;font-style:italic>// Found!
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#ff7b72;font-weight:700>=</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> NULL;  <span style=color:#8b949e;font-style:italic>// No fit
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Simple, fast for small lists
<strong>Cons:</strong> Tends to fragment the beginning of memory; large allocations become slow</p><h3 id="32-best-fit">3.2 Best-Fit</h3><p>Search for the smallest block that fits:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>best_fit</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> best <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> current <span style=color:#ff7b72;font-weight:700>=</span> free_list;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (current) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> size) {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>best <span style=color:#ff7b72;font-weight:700>||</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&lt;</span> best<span style=color:#ff7b72;font-weight:700>-&gt;</span>size) {
</span></span><span style=display:flex><span>                best <span style=color:#ff7b72;font-weight:700>=</span> current;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#ff7b72;font-weight:700>=</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> best;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Minimizes wasted space in each allocation
<strong>Cons:</strong> Slow (must scan entire list); creates many tiny unusable fragments</p><h3 id="33-worst-fit">3.3 Worst-Fit</h3><p>Allocate from the largest block:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>worst_fit</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> worst <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> current <span style=color:#ff7b72;font-weight:700>=</span> free_list;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (current) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> size) {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>worst <span style=color:#ff7b72;font-weight:700>||</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&gt;</span> worst<span style=color:#ff7b72;font-weight:700>-&gt;</span>size) {
</span></span><span style=display:flex><span>                worst <span style=color:#ff7b72;font-weight:700>=</span> current;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#ff7b72;font-weight:700>=</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> worst;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Leaves larger remaining fragments (potentially more useful)
<strong>Cons:</strong> Slow; fragments large blocks quickly</p><h3 id="34-next-fit">3.4 Next-Fit</h3><p>Like first-fit, but start searching where the last search ended:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>static</span> Block<span style=color:#ff7b72;font-weight:700>*</span> search_start <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>next_fit</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>search_start) search_start <span style=color:#ff7b72;font-weight:700>=</span> free_list;
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> start <span style=color:#ff7b72;font-weight:700>=</span> search_start;
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> current <span style=color:#ff7b72;font-weight:700>=</span> start;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (current<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> size) {
</span></span><span style=display:flex><span>            search_start <span style=color:#ff7b72;font-weight:700>=</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>?</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span><span style=color:#79c0ff;font-weight:700>next</span> : free_list;
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> current;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#ff7b72;font-weight:700>=</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>?</span> current<span style=color:#ff7b72;font-weight:700>-&gt;</span><span style=color:#79c0ff;font-weight:700>next</span> : free_list;
</span></span><span style=display:flex><span>    } <span style=color:#ff7b72>while</span> (current <span style=color:#ff7b72;font-weight:700>!=</span> start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Spreads allocations across memory; better than first-fit for fragmentation
<strong>Cons:</strong> Still O(n) worst case</p><h2 id="4-free-list-organizations">4. Free List Organizations</h2><p>How you organize free blocks dramatically affects performance.</p><h3 id="41-implicit-free-lists">4.1 Implicit Free Lists</h3><p>Store size in block headers; traverse all blocks (used and free):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>[Header:32|USED][Data...][Header:64|FREE][Data...][Header:16|USED]
</span></span></code></pre></div><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>next_block</span>(Block<span style=color:#ff7b72;font-weight:700>*</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> (Block<span style=color:#ff7b72;font-weight:700>*</span>)((<span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span>)b <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#ff7b72>sizeof</span>(Header) <span style=color:#ff7b72;font-weight:700>+</span> b<span style=color:#ff7b72;font-weight:700>-&gt;</span>size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Simple; no extra pointers
<strong>Cons:</strong> Must traverse used blocks to find free ones; slow</p><h3 id="42-explicit-free-lists">4.2 Explicit Free Lists</h3><p>Link free blocks together:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> FreeBlock {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> size;
</span></span><span style=display:flex><span>    FreeBlock<span style=color:#ff7b72;font-weight:700>*</span> next;
</span></span><span style=display:flex><span>    FreeBlock<span style=color:#ff7b72;font-weight:700>*</span> prev;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Used blocks: [H|data][H|data][H|data]
</span></span><span style=display:flex><span>Free list:   block1 &lt;-&gt; block2 &lt;-&gt; block3
</span></span></code></pre></div><p><strong>Pros:</strong> Only traverse free blocks
<strong>Cons:</strong> Minimum block size (must fit pointers); extra pointer overhead</p><h3 id="43-segregated-free-lists">4.3 Segregated Free Lists</h3><p>Multiple free lists, one per size class:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Size class 16:   [16] -&gt; [16] -&gt; [16]
</span></span><span style=display:flex><span>Size class 32:   [32] -&gt; [32]
</span></span><span style=display:flex><span>Size class 64:   [64] -&gt; [64] -&gt; [64] -&gt; [64]
</span></span><span style=display:flex><span>Size class 128:  [128]
</span></span></code></pre></div><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define NUM_CLASSES 32
</span></span></span><span style=display:flex><span>FreeBlock<span style=color:#ff7b72;font-weight:700>*</span> free_lists[NUM_CLASSES];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>size_class</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Map size to class index
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (size <span style=color:#ff7b72;font-weight:700>&lt;=</span> <span style=color:#a5d6ff>16</span>) <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (size <span style=color:#ff7b72;font-weight:700>&lt;=</span> <span style=color:#a5d6ff>32</span>) <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// ... etc
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>size_class</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (free_lists[cls]) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>pop_from_list</span>(cls);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Try larger classes or get more memory
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> O(1) allocation for common sizes; good cache locality
<strong>Cons:</strong> Internal fragmentation from size class rounding</p><h3 id="44-buddy-allocators">4.4 Buddy Allocators</h3><p>Split memory into power-of-two blocks; merge adjacent &ldquo;buddies&rdquo; on free:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Initial: [1024]
</span></span><span style=display:flex><span>Alloc 100: Split -&gt; [512][512] -&gt; [256][256][512]
</span></span><span style=display:flex><span>           Return first 256 (wastes 156 bytes)
</span></span><span style=display:flex><span>Free:     Merge buddies back: [256][256] -&gt; [512] -&gt; [1024]
</span></span></code></pre></div><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>buddy_alloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> order <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>ceil_log2</span>(size);  <span style=color:#8b949e;font-style:italic>// Round up to power of 2
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Find smallest available block &gt;= order
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> order; i <span style=color:#ff7b72;font-weight:700>&lt;=</span> MAX_ORDER; i<span style=color:#ff7b72;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (free_lists[i]) {
</span></span><span style=display:flex><span>            Block<span style=color:#ff7b72;font-weight:700>*</span> block <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pop_free_list</span>(i);
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-style:italic>// Split if larger than needed
</span></span></span><span style=display:flex><span>            <span style=color:#ff7b72>while</span> (i <span style=color:#ff7b72;font-weight:700>&gt;</span> order) {
</span></span><span style=display:flex><span>                i<span style=color:#ff7b72;font-weight:700>--</span>;
</span></span><span style=display:flex><span>                Block<span style=color:#ff7b72;font-weight:700>*</span> buddy <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>split</span>(block);
</span></span><span style=display:flex><span>                <span style=color:#d2a8ff;font-weight:700>push_free_list</span>(buddy, i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> block;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Fast coalescing (buddy address computed via XOR); bounded fragmentation
<strong>Cons:</strong> High internal fragmentation (50% worst case); only power-of-two sizes</p><h2 id="5-coalescing-strategies">5. Coalescing Strategies</h2><p>When freeing memory, should we merge adjacent free blocks?</p><h3 id="51-immediate-coalescing">5.1 Immediate Coalescing</h3><p>Merge free blocks as soon as they&rsquo;re freed:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> block <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>get_block</span>(ptr);
</span></span><span style=display:flex><span>    block<span style=color:#ff7b72;font-weight:700>-&gt;</span>free <span style=color:#ff7b72;font-weight:700>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Check and merge with next block
</span></span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> next <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>next_block</span>(block);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (next <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> next<span style=color:#ff7b72;font-weight:700>-&gt;</span>free) {
</span></span><span style=display:flex><span>        block<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>+=</span> <span style=color:#ff7b72>sizeof</span>(Header) <span style=color:#ff7b72;font-weight:700>+</span> next<span style=color:#ff7b72;font-weight:700>-&gt;</span>size;
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>remove_from_free_list</span>(next);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Check and merge with previous block
</span></span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> prev <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>prev_block</span>(block);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (prev <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> prev<span style=color:#ff7b72;font-weight:700>-&gt;</span>free) {
</span></span><span style=display:flex><span>        prev<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>+=</span> <span style=color:#ff7b72>sizeof</span>(Header) <span style=color:#ff7b72;font-weight:700>+</span> block<span style=color:#ff7b72;font-weight:700>-&gt;</span>size;
</span></span><span style=display:flex><span>        block <span style=color:#ff7b72;font-weight:700>=</span> prev;  <span style=color:#8b949e;font-style:italic>// Merged into prev
</span></span></span><span style=display:flex><span>    } <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>add_to_free_list</span>(block);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Reduces fragmentation immediately
<strong>Cons:</strong> Expensive if allocation patterns cause repeated split/merge cycles</p><h3 id="52-deferred-coalescing">5.2 Deferred Coalescing</h3><p>Delay merging until needed (e.g., when allocation fails):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>try_allocate</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>ptr) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>coalesce_all_free_blocks</span>();
</span></span><span style=display:flex><span>        ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>try_allocate</span>(size);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Pros:</strong> Avoids unnecessary coalescing; better for alloc/free patterns with similar sizes
<strong>Cons:</strong> May delay finding suitable blocks; sudden coalescing spikes</p><h3 id="53-boundary-tags">5.3 Boundary Tags</h3><p>To coalesce with the previous block, we need to find it. Boundary tags store size at both ends:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>[Size|...data...|Size]
</span></span></code></pre></div><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>Block<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>prev_block</span>(Block<span style=color:#ff7b72;font-weight:700>*</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> prev_size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>((<span style=color:#ff7b72>size_t</span><span style=color:#ff7b72;font-weight:700>*</span>)b <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>1</span>);  <span style=color:#8b949e;font-style:italic>// Size at end of prev block
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> (Block<span style=color:#ff7b72;font-weight:700>*</span>)((<span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span>)b <span style=color:#ff7b72;font-weight:700>-</span> prev_size <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>2</span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>sizeof</span>(<span style=color:#ff7b72>size_t</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This enables O(1) backward traversal at the cost of extra space per block.</p><h2 id="6-modern-allocator-design">6. Modern Allocator Design</h2><p>Modern allocators combine multiple techniques to handle diverse workloads.</p><h3 id="61-size-classes-and-slabs">6.1 Size Classes and Slabs</h3><p>Most allocations are small. Modern allocators optimize for this:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Size classes (typical):
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 8, 16, 32, 48, 64, 80, 96, 112, 128, 192, 256, ...
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> SizeClass {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> size;
</span></span><span style=display:flex><span>    FreeList<span style=color:#ff7b72;font-weight:700>*</span> free_list;
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> partial_slabs;
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> full_slabs;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> Slab {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> memory;       <span style=color:#8b949e;font-style:italic>// Contiguous region
</span></span></span><span style=display:flex><span>    Bitmap free_slots;  <span style=color:#8b949e;font-style:italic>// Which slots are free
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> num_free;
</span></span><span style=display:flex><span>    SizeClass<span style=color:#ff7b72;font-weight:700>*</span> class;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Slabs are contiguous regions divided into fixed-size slots:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Slab for 64-byte objects:
</span></span><span style=display:flex><span>[slot0][slot1][slot2][slot3][slot4][slot5]...
</span></span><span style=display:flex><span>  ^free  ^used  ^used  ^free  ^free  ^used
</span></span></code></pre></div><p><strong>Allocation:</strong> Pop from free list or allocate from slab
<strong>Deallocation:</strong> Push to free list or return to slab</p><h3 id="62-thread-caching">6.2 Thread Caching</h3><p>Allocator lock contention kills multi-threaded performance. Solution: per-thread caches.</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>thread_local <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    FreeList<span style=color:#ff7b72;font-weight:700>*</span> caches[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cache_sizes[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>} thread_cache;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>size_class</span>(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Fast path: thread-local cache
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (thread_cache.caches[cls]) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>pop_from_cache</span>(cls);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Slow path: refill from central allocator
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>refill_cache</span>(cls);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>pop_from_cache</span>(cls);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Trade-off:</strong> Thread caches hold memory that other threads might need. Periodic rebalancing is required.</p><h3 id="63-central-and-page-heaps">6.3 Central and Page Heaps</h3><p>A multi-tier architecture:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│         Thread Cache (per-thread)           │
</span></span><span style=display:flex><span>│   Fast, lock-free, small allocations        │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│         Central Free List (shared)          │
</span></span><span style=display:flex><span>│   Batched transfers, locked                 │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│         Page Heap (large allocations)       │
</span></span><span style=display:flex><span>│   Full pages, span management               │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│         OS (mmap, sbrk)                     │
</span></span><span style=display:flex><span>│   Physical memory acquisition               │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────┘
</span></span></code></pre></div><p>Small allocations stay in thread caches. Medium allocations use central free lists. Large allocations go directly to the page heap or OS.</p><h2 id="7-jemalloc-deep-dive">7. jemalloc Deep Dive</h2><p>jemalloc (Jason Evans malloc) is used by Firefox, Facebook, Redis, and many others. Let&rsquo;s examine its design.</p><h3 id="71-architecture-overview">7.1 Architecture Overview</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│              Thread Cache                    │
</span></span><span style=display:flex><span>│   Per-thread bins for small sizes           │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│              Arenas (multiple)              │
</span></span><span style=display:flex><span>│   Thread-to-arena assignment                │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│              Bins (per arena)               │
</span></span><span style=display:flex><span>│   Size-class-specific regions               │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│              Runs and Pages                 │
</span></span><span style=display:flex><span>│   Contiguous page runs                      │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="72-size-classes">7.2 Size Classes</h3><p>jemalloc uses carefully chosen size classes to minimize internal fragmentation:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Small (&lt; 14 KiB): 8, 16, 32, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, ...
</span></span><span style=display:flex><span>Large (&gt;= 14 KiB): Multiple of page size
</span></span></code></pre></div><p>The spacing between classes is designed to limit internal fragmentation to about 20%:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Size class spacing
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Tiny: 8-byte spacing (8, 16, 24, 32, ...)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Quantum: 16-byte spacing for sizes 128-256
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Sub-page: Geometric spacing
</span></span></span></code></pre></div><h3 id="73-thread-to-arena-assignment">7.3 Thread-to-Arena Assignment</h3><p>Rather than one arena per thread (memory waste) or one global arena (contention), jemalloc assigns threads to arenas in a round-robin fashion:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Typically: num_arenas = 4 * num_cpus
</span></span></span><span style=display:flex><span>Arena<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>get_arena</span>() {
</span></span><span style=display:flex><span>    thread_local Arena<span style=color:#ff7b72;font-weight:700>*</span> cached_arena <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>cached_arena) {
</span></span><span style=display:flex><span>        cached_arena <span style=color:#ff7b72;font-weight:700>=</span> arenas[next_arena_index<span style=color:#ff7b72;font-weight:700>++</span> <span style=color:#ff7b72;font-weight:700>%</span> num_arenas];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> cached_arena;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This balances contention against memory efficiency.</p><h3 id="74-extent-based-management">7.4 Extent-Based Management</h3><p>jemalloc 5.0 introduced extents—variable-sized virtual memory regions:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> Extent {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> addr;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> size;
</span></span><span style=display:flex><span>    Arena<span style=color:#ff7b72;font-weight:700>*</span> arena;
</span></span><span style=display:flex><span>    ExtentState state;  <span style=color:#8b949e;font-style:italic>// active, dirty, muzzy, retained
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>States:</strong></p><ul><li><strong>Active:</strong> Currently in use</li><li><strong>Dirty:</strong> Recently freed, pages still in memory</li><li><strong>Muzzy:</strong> Advised to OS (MADV_FREE) but not returned</li><li><strong>Retained:</strong> Virtual address space held but pages released</li></ul><p>This enables efficient memory return to the OS while maintaining address space.</p><h3 id="75-decay-based-purging">7.5 Decay-Based Purging</h3><p>Rather than immediately returning memory to the OS (expensive) or never returning it (wasteful), jemalloc uses time-based decay:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Dirty pages decay to muzzy after dirty_decay_ms
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Muzzy pages decay to clean after muzzy_decay_ms
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Default: 10 seconds dirty, 10 seconds muzzy
</span></span></span></code></pre></div><p>This smooths out memory usage patterns and reduces system call overhead.</p><h2 id="8-tcmalloc-deep-dive">8. tcmalloc Deep Dive</h2><p>Google&rsquo;s tcmalloc (thread-caching malloc) is another major allocator, used in Chrome and many Google services.</p><h3 id="81-architecture">8.1 Architecture</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│        Front-end (per-thread cache)         │
</span></span><span style=display:flex><span>│   Lock-free allocation for common sizes     │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│        Middle-end (transfer cache)          │
</span></span><span style=display:flex><span>│   Batched transfers between front/back      │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│        Back-end (page heap)                 │
</span></span><span style=display:flex><span>│   Page-level management, OS interaction     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="82-size-classes">8.2 Size Classes</h3><p>tcmalloc&rsquo;s size classes are tuned for Google&rsquo;s workloads:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>// Small: 8 to 256 KiB
</span></span><span style=display:flex><span>8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Large: &gt; 256 KiB, directly from page heap
</span></span></code></pre></div><h3 id="83-per-cpu-caches-tcmalloc-v2">8.3 Per-CPU Caches (tcmalloc v2)</h3><p>Modern tcmalloc uses per-CPU caches instead of per-thread:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> PerCpuCache {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> objects[NUM_SIZE_CLASSES][MAX_CACHED];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> sizes[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Access current CPU&#39;s cache
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Using restartable sequences (rseq) for atomicity
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cpu <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>current_cpu</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>size_class</span>(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (per_cpu_cache[cpu].sizes[cls] <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>pop_from_cpu_cache</span>(cpu, cls);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// ... slow path
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Per-CPU caches reduce memory overhead (threads &#187; CPUs) and improve cache locality.</p><h3 id="84-huge-pages">8.4 Huge Pages</h3><p>tcmalloc supports transparent huge pages for large allocations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>allocate_large</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Round up to huge page boundary (2 MiB)
</span></span></span><span style=display:flex><span>    size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>round_up</span>(size, HUGE_PAGE_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, size, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                     MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS <span style=color:#ff7b72;font-weight:700>|</span> MAP_HUGETLB, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (ptr <span style=color:#ff7b72;font-weight:700>==</span> MAP_FAILED) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Fall back to regular pages
</span></span></span><span style=display:flex><span>        ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, size, ...);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Huge pages reduce TLB misses for large allocations.</p><h2 id="9-arena-allocators">9. Arena Allocators</h2><p>For specific workloads, custom arena allocators can dramatically outperform general-purpose allocators.</p><h3 id="91-basic-linear-allocator">9.1 Basic Linear Allocator</h3><p>The simplest arena: bump pointer allocation, no individual frees:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> LinearArena {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> base;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> current;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> end;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>arena_alloc</span>(LinearArena<span style=color:#ff7b72;font-weight:700>*</span> arena, <span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>align_up</span>(size, <span style=color:#a5d6ff>16</span>);  <span style=color:#8b949e;font-style:italic>// Alignment
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current <span style=color:#ff7b72;font-weight:700>+</span> size <span style=color:#ff7b72;font-weight:700>&gt;</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>end) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> NULL;  <span style=color:#8b949e;font-style:italic>// Out of memory
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current;
</span></span><span style=display:flex><span>    arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current <span style=color:#ff7b72;font-weight:700>+=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>arena_reset</span>(LinearArena<span style=color:#ff7b72;font-weight:700>*</span> arena) {
</span></span><span style=display:flex><span>    arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current <span style=color:#ff7b72;font-weight:700>=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>base;  <span style=color:#8b949e;font-style:italic>// &#34;Free&#34; everything at once
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Use case:</strong> Per-request allocations in servers, per-frame allocations in games.</p><h3 id="92-stack-allocator">9.2 Stack Allocator</h3><p>Like linear, but supports LIFO deallocation:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> StackArena {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> base;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> current;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> end;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> StackMarker {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> position;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>StackMarker <span style=color:#d2a8ff;font-weight:700>arena_mark</span>(StackArena<span style=color:#ff7b72;font-weight:700>*</span> arena) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> (StackMarker){arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>arena_restore</span>(StackArena<span style=color:#ff7b72;font-weight:700>*</span> arena, StackMarker marker) {
</span></span><span style=display:flex><span>    arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current <span style=color:#ff7b72;font-weight:700>=</span> marker.position;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Use case:</strong> Recursive algorithms, nested scopes.</p><h3 id="93-pool-allocator">9.3 Pool Allocator</h3><p>Fixed-size blocks, O(1) alloc and free:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> PoolArena {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> block_size;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> free_list;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> memory;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>pool_init</span>(PoolArena<span style=color:#ff7b72;font-weight:700>*</span> pool, <span style=color:#ff7b72>size_t</span> block_size, <span style=color:#ff7b72>size_t</span> count) {
</span></span><span style=display:flex><span>    pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>block_size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>align_up</span>(block_size, <span style=color:#a5d6ff>8</span>);
</span></span><span style=display:flex><span>    pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>memory <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>block_size <span style=color:#ff7b72;font-weight:700>*</span> count, ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Build free list
</span></span></span><span style=display:flex><span>    pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>size_t</span> i <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>&lt;</span> count; i<span style=color:#ff7b72;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> block <span style=color:#ff7b72;font-weight:700>=</span> pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>memory <span style=color:#ff7b72;font-weight:700>+</span> i <span style=color:#ff7b72;font-weight:700>*</span> pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>block_size;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>**</span>)block <span style=color:#ff7b72;font-weight:700>=</span> pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list;
</span></span><span style=display:flex><span>        pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> block;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>pool_alloc</span>(PoolArena<span style=color:#ff7b72;font-weight:700>*</span> pool) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list) <span style=color:#ff7b72>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> block <span style=color:#ff7b72;font-weight:700>=</span> pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list;
</span></span><span style=display:flex><span>    pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>**</span>)block;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> block;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>pool_free</span>(PoolArena<span style=color:#ff7b72;font-weight:700>*</span> pool, <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>**</span>)ptr <span style=color:#ff7b72;font-weight:700>=</span> pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list;
</span></span><span style=display:flex><span>    pool<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Use case:</strong> Game entities, network packets, any fixed-size object.</p><h3 id="94-growing-arenas">9.4 Growing Arenas</h3><p>Arenas that grow by allocating new blocks:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> GrowingArena {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>struct</span> Block {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> data;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>size_t</span> size;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>size_t</span> used;
</span></span><span style=display:flex><span>        Block<span style=color:#ff7b72;font-weight:700>*</span> next;
</span></span><span style=display:flex><span>    }<span style=color:#ff7b72;font-weight:700>*</span> current_block;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> min_block_size;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>growing_arena_alloc</span>(GrowingArena<span style=color:#ff7b72;font-weight:700>*</span> arena, <span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>align_up</span>(size, <span style=color:#a5d6ff>16</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Check current block
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>        arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>used <span style=color:#ff7b72;font-weight:700>+</span> size <span style=color:#ff7b72;font-weight:700>&lt;=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>size) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>data <span style=color:#ff7b72;font-weight:700>+</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>used;
</span></span><span style=display:flex><span>        arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>used <span style=color:#ff7b72;font-weight:700>+=</span> size;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Allocate new block
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> block_size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>max</span>(arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>min_block_size, size);
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> new_block <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>sizeof</span>(Block));
</span></span><span style=display:flex><span>    new_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>data <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, block_size, ...);
</span></span><span style=display:flex><span>    new_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>size <span style=color:#ff7b72;font-weight:700>=</span> block_size;
</span></span><span style=display:flex><span>    new_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>used <span style=color:#ff7b72;font-weight:700>=</span> size;
</span></span><span style=display:flex><span>    new_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block;
</span></span><span style=display:flex><span>    arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block <span style=color:#ff7b72;font-weight:700>=</span> new_block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> new_block<span style=color:#ff7b72;font-weight:700>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>growing_arena_free_all</span>(GrowingArena<span style=color:#ff7b72;font-weight:700>*</span> arena) {
</span></span><span style=display:flex><span>    Block<span style=color:#ff7b72;font-weight:700>*</span> block <span style=color:#ff7b72;font-weight:700>=</span> arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (block) {
</span></span><span style=display:flex><span>        Block<span style=color:#ff7b72;font-weight:700>*</span> next <span style=color:#ff7b72;font-weight:700>=</span> block<span style=color:#ff7b72;font-weight:700>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>munmap</span>(block<span style=color:#ff7b72;font-weight:700>-&gt;</span>data, block<span style=color:#ff7b72;font-weight:700>-&gt;</span>size);
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>free</span>(block);
</span></span><span style=display:flex><span>        block <span style=color:#ff7b72;font-weight:700>=</span> next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    arena<span style=color:#ff7b72;font-weight:700>-&gt;</span>current_block <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="10-memory-allocation-in-practice">10. Memory Allocation in Practice</h2><h3 id="101-choosing-an-allocator">10.1 Choosing an Allocator</h3><table><thead><tr><th>Workload</th><th>Recommended Allocator</th></tr></thead><tbody><tr><td>General purpose</td><td>System malloc or jemalloc</td></tr><tr><td>Multi-threaded server</td><td>tcmalloc or jemalloc</td></tr><tr><td>Memory-constrained</td><td>mimalloc or custom</td></tr><tr><td>Real-time</td><td>Pool allocators, no general malloc</td></tr><tr><td>Single-threaded batch</td><td>Arena allocators</td></tr><tr><td>Game engine</td><td>Custom arena + pool hierarchy</td></tr></tbody></table><h3 id="102-profiling-allocation">10.2 Profiling Allocation</h3><p>Before optimizing, measure:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># On Linux with jemalloc</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>MALLOC_CONF</span><span style=color:#ff7b72;font-weight:700>=</span>prof:true,prof_prefix:jeprof ./myapp
</span></span><span style=display:flex><span>jeprof --pdf ./myapp jeprof.*.heap &gt; heap.pdf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># With heaptrack</span>
</span></span><span style=display:flex><span>heaptrack ./myapp
</span></span><span style=display:flex><span>heaptrack_gui heaptrack.myapp.*.gz
</span></span></code></pre></div><p>Look for:</p><ul><li>Allocation hotspots (which call sites allocate most?)</li><li>Fragmentation (ratio of RSS to actual used memory)</li><li>Temporary allocations (high alloc rate with short lifetimes)</li></ul><h3 id="103-common-optimizations">10.3 Common Optimizations</h3><p><strong>Object pooling:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Instead of malloc/free per request
</span></span></span><span style=display:flex><span>Request<span style=color:#ff7b72;font-weight:700>*</span> req <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(<span style=color:#ff7b72>sizeof</span>(Request));
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// ... use ...
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>free</span>(req);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Use a pool
</span></span></span><span style=display:flex><span>Request<span style=color:#ff7b72;font-weight:700>*</span> req <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pool_get</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>request_pool);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// ... use ...
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>pool_return</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>request_pool, req);
</span></span></code></pre></div><p><strong>Arena allocation for request handling:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>handle_request</span>(Request<span style=color:#ff7b72;font-weight:700>*</span> req) {
</span></span><span style=display:flex><span>    Arena arena <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>arena_create</span>(<span style=color:#a5d6ff>64</span> <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#a5d6ff>1024</span>);  <span style=color:#8b949e;font-style:italic>// 64 KiB
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// All allocations from arena
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> buffer <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>arena_alloc</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>arena, buffer_size);
</span></span><span style=display:flex><span>    ParsedData<span style=color:#ff7b72;font-weight:700>*</span> data <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>arena_alloc</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>arena, <span style=color:#ff7b72>sizeof</span>(ParsedData));
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// ... process ...
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>arena_destroy</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>arena);  <span style=color:#8b949e;font-style:italic>// Free everything at once
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Slab allocators for kernel objects:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Linux kernel style
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> kmem_cache <span style=color:#ff7b72;font-weight:700>*</span>task_cache;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>task_cache <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>kmem_cache_create</span>(<span style=color:#a5d6ff>&#34;task_struct&#34;</span>,
</span></span><span style=display:flex><span>                               <span style=color:#ff7b72>sizeof</span>(<span style=color:#ff7b72>struct</span> task_struct),
</span></span><span style=display:flex><span>                               <span style=color:#a5d6ff>0</span>, SLAB_HWCACHE_ALIGN, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> task_struct <span style=color:#ff7b72;font-weight:700>*</span>task <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>kmem_cache_alloc</span>(task_cache, GFP_KERNEL);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// ... use ...
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>kmem_cache_free</span>(task_cache, task);
</span></span></code></pre></div><h2 id="11-memory-safety-considerations">11. Memory Safety Considerations</h2><p>Modern allocators incorporate safety features.</p><h3 id="111-guard-pages">11.1 Guard Pages</h3><p>Detect buffer overflows by placing inaccessible pages:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>safe_alloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Allocate extra pages
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> total <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>round_up</span>(size, PAGE_SIZE) <span style=color:#ff7b72;font-weight:700>+</span> PAGE_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> base <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, total, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE, ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Make last page inaccessible
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mprotect</span>(base <span style=color:#ff7b72;font-weight:700>+</span> total <span style=color:#ff7b72;font-weight:700>-</span> PAGE_SIZE, PAGE_SIZE, PROT_NONE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Return pointer near the guard page
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> base <span style=color:#ff7b72;font-weight:700>+</span> (total <span style=color:#ff7b72;font-weight:700>-</span> PAGE_SIZE <span style=color:#ff7b72;font-weight:700>-</span> size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Overflow triggers SIGSEGV immediately.</p><h3 id="112-red-zones">11.2 Red Zones</h3><p>Fill boundaries with known patterns:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define REDZONE_SIZE 16
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define REDZONE_PATTERN 0xFE
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>debug_alloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(size <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>2</span> <span style=color:#ff7b72;font-weight:700>*</span> REDZONE_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>memset</span>(ptr, REDZONE_PATTERN, REDZONE_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>memset</span>(ptr <span style=color:#ff7b72;font-weight:700>+</span> REDZONE_SIZE <span style=color:#ff7b72;font-weight:700>+</span> size, REDZONE_PATTERN, REDZONE_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr <span style=color:#ff7b72;font-weight:700>+</span> REDZONE_SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>debug_free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span> base <span style=color:#ff7b72;font-weight:700>=</span> (<span style=color:#ff7b72>char</span><span style=color:#ff7b72;font-weight:700>*</span>)ptr <span style=color:#ff7b72;font-weight:700>-</span> REDZONE_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Check red zones
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>&lt;</span> REDZONE_SIZE; i<span style=color:#ff7b72;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (base[i] <span style=color:#ff7b72;font-weight:700>!=</span> REDZONE_PATTERN) {
</span></span><span style=display:flex><span>            <span style=color:#d2a8ff;font-weight:700>report_underflow</span>(ptr);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Check after...
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>free</span>(base);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="113-use-after-free-detection">11.3 Use-After-Free Detection</h3><p>Quarantine freed memory:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> QuarantineEntry {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> size;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>time_t</span> freed_at;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>quarantine_free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr, <span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Fill with pattern
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>memset</span>(ptr, <span style=color:#a5d6ff>0xDD</span>, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Add to quarantine
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>quarantine_add</span>(ptr, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Actually free old entries
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (quarantine_size <span style=color:#ff7b72;font-weight:700>&gt;</span> MAX_QUARANTINE) {
</span></span><span style=display:flex><span>        QuarantineEntry entry <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>quarantine_pop_oldest</span>();
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>actual_free</span>(entry.ptr);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="114-aslr-integration">11.4 ASLR Integration</h3><p>Modern allocators randomize layout:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>mmap_random</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Add random offset
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>uintptr_t</span> random_offset <span style=color:#ff7b72;font-weight:700>=</span> (<span style=color:#d2a8ff;font-weight:700>random</span>() <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#a5d6ff>0xFFFFFF</span>) <span style=color:#ff7b72;font-weight:700>*</span> PAGE_SIZE;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> hint <span style=color:#ff7b72;font-weight:700>=</span> (<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span>)(BASE_ADDRESS <span style=color:#ff7b72;font-weight:700>+</span> random_offset);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(hint, size, ...);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This makes exploitation harder by unpredictable addresses.</p><h2 id="12-emerging-trends">12. Emerging Trends</h2><h3 id="121-mimalloc">12.1 mimalloc</h3><p>Microsoft&rsquo;s mimalloc offers excellent performance with a simple design:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Key features:
</span></span><span style=display:flex><span>- Free lists per page (no size classes!)
</span></span><span style=display:flex><span>- Immediate memory return to OS
</span></span><span style=display:flex><span>- First-class huge page support
</span></span><span style=display:flex><span>- Excellent fragmentation behavior
</span></span></code></pre></div><p>mimalloc achieves near-jemalloc performance with significantly simpler code.</p><h3 id="122-hardened-allocators">12.2 Hardened Allocators</h3><p>Security-focused allocators like OpenBSD&rsquo;s malloc and GrapheneOS&rsquo;s hardened_malloc:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Features:
</span></span><span style=display:flex><span>- Isolated metadata (can&#39;t be overwritten via buffer overflow)
</span></span><span style=display:flex><span>- Strong randomization
</span></span><span style=display:flex><span>- Immediate use-after-free detection
</span></span><span style=display:flex><span>- Guard pages on all allocations
</span></span></code></pre></div><p>Trade performance for security.</p><h3 id="123-memory-tagging">12.3 Memory Tagging</h3><p>ARM&rsquo;s Memory Tagging Extension (MTE) enables hardware-assisted safety:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Each pointer has a 4-bit tag in high bits
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Memory has corresponding tag
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Hardware checks tags on access
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>tagged_alloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> tag <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>random</span>() <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#a5d6ff>0xF</span>;
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>set_memory_tag</span>(ptr, size, tag);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>add_pointer_tag</span>(ptr, tag);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>tagged_free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> new_tag <span style=color:#ff7b72;font-weight:700>=</span> (<span style=color:#d2a8ff;font-weight:700>get_pointer_tag</span>(ptr) <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#a5d6ff>0xF</span>;
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>set_memory_tag</span>(ptr, size, new_tag);  <span style=color:#8b949e;font-style:italic>// Invalidate old tag
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>free</span>(<span style=color:#d2a8ff;font-weight:700>remove_pointer_tag</span>(ptr));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Use-after-free and buffer overflow are detected by hardware.</p><h3 id="124-persistent-memory-allocators">12.4 Persistent Memory Allocators</h3><p>NVM (Non-Volatile Memory) requires special allocators:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// PMDK library
</span></span></span><span style=display:flex><span>PMEMobjpool <span style=color:#ff7b72;font-weight:700>*</span>pop <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pmemobj_open</span>(path, <span style=color:#a5d6ff>&#34;mypool&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>TX_BEGIN</span>(pop) {
</span></span><span style=display:flex><span>    PMEMoid oid <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pmemobj_tx_alloc</span>(<span style=color:#ff7b72>sizeof</span>(MyStruct), TYPE_NUM);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Allocation is transactional
</span></span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Memory persists across restarts
</span></span></span></code></pre></div><p>Challenges:</p><ul><li>Ensuring consistency on crash</li><li>Managing persistent pointers</li><li>Handling capacity vs. performance trade-offs</li></ul><h2 id="13-implementing-a-simple-allocator">13. Implementing a Simple Allocator</h2><p>Let&rsquo;s build a working allocator to solidify concepts.</p><h3 id="131-design-goals">13.1 Design Goals</h3><ul><li>Support small allocations (&lt; 4 KiB) efficiently</li><li>Thread-safe with per-thread caching</li><li>Reasonable fragmentation</li><li>Simple enough to understand</li></ul><h3 id="132-size-classes">13.2 Size Classes</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define NUM_SIZE_CLASSES 8
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>static</span> <span style=color:#ff7b72>const</span> <span style=color:#ff7b72>size_t</span> size_classes[NUM_SIZE_CLASSES] <span style=color:#ff7b72;font-weight:700>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>16</span>, <span style=color:#a5d6ff>32</span>, <span style=color:#a5d6ff>64</span>, <span style=color:#a5d6ff>128</span>, <span style=color:#a5d6ff>256</span>, <span style=color:#a5d6ff>512</span>, <span style=color:#a5d6ff>1024</span>, <span style=color:#a5d6ff>2048</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>get_size_class</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>&lt;</span> NUM_SIZE_CLASSES; i<span style=color:#ff7b72;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (size <span style=color:#ff7b72;font-weight:700>&lt;=</span> size_classes[i]) <span style=color:#ff7b72>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>;  <span style=color:#8b949e;font-style:italic>// Too large, use mmap directly
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="133-slab-structure">13.3 Slab Structure</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define SLAB_SIZE (64 * 1024)  </span><span style=color:#8b949e;font-style:italic>// 64 KiB slabs
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> Slab {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>struct</span> Slab<span style=color:#ff7b72;font-weight:700>*</span> next;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>size_t</span> object_size;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> num_objects;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> num_free;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> free_list;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span> data[];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Slab<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>slab_create</span>(<span style=color:#ff7b72>size_t</span> object_size) {
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> slab <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, SLAB_SIZE, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                       MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>object_size <span style=color:#ff7b72;font-weight:700>=</span> object_size;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_objects <span style=color:#ff7b72;font-weight:700>=</span> (SLAB_SIZE <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#ff7b72>sizeof</span>(Slab)) <span style=color:#ff7b72;font-weight:700>/</span> object_size;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_free <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_objects;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Build free list
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_objects <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>1</span>; i <span style=color:#ff7b72;font-weight:700>&gt;=</span> <span style=color:#a5d6ff>0</span>; i<span style=color:#ff7b72;font-weight:700>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> obj <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>data <span style=color:#ff7b72;font-weight:700>+</span> i <span style=color:#ff7b72;font-weight:700>*</span> object_size;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>**</span>)obj <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list;
</span></span><span style=display:flex><span>        slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> obj;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> slab;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="134-thread-cache">13.4 Thread Cache</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define CACHE_SIZE 32
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> ThreadCache {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> cached[NUM_SIZE_CLASSES][CACHE_SIZE];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> count[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>thread_local ThreadCache thread_cache <span style=color:#ff7b72;font-weight:700>=</span> {<span style=color:#a5d6ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>cache_alloc</span>(<span style=color:#ff7b72>int</span> cls) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (thread_cache.count[cls] <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> thread_cache.cached[cls][<span style=color:#ff7b72;font-weight:700>--</span>thread_cache.count[cls]];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>cache_free</span>(<span style=color:#ff7b72>int</span> cls, <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (thread_cache.count[cls] <span style=color:#ff7b72;font-weight:700>&lt;</span> CACHE_SIZE) {
</span></span><span style=display:flex><span>        thread_cache.cached[cls][thread_cache.count[cls]<span style=color:#ff7b72;font-weight:700>++</span>] <span style=color:#ff7b72;font-weight:700>=</span> ptr;
</span></span><span style=display:flex><span>    } <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>central_free</span>(cls, ptr);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="135-central-allocator">13.5 Central Allocator</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> CentralAllocator {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>pthread_mutex_t</span> lock;
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> partial_slabs[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> full_slabs[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CentralAllocator central <span style=color:#ff7b72;font-weight:700>=</span> {PTHREAD_MUTEX_INITIALIZER};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>central_alloc</span>(<span style=color:#ff7b72>int</span> cls) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>pthread_mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>central.lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> slab <span style=color:#ff7b72;font-weight:700>=</span> central.partial_slabs[cls];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>slab) {
</span></span><span style=display:flex><span>        slab <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>slab_create</span>(size_classes[cls]);
</span></span><span style=display:flex><span>        central.partial_slabs[cls] <span style=color:#ff7b72;font-weight:700>=</span> slab;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> obj <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>free_list <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>**</span>)obj;
</span></span><span style=display:flex><span>    slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_free<span style=color:#ff7b72;font-weight:700>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>num_free <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Move to full list
</span></span></span><span style=display:flex><span>        central.partial_slabs[cls] <span style=color:#ff7b72;font-weight:700>=</span> slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>next;
</span></span><span style=display:flex><span>        slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>=</span> central.full_slabs[cls];
</span></span><span style=display:flex><span>        central.full_slabs[cls] <span style=color:#ff7b72;font-weight:700>=</span> slab;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>pthread_mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>central.lock);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> obj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="136-public-interface">13.6 Public Interface</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>my_malloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>get_size_class</span>(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (cls <span style=color:#ff7b72;font-weight:700>&lt;</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Large allocation: mmap directly
</span></span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, size, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                    MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>cache_alloc</span>(cls);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>ptr) {
</span></span><span style=display:flex><span>        ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>central_alloc</span>(cls);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>my_free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>ptr) <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Find containing slab (in real implementation, use radix tree or similar)
</span></span></span><span style=display:flex><span>    Slab<span style=color:#ff7b72;font-weight:700>*</span> slab <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>find_slab</span>(ptr);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>slab) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Large allocation
</span></span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>munmap</span>(ptr, <span style=color:#8b949e;font-style:italic>/* need to track size */</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>get_size_class</span>(slab<span style=color:#ff7b72;font-weight:700>-&gt;</span>object_size);
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>cache_free</span>(cls, ptr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="14-debugging-allocation-issues">14. Debugging Allocation Issues</h2><h3 id="141-memory-leaks">14.1 Memory Leaks</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Valgrind</span>
</span></span><span style=display:flex><span>valgrind --leak-check<span style=color:#ff7b72;font-weight:700>=</span>full ./myapp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># AddressSanitizer</span>
</span></span><span style=display:flex><span>clang -fsanitize<span style=color:#ff7b72;font-weight:700>=</span>address ./myapp.c -o myapp
</span></span><span style=display:flex><span>./myapp
</span></span></code></pre></div><h3 id="142-heap-corruption">14.2 Heap Corruption</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Electric Fence - crashes on overflow</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>LD_PRELOAD</span><span style=color:#ff7b72;font-weight:700>=</span>/usr/lib/libefence.so ./myapp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># ASan with more checks</span>
</span></span><span style=display:flex><span><span style=color:#79c0ff>ASAN_OPTIONS</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>detect_stack_use_after_return</span><span style=color:#ff7b72;font-weight:700>=</span>1:check_initialization_order<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>1</span> ./myapp
</span></span></code></pre></div><h3 id="143-fragmentation-analysis">14.3 Fragmentation Analysis</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// jemalloc statistics
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;jemalloc/jemalloc.h&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>print_stats</span>() {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>malloc_stats_print</span>(NULL, NULL, <span style=color:#a5d6ff>&#34;gm&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Look for:</p><ul><li><code>mapped</code> vs <code>active</code> (fragmentation)</li><li><code>allocated</code> vs <code>resident</code> (overhead)</li><li>Per-size-class statistics</li></ul><h3 id="144-custom-allocator-debugging">14.4 Custom Allocator Debugging</h3><p>Add instrumentation to your allocator:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>struct</span> AllocStats {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>atomic_uint64_t</span> total_allocs;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>atomic_uint64_t</span> total_frees;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>atomic_uint64_t</span> allocs_per_class[NUM_SIZE_CLASSES];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>atomic_uint64_t</span> cache_hits;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>atomic_uint64_t</span> cache_misses;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AllocStats stats <span style=color:#ff7b72;font-weight:700>=</span> {<span style=color:#a5d6ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>my_malloc_instrumented</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>atomic_fetch_add</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>stats.total_allocs, <span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> cls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>get_size_class</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (cls <span style=color:#ff7b72;font-weight:700>&gt;=</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>atomic_fetch_add</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>stats.allocs_per_class[cls], <span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>cache_alloc</span>(cls);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (ptr) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>atomic_fetch_add</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>stats.cache_hits, <span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>atomic_fetch_add</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>stats.cache_misses, <span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span>        ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>central_alloc</span>(cls);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="15-real-world-performance-comparisons">15. Real-World Performance Comparisons</h2><h3 id="151-benchmark-results">15.1 Benchmark Results</h3><p>Typical results from allocation benchmarks (allocations per second, higher is better):</p><table><thead><tr><th>Allocator</th><th>Single-thread</th><th>8 threads</th><th>64 threads</th></tr></thead><tbody><tr><td>glibc malloc</td><td>8M</td><td>15M</td><td>20M</td></tr><tr><td>jemalloc</td><td>12M</td><td>80M</td><td>150M</td></tr><tr><td>tcmalloc</td><td>15M</td><td>90M</td><td>180M</td></tr><tr><td>mimalloc</td><td>14M</td><td>85M</td><td>170M</td></tr></tbody></table><h3 id="152-memory-efficiency">15.2 Memory Efficiency</h3><p>Memory overhead varies significantly:</p><table><thead><tr><th>Allocator</th><th>Overhead (small objects)</th><th>Fragmentation</th></tr></thead><tbody><tr><td>glibc</td><td>8-16 bytes</td><td>High</td></tr><tr><td>jemalloc</td><td>0-8 bytes</td><td>Low</td></tr><tr><td>tcmalloc</td><td>0-16 bytes</td><td>Medium</td></tr><tr><td>mimalloc</td><td>0-8 bytes</td><td>Very Low</td></tr></tbody></table><h3 id="153-latency-distribution">15.3 Latency Distribution</h3><p>For latency-sensitive applications, tail latency matters:</p><table><thead><tr><th>Allocator</th><th>p50</th><th>p99</th><th>p99.9</th></tr></thead><tbody><tr><td>glibc</td><td>50ns</td><td>2µs</td><td>50µs</td></tr><tr><td>jemalloc</td><td>40ns</td><td>200ns</td><td>5µs</td></tr><tr><td>tcmalloc</td><td>35ns</td><td>150ns</td><td>3µs</td></tr><tr><td>Arena</td><td>5ns</td><td>10ns</td><td>20ns</td></tr></tbody></table><p>Arena allocators excel at tail latency by avoiding complex free operations.</p><h2 id="16-summary">16. Summary</h2><p>Memory allocation is a rich field balancing multiple constraints:</p><ul><li><strong>Speed:</strong> Thread caching, size classes, and fast paths enable O(1) common-case allocation</li><li><strong>Space:</strong> Careful size class selection and coalescing minimize fragmentation</li><li><strong>Safety:</strong> Guard pages, red zones, and quarantine catch bugs early</li><li><strong>Scalability:</strong> Per-CPU caches and arena sharding reduce contention</li></ul><p>Key takeaways:</p><ol><li><strong>Understand your workload:</strong> General-purpose allocators are good defaults, but specific patterns (arena-friendly, fixed-size objects) enable dramatic optimizations</li><li><strong>Measure before optimizing:</strong> Use profiling tools to find allocation hotspots</li><li><strong>Consider custom allocators:</strong> For critical paths, arena and pool allocators can be 10-100x faster</li><li><strong>Safety has costs:</strong> Debug allocators are slower but catch bugs; production allocators balance safety and speed</li></ol><p>Modern allocators like jemalloc and tcmalloc represent decades of research and engineering. Understanding their design helps you use them effectively and know when custom solutions are worthwhile. Whether you&rsquo;re building a game engine, a database, or a web server, memory allocation is a fundamental skill that rewards deep understanding.</p><p>The allocator is often the most-called code in your application. Make it count.</p><h2 id="17-language-specific-allocation-patterns">17. Language-Specific Allocation Patterns</h2><p>Different programming languages present unique allocation challenges and opportunities. Understanding these patterns helps you optimize across the stack.</p><h3 id="171-c-allocators-and-the-standard-library">17.1 C++ Allocators and the Standard Library</h3><p>C++ allows custom allocators for standard containers:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>PoolAllocator</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>static</span> MemoryPool pool;
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#ff7b72;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>using</span> value_type <span style=color:#ff7b72;font-weight:700>=</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>allocate</span>(size_t n) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>static_cast</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>*&gt;</span>(pool.alloc(n <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#ff7b72>sizeof</span>(T)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>deallocate</span>(T<span style=color:#ff7b72;font-weight:700>*</span> p, size_t n) {
</span></span><span style=display:flex><span>        pool.free(p, n <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#ff7b72>sizeof</span>(T));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Use with containers
</span></span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>vector<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span>, PoolAllocator<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>&gt;&gt;</span> vec;
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>map<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span>, std<span style=color:#ff7b72;font-weight:700>::</span>string, std<span style=color:#ff7b72;font-weight:700>::</span>less<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>         PoolAllocator<span style=color:#ff7b72;font-weight:700>&lt;</span>std<span style=color:#ff7b72;font-weight:700>::</span>pair<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>const</span> <span style=color:#ff7b72>int</span>, std<span style=color:#ff7b72;font-weight:700>::</span>string<span style=color:#ff7b72;font-weight:700>&gt;&gt;&gt;</span> map;
</span></span></code></pre></div><p>C++17 introduced polymorphic memory resources (PMR):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;memory_resource&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>array<span style=color:#ff7b72;font-weight:700>&lt;</span>std<span style=color:#ff7b72;font-weight:700>::</span>byte, <span style=color:#a5d6ff>1024</span><span style=color:#ff7b72;font-weight:700>&gt;</span> buffer;
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>pmr<span style=color:#ff7b72;font-weight:700>::</span>monotonic_buffer_resource pool{buffer.data(), buffer.size()};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>pmr<span style=color:#ff7b72;font-weight:700>::</span>vector<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>&gt;</span> vec{<span style=color:#ff7b72;font-weight:700>&amp;</span>pool};  <span style=color:#8b949e;font-style:italic>// Uses our buffer
</span></span></span><span style=display:flex><span>vec.push_back(<span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span>vec.push_back(<span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// No heap allocation until buffer exhausted
</span></span></span></code></pre></div><p>PMR separates allocation policy from container type, enabling runtime allocator selection.</p><h3 id="172-rusts-ownership-and-allocation">17.2 Rust&rsquo;s Ownership and Allocation</h3><p>Rust&rsquo;s ownership model enables compile-time allocation analysis:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-rust" data-lang=rust><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Stack allocation - no heap involvement
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>let</span><span style=color:#6e7681> </span>x: [<span style=color:#ff7b72>i32</span>;<span style=color:#6e7681> </span><span style=color:#a5d6ff>1000</span>]<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>[<span style=color:#a5d6ff>0</span>;<span style=color:#6e7681> </span><span style=color:#a5d6ff>1000</span>];<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Heap allocation with Box
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>let</span><span style=color:#6e7681> </span>boxed: Box<span style=color:#ff7b72;font-weight:700>&lt;</span>[<span style=color:#ff7b72>i32</span>;<span style=color:#6e7681> </span><span style=color:#a5d6ff>1000</span>]<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>Box::new([<span style=color:#a5d6ff>0</span>;<span style=color:#6e7681> </span><span style=color:#a5d6ff>1000</span>]);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Custom allocators (nightly feature)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#![feature(allocator_api)]</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>use</span><span style=color:#6e7681> </span>std::alloc::{Allocator,<span style=color:#6e7681> </span>Global,<span style=color:#6e7681> </span>Layout};<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> <span style=color:#f0883e;font-weight:700>BumpAllocator</span><span style=color:#6e7681> </span>{<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>/* ... */</span><span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>impl</span><span style=color:#6e7681> </span>Allocator<span style=color:#6e7681> </span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>BumpAllocator<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>fn</span> <span style=color:#d2a8ff;font-weight:700>allocate</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>self,<span style=color:#6e7681> </span>layout: <span style=color:#f0883e;font-weight:700>Layout</span>)<span style=color:#6e7681> </span>-&gt; Result<span style=color:#ff7b72;font-weight:700>&lt;</span>NonNull<span style=color:#ff7b72;font-weight:700>&lt;</span>[<span style=color:#ff7b72>u8</span>]<span style=color:#ff7b72;font-weight:700>&gt;</span>,<span style=color:#6e7681> </span>AllocError<span style=color:#ff7b72;font-weight:700>&gt;</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// Bump pointer allocation
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>unsafe</span><span style=color:#6e7681> </span><span style=color:#ff7b72>fn</span> <span style=color:#d2a8ff;font-weight:700>deallocate</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>self,<span style=color:#6e7681> </span>ptr: <span style=color:#f0883e;font-weight:700>NonNull</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>u8</span><span style=color:#ff7b72;font-weight:700>&gt;</span>,<span style=color:#6e7681> </span>layout: <span style=color:#f0883e;font-weight:700>Layout</span>)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// No-op for bump allocator
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Rust&rsquo;s <code>Vec&lt;T, A></code> allows allocator-parameterized collections, similar to C++.</p><h3 id="173-gos-escape-analysis">17.3 Go&rsquo;s Escape Analysis</h3><p>Go&rsquo;s compiler determines whether allocations can stay on the stack:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-go" data-lang=go><span style=display:flex><span><span style=color:#ff7b72>func</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>stackAlloc</span>()<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>x<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>:=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>42</span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Stays on stack</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>x<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>func</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>heapAlloc</span>()<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>x<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>:=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>42</span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// Escapes to heap - returned pointer outlives function</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&amp;</span>x<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>Check escape analysis with:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span>go build -gcflags<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;-m&#34;</span> main.go
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Output shows which allocations escape to heap</span>
</span></span></code></pre></div><p>Go&rsquo;s runtime includes a sophisticated allocator based on tcmalloc, with:</p><ul><li>Per-P (processor) caches for small objects</li><li>Size-class-based allocation</li><li>Concurrent garbage collection integration</li></ul><h3 id="174-jvm-allocation-and-tlab">17.4 JVM Allocation and TLAB</h3><p>The JVM uses Thread-Local Allocation Buffers (TLABs):</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│              Eden Space                      │
</span></span><span style=display:flex><span>│  ┌────────┐  ┌────────┐  ┌────────┐        │
</span></span><span style=display:flex><span>│  │ TLAB 1 │  │ TLAB 2 │  │ TLAB 3 │  ...   │
</span></span><span style=display:flex><span>│  │Thread 1│  │Thread 2│  │Thread 3│        │
</span></span><span style=display:flex><span>│  └────────┘  └────────┘  └────────┘        │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────┘
</span></span></code></pre></div><p>Each thread gets a TLAB from Eden. Allocation is just a pointer bump:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-java" data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// JVM internal (conceptual)</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span>Object<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>allocate</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>size)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(tlab.pointer<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span>size<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;=</span><span style=color:#6e7681> </span>tlab.end)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>Object<span style=color:#6e7681> </span>obj<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>tlab.pointer;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>tlab.pointer<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+=</span><span style=color:#6e7681> </span>size;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>obj;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>slowPathAlloc(size);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>This makes most JVM allocations extremely fast—often faster than malloc.</p><h2 id="18-virtual-memory-and-the-allocator">18. Virtual Memory and the Allocator</h2><p>Allocators work with virtual memory, not physical memory. Understanding this relationship is crucial.</p><h3 id="181-the-mmap-interface">18.1 The mmap Interface</h3><p>Modern allocators use <code>mmap</code> for large allocations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#d2a8ff;font-weight:700>large_alloc</span>(<span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, size,
</span></span><span style=display:flex><span>                     PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                     MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS,
</span></span><span style=display:flex><span>                     <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (ptr <span style=color:#ff7b72;font-weight:700>==</span> MAP_FAILED) <span style=color:#ff7b72>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>large_free</span>(<span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr, <span style=color:#ff7b72>size_t</span> size) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>munmap</span>(ptr, size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>mmap</code> advantages:</p><ul><li>Immediate return to OS (unlike <code>brk</code>/<code>sbrk</code>)</li><li>Address space isolation</li><li>Huge page support</li><li>Memory protection granularity</li></ul><h3 id="182-overcommit-and-oom">18.2 Overcommit and OOM</h3><p>Linux overcommits memory by default:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// This succeeds even without 1 TiB RAM
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, <span style=color:#a5d6ff>1ULL</span> <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> <span style=color:#a5d6ff>40</span>, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                 MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Fails only when you access pages beyond physical memory
</span></span></span></code></pre></div><p>This enables:</p><ul><li>Sparse data structures (only touched pages consume RAM)</li><li>Copy-on-write fork efficiency</li><li>Lazy initialization</li></ul><p>But leads to the OOM killer when physical memory is exhausted.</p><h3 id="183-memory-advising">18.3 Memory Advising</h3><p>Allocators can hint to the kernel about memory usage patterns:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Mark memory as not needed soon
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>madvise</span>(ptr, size, MADV_DONTNEED);  <span style=color:#8b949e;font-style:italic>// Pages can be reclaimed
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Hint that memory will be needed
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>madvise</span>(ptr, size, MADV_WILLNEED);  <span style=color:#8b949e;font-style:italic>// Prefetch pages
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Mark as sequential access
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>madvise</span>(ptr, size, MADV_SEQUENTIAL);  <span style=color:#8b949e;font-style:italic>// Optimize readahead
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Mark as random access
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>madvise</span>(ptr, size, MADV_RANDOM);  <span style=color:#8b949e;font-style:italic>// Disable readahead
</span></span></span></code></pre></div><p>jemalloc uses <code>MADV_DONTNEED</code> and <code>MADV_FREE</code> to return memory without unmapping.</p><h3 id="184-transparent-huge-pages">18.4 Transparent Huge Pages</h3><p>2 MiB huge pages reduce TLB pressure:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Request huge page backing
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>madvise</span>(ptr, size, MADV_HUGEPAGE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Or allocate huge pages directly
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span><span style=color:#ff7b72;font-weight:700>*</span> ptr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>mmap</span>(NULL, size, PROT_READ <span style=color:#ff7b72;font-weight:700>|</span> PROT_WRITE,
</span></span><span style=display:flex><span>                 MAP_PRIVATE <span style=color:#ff7b72;font-weight:700>|</span> MAP_ANONYMOUS <span style=color:#ff7b72;font-weight:700>|</span> MAP_HUGETLB,
</span></span><span style=display:flex><span>                 <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>0</span>);
</span></span></code></pre></div><p>Trade-offs:</p><ul><li>Pro: Fewer TLB misses (1 entry covers 2 MiB vs 4 KiB)</li><li>Con: Internal fragmentation (smallest unit is 2 MiB)</li><li>Con: Allocation latency (finding contiguous physical memory)</li></ul><h2 id="19-allocation-in-distributed-systems">19. Allocation in Distributed Systems</h2><p>Distributed systems face unique allocation challenges.</p><h3 id="191-shared-nothing-memory">19.1 Shared-Nothing Memory</h3><p>In shared-nothing architectures, each node manages its own memory:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Node 1                    Node 2                    Node 3
</span></span><span style=display:flex><span>┌──────────────────┐     ┌──────────────────┐     ┌──────────────────┐
</span></span><span style=display:flex><span>│ Local allocator  │     │ Local allocator  │     │ Local allocator  │
</span></span><span style=display:flex><span>│ Serialization    │────▶│ Deserialization  │────▶│ Local copy       │
</span></span><span style=display:flex><span>└──────────────────┘     └──────────────────┘     └──────────────────┘
</span></span></code></pre></div><p>Serialization/deserialization overhead often dominates. Strategies:</p><ul><li><strong>Zero-copy serialization:</strong> Formats like FlatBuffers, Cap&rsquo;n Proto</li><li><strong>Object pooling:</strong> Reuse buffers for network I/O</li><li><strong>Arena allocation:</strong> Per-request arenas freed in bulk</li></ul><h3 id="192-rdma-and-remote-memory">19.2 RDMA and Remote Memory</h3><p>Remote Direct Memory Access changes the allocation picture:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Register memory for RDMA
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> ibv_mr<span style=color:#ff7b72;font-weight:700>*</span> mr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>ibv_reg_mr</span>(pd, buffer, size,
</span></span><span style=display:flex><span>                                IBV_ACCESS_LOCAL_WRITE <span style=color:#ff7b72;font-weight:700>|</span>
</span></span><span style=display:flex><span>                                IBV_ACCESS_REMOTE_WRITE <span style=color:#ff7b72;font-weight:700>|</span>
</span></span><span style=display:flex><span>                                IBV_ACCESS_REMOTE_READ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Remote read (no CPU involvement at remote end)
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>ibv_post_send</span>(qp, <span style=color:#ff7b72;font-weight:700>&amp;</span>read_wr, <span style=color:#ff7b72;font-weight:700>&amp;</span>bad_wr);
</span></span></code></pre></div><p>RDMA-aware allocators must:</p><ul><li>Pin memory (prevent page-out)</li><li>Register memory regions with the NIC</li><li>Handle registration caching</li><li>Balance registration overhead against memory efficiency</li></ul><h3 id="193-persistent-memory-in-distributed-systems">19.3 Persistent Memory in Distributed Systems</h3><p>NVM adds durability requirements to distributed allocation:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Intel PMDK distributed pattern
</span></span></span><span style=display:flex><span>PMEMobjpool<span style=color:#ff7b72;font-weight:700>*</span> pop <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pmemobj_open</span>(path, layout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Transactional allocation
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>TX_BEGIN</span>(pop) {
</span></span><span style=display:flex><span>    PMEMoid oid <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pmemobj_tx_alloc</span>(size, type_num);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// If crash here, allocation is rolled back
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>pmemobj_tx_add_range</span>(oid, <span style=color:#a5d6ff>0</span>, size);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Initialize object
</span></span></span><span style=display:flex><span>} TX_END
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Durably committed
</span></span></span></code></pre></div><p>Distributed consensus (like Raft) combined with persistent allocators enables durable distributed data structures.</p><h2 id="20-future-directions-in-memory-allocation">20. Future Directions in Memory Allocation</h2><h3 id="201-hardware-memory-tagging">20.1 Hardware Memory Tagging</h3><p>ARM MTE and similar technologies enable hardware-assisted memory safety:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Pointer: [Tag:4][Address:60]                │
</span></span><span style=display:flex><span>│ Memory:  Each 16 bytes has 4-bit tag        │
</span></span><span style=display:flex><span>│ Access:  Hardware checks tag match          │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────┘
</span></span></code></pre></div><p>Future allocators will manage tags:</p><ul><li>Different tag per allocation</li><li>Change tag on free (detects use-after-free)</li><li>Bound checking via adjacent tags</li></ul><h3 id="202-cxl-and-disaggregated-memory">20.2 CXL and Disaggregated Memory</h3><p>Compute Express Link enables memory disaggregation:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>┌─────────┐     CXL      ┌─────────────────┐
</span></span><span style=display:flex><span>│ CPU 1   │◀────────────▶│ Memory Pool     │
</span></span><span style=display:flex><span>│ Local   │              │ (shared)        │
</span></span><span style=display:flex><span>│ DRAM    │◀────────────▶│ - Hot data      │
</span></span><span style=display:flex><span>└─────────┘              │ - Cold data     │
</span></span><span style=display:flex><span>                         │ - Persistent    │
</span></span><span style=display:flex><span>┌─────────┐              └─────────────────┘
</span></span><span style=display:flex><span>│ CPU 2   │◀────────────────────┘
</span></span><span style=display:flex><span>└─────────┘
</span></span></code></pre></div><p>CXL-aware allocators will:</p><ul><li>Manage memory tiers (local DRAM, CXL-attached, NVM)</li><li>Optimize placement based on access patterns</li><li>Handle heterogeneous latency/bandwidth</li></ul><h3 id="203-ml-guided-allocation">20.3 ML-Guided Allocation</h3><p>Machine learning can optimize allocation decisions:</p><ul><li>Predict allocation lifetimes for better placement</li><li>Learn size class distributions for specific workloads</li><li>Detect anomalous allocation patterns (memory leaks, attacks)</li></ul><p>Research prototypes show promising results:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Conceptual ML allocator</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>MLAllocator</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>model <span style=color:#ff7b72;font-weight:700>=</span> load_model(<span style=color:#a5d6ff>&#34;allocation_predictor.h5&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>allocate</span>(self, size, context):
</span></span><span style=display:flex><span>        lifetime <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>model<span style=color:#ff7b72;font-weight:700>.</span>predict([size, context])
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> lifetime <span style=color:#ff7b72;font-weight:700>&lt;</span> SHORT_THRESHOLD:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>arena_alloc(size)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>elif</span> lifetime <span style=color:#ff7b72;font-weight:700>&lt;</span> MEDIUM_THRESHOLD:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>pool_alloc(size)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>general_alloc(size)
</span></span></code></pre></div><h3 id="204-verified-allocators">20.4 Verified Allocators</h3><p>Formal verification ensures allocator correctness:</p><ul><li>seL4&rsquo;s verified allocator (capability-based)</li><li>CompCert&rsquo;s verified C allocator</li><li>Rust&rsquo;s type system as lightweight verification</li></ul><p>As systems become more critical (autonomous vehicles, medical devices), verified allocators will become essential.</p><h2 id="21-summary">21. Summary</h2><p>Memory allocation is a rich field balancing multiple constraints:</p><ul><li><strong>Speed:</strong> Thread caching, size classes, and fast paths enable O(1) common-case allocation</li><li><strong>Space:</strong> Careful size class selection and coalescing minimize fragmentation</li><li><strong>Safety:</strong> Guard pages, red zones, and quarantine catch bugs early</li><li><strong>Scalability:</strong> Per-CPU caches and arena sharding reduce contention</li></ul><p>Key takeaways:</p><ol><li><strong>Understand your workload:</strong> General-purpose allocators are good defaults, but specific patterns (arena-friendly, fixed-size objects) enable dramatic optimizations</li><li><strong>Measure before optimizing:</strong> Use profiling tools to find allocation hotspots</li><li><strong>Consider custom allocators:</strong> For critical paths, arena and pool allocators can be 10-100x faster</li><li><strong>Safety has costs:</strong> Debug allocators are slower but catch bugs; production allocators balance safety and speed</li></ol><p>Modern allocators like jemalloc and tcmalloc represent decades of research and engineering. Understanding their design helps you use them effectively and know when custom solutions are worthwhile. Whether you&rsquo;re building a game engine, a database, or a web server, memory allocation is a fundamental skill that rewards deep understanding.</p><p>The allocator is often the most-called code in your application. Make it count.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/systems/>systems</a>, <a href=/categories/performance/>performance</a></div><div>Tags:
<a href=/tags/memory/>#memory</a>, <a href=/tags/allocators/>#allocators</a>, <a href=/tags/malloc/>#malloc</a>, <a href=/tags/performance/>#performance</a>, <a href=/tags/systems/>#systems</a>, <a href=/tags/arena/>#arena</a>, <a href=/tags/jemalloc/>#jemalloc</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>