<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>B-Trees and LSM-Trees: The Foundations of Modern Storage Engines · Leonardo Benicio</title><meta name=description content="An in-depth exploration of B-Trees and LSM-Trees, the two dominant data structures powering databases from PostgreSQL to RocksDB. Learn their trade-offs, internal mechanics, and when to choose each for your workload."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/b-trees-and-lsm-trees-the-foundations-of-modern-storage-engines/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="B-Trees and LSM-Trees: The Foundations of Modern Storage Engines · Leonardo Benicio"><meta property="og:description" content="An in-depth exploration of B-Trees and LSM-Trees, the two dominant data structures powering databases from PostgreSQL to RocksDB. Learn their trade-offs, internal mechanics, and when to choose each for your workload."><meta property="og:url" content="https://blog.lbenicio.dev/blog/b-trees-and-lsm-trees-the-foundations-of-modern-storage-engines/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/btrees-lsm-trees-storage-engine-foundations.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="B-Trees and LSM-Trees: The Foundations of Modern Storage Engines · Leonardo Benicio"><meta name=twitter:description content="An in-depth exploration of B-Trees and LSM-Trees, the two dominant data structures powering databases from PostgreSQL to RocksDB. Learn their trade-offs, internal mechanics, and when to choose each for your workload."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/b-trees-and-lsm-trees-the-foundations-of-modern-storage-engines/","name":"B Trees and Lsm Trees the Foundations of Modern Storage Engines","position":3}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">B Trees and Lsm Trees the Foundations of Modern Storage Engines</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">B Trees and Lsm Trees the Foundations of Modern Storage Engines</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">B-Trees and LSM-Trees: The Foundations of Modern Storage Engines</h1><div class="c277478 c3ecea6 c8fb24a">2021-07-14
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/btrees-lsm-trees-storage-engine-foundations.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">An in-depth exploration of B-Trees and LSM-Trees, the two dominant data structures powering databases from PostgreSQL to RocksDB. Learn their trade-offs, internal mechanics, and when to choose each for your workload.</p></header><div class="content"><p>Every database faces the same fundamental challenge: how do you organize data on disk so that both reads and writes are fast? Two data structures have emerged as the dominant answers—B-Trees and LSM-Trees. Understanding their trade-offs is essential for anyone building or operating data-intensive systems. This post explores both in depth, from their internal mechanics to their real-world implementations.</p><h2 id="1-the-storage-engine-problem">1. The Storage Engine Problem</h2><p>Before diving into specific data structures, let&rsquo;s understand what we&rsquo;re optimizing for.</p><h3 id="11-the-read-write-trade-off">1.1 The Read-Write Trade-off</h3><p>Disk storage has fundamentally different characteristics than memory:</p><ul><li><strong>Sequential access is fast:</strong> Reading or writing data in order is 100-1000x faster than random access on HDDs, and still 10x faster on SSDs</li><li><strong>Random access is slow:</strong> Seeking to arbitrary locations has high latency</li><li><strong>Writes are especially expensive:</strong> SSDs wear out with writes, and HDDs have mechanical seek overhead</li></ul><p>This creates a fundamental tension:</p><ul><li><strong>Optimize for reads:</strong> Keep data sorted and organized for fast lookups</li><li><strong>Optimize for writes:</strong> Append data sequentially to avoid random I/O</li></ul><p>No data structure can be optimal for both. B-Trees and LSM-Trees represent different points on this trade-off spectrum.</p><h3 id="12-key-operations">1.2 Key Operations</h3><p>Storage engines must support these operations efficiently:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>StorageEngine</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key: bytes, value: bytes) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Insert or update a key-value pair.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key: bytes) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Optional[bytes]:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Retrieve the value for a key, or None if not found.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>delete</span>(self, key: bytes) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Remove a key-value pair.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>scan</span>(self, start_key: bytes, end_key: bytes) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Iterator[Tuple[bytes, bytes]]:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Iterate over all key-value pairs in a range.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>pass</span>
</span></span></code></pre></div><p>The relative frequency of these operations determines which data structure is optimal.</p><h3 id="13-metrics-that-matter">1.3 Metrics That Matter</h3><p>When evaluating storage engines:</p><ul><li><strong>Write amplification:</strong> How many times is data written to disk for each logical write?</li><li><strong>Read amplification:</strong> How many disk reads are needed for each logical read?</li><li><strong>Space amplification:</strong> How much extra disk space is used beyond the logical data size?</li><li><strong>Latency distribution:</strong> Not just averages, but P99 and P999 latencies</li></ul><p>B-Trees and LSM-Trees make different trade-offs across these metrics.</p><h2 id="2-b-trees-the-read-optimized-classic">2. B-Trees: The Read-Optimized Classic</h2><p>B-Trees have powered relational databases for over 50 years. They&rsquo;re the default choice for PostgreSQL, MySQL InnoDB, SQL Server, and Oracle.</p><h3 id="21-structure-and-invariants">2.1 Structure and Invariants</h3><p>A B-Tree is a self-balancing tree where:</p><ul><li>Each node contains multiple keys in sorted order</li><li>Internal nodes contain pointers to child nodes</li><li>All leaves are at the same depth</li><li>Nodes are sized to match disk pages (typically 4KB-16KB)</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>                    [30 | 60]
</span></span><span style=display:flex><span>                   /    |    \
</span></span><span style=display:flex><span>                  /     |     \
</span></span><span style=display:flex><span>          [10|20]    [40|50]   [70|80|90]
</span></span><span style=display:flex><span>          /  |  \    /  |  \    /  |  |  \
</span></span><span style=display:flex><span>        [...] [...] [...] [...] [...] [...]
</span></span></code></pre></div><p>Key invariants for a B-Tree of order <code>m</code>:</p><ul><li>Each node has at most <code>m</code> children</li><li>Each node (except root) has at least <code>⌈m/2⌉</code> children</li><li>The root has at least 2 children (if not a leaf)</li><li>All leaves appear at the same level</li></ul><h3 id="22-b-trees-the-practical-variant">2.2 B+ Trees: The Practical Variant</h3><p>Most databases use B+ Trees, which differ from B-Trees:</p><ul><li><strong>Only leaves contain values:</strong> Internal nodes contain only keys and pointers</li><li><strong>Leaves are linked:</strong> A doubly-linked list connects all leaves for efficient range scans</li><li><strong>Higher fanout:</strong> More keys per internal node means shallower trees</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Internal nodes (keys only):
</span></span><span style=display:flex><span>                    [30 | 60]
</span></span><span style=display:flex><span>                   /    |    \
</span></span><span style=display:flex><span>          [10|20]    [40|50]   [70|80|90]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Leaf nodes (keys + values, linked):
</span></span><span style=display:flex><span>[10:v1|20:v2] &lt;-&gt; [30:v3|40:v4|50:v5] &lt;-&gt; [60:v6|70:v7|80:v8|90:v9]
</span></span></code></pre></div><h3 id="23-point-lookup">2.3 Point Lookup</h3><p>Finding a key in a B+ Tree:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key):
</span></span><span style=display:flex><span>    node <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>root
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> <span style=color:#ff7b72;font-weight:700>not</span> node<span style=color:#ff7b72;font-weight:700>.</span>is_leaf:
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Binary search within the node</span>
</span></span><span style=display:flex><span>        i <span style=color:#ff7b72;font-weight:700>=</span> binary_search(node<span style=color:#ff7b72;font-weight:700>.</span>keys, key)
</span></span><span style=display:flex><span>        node <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>children[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Binary search in leaf</span>
</span></span><span style=display:flex><span>    i <span style=color:#ff7b72;font-weight:700>=</span> binary_search(node<span style=color:#ff7b72;font-weight:700>.</span>keys, key)
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> i <span style=color:#ff7b72;font-weight:700>&lt;</span> len(node<span style=color:#ff7b72;font-weight:700>.</span>keys) <span style=color:#ff7b72;font-weight:700>and</span> node<span style=color:#ff7b72;font-weight:700>.</span>keys[i] <span style=color:#ff7b72;font-weight:700>==</span> key:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> node<span style=color:#ff7b72;font-weight:700>.</span>values[i]
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span>
</span></span></code></pre></div><p>With pages sized to match disk blocks, each level requires one disk read. A B+ Tree with 1000 keys per node and 1 billion entries needs only 3 levels—just 3 disk reads for any lookup.</p><h3 id="24-insertion">2.4 Insertion</h3><p>Inserting a key-value pair:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key, value):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Find the leaf where this key belongs</span>
</span></span><span style=display:flex><span>    leaf, path <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>find_leaf_with_path(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Insert into leaf</span>
</span></span><span style=display:flex><span>    leaf<span style=color:#ff7b72;font-weight:700>.</span>insert(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># If leaf is too full, split</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> leaf<span style=color:#ff7b72;font-weight:700>.</span>is_overfull():
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>split_and_propagate(leaf, path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>split_and_propagate</span>(self, node, path):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Split the node in half</span>
</span></span><span style=display:flex><span>    mid <span style=color:#ff7b72;font-weight:700>=</span> len(node<span style=color:#ff7b72;font-weight:700>.</span>keys) <span style=color:#ff7b72;font-weight:700>//</span> <span style=color:#a5d6ff>2</span>
</span></span><span style=display:flex><span>    left_node <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>keys[:mid]
</span></span><span style=display:flex><span>    right_node <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>keys[mid:]
</span></span><span style=display:flex><span>    middle_key <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>keys[mid]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Propagate split to parent</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> path:
</span></span><span style=display:flex><span>        parent <span style=color:#ff7b72;font-weight:700>=</span> path<span style=color:#ff7b72;font-weight:700>.</span>pop()
</span></span><span style=display:flex><span>        parent<span style=color:#ff7b72;font-weight:700>.</span>insert_child(middle_key, right_node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> parent<span style=color:#ff7b72;font-weight:700>.</span>is_overfull():
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>split_and_propagate(parent, path)
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Split the root - tree grows taller</span>
</span></span><span style=display:flex><span>        new_root <span style=color:#ff7b72;font-weight:700>=</span> Node([middle_key], [left_node, right_node])
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>root <span style=color:#ff7b72;font-weight:700>=</span> new_root
</span></span></code></pre></div><p>Splits cascade upward, potentially all the way to the root. The tree grows from the bottom up, maintaining balance.</p><h3 id="25-deletion">2.5 Deletion</h3><p>Deletion is more complex because nodes might become underfull:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>delete</span>(self, key):
</span></span><span style=display:flex><span>    leaf, path <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>find_leaf_with_path(key)
</span></span><span style=display:flex><span>    leaf<span style=color:#ff7b72;font-weight:700>.</span>remove(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> leaf<span style=color:#ff7b72;font-weight:700>.</span>is_underfull() <span style=color:#ff7b72;font-weight:700>and</span> path:
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>rebalance(leaf, path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>rebalance</span>(self, node, path):
</span></span><span style=display:flex><span>    parent <span style=color:#ff7b72;font-weight:700>=</span> path[<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>]
</span></span><span style=display:flex><span>    sibling <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>get_sibling(node, parent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> sibling<span style=color:#ff7b72;font-weight:700>.</span>can_lend():
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Borrow from sibling</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>redistribute(node, sibling, parent)
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Merge with sibling</span>
</span></span><span style=display:flex><span>        merged <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>merge(node, sibling)
</span></span><span style=display:flex><span>        parent<span style=color:#ff7b72;font-weight:700>.</span>remove_child(node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> parent<span style=color:#ff7b72;font-weight:700>.</span>is_underfull() <span style=color:#ff7b72;font-weight:700>and</span> len(path) <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>1</span>:
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>rebalance(parent, path[:<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>])
</span></span></code></pre></div><h3 id="26-concurrency-control">2.6 Concurrency Control</h3><p>B-Trees require careful locking for concurrent access:</p><p><strong>Latch crabbing:</strong> Hold a latch on the parent while acquiring the child&rsquo;s latch, then release the parent:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get_concurrent</span>(self, key):
</span></span><span style=display:flex><span>    node <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>root
</span></span><span style=display:flex><span>    node<span style=color:#ff7b72;font-weight:700>.</span>acquire_read_latch()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> <span style=color:#ff7b72;font-weight:700>not</span> node<span style=color:#ff7b72;font-weight:700>.</span>is_leaf:
</span></span><span style=display:flex><span>        child_idx <span style=color:#ff7b72;font-weight:700>=</span> binary_search(node<span style=color:#ff7b72;font-weight:700>.</span>keys, key)
</span></span><span style=display:flex><span>        child <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>children[child_idx]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        child<span style=color:#ff7b72;font-weight:700>.</span>acquire_read_latch()
</span></span><span style=display:flex><span>        node<span style=color:#ff7b72;font-weight:700>.</span>release_read_latch()  <span style=color:#8b949e;font-style:italic># Safe to release parent</span>
</span></span><span style=display:flex><span>        node <span style=color:#ff7b72;font-weight:700>=</span> child
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result <span style=color:#ff7b72;font-weight:700>=</span> node<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>    node<span style=color:#ff7b72;font-weight:700>.</span>release_read_latch()
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> result
</span></span></code></pre></div><p><strong>Optimistic locking:</strong> For writes, optimistically assume no splits will cascade to the root:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put_optimistic</span>(self, key, value):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># First, try optimistic path (no root latch)</span>
</span></span><span style=display:flex><span>    leaf, path <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>find_leaf_with_latches(key, write_latch<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    leaf<span style=color:#ff7b72;font-weight:700>.</span>insert(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> leaf<span style=color:#ff7b72;font-weight:700>.</span>is_overfull():
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> self<span style=color:#ff7b72;font-weight:700>.</span>can_handle_locally(leaf, path):
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>split_and_propagate(leaf, path)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-style:italic># Restart with pessimistic locking from root</span>
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>release_all_latches(path)
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>put_pessimistic(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>release_all_latches(path)
</span></span></code></pre></div><h3 id="27-write-ahead-logging">2.7 Write-Ahead Logging</h3><p>B-Tree modifications must be crash-safe. Write-ahead logging (WAL) ensures durability:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put_with_wal</span>(self, key, value):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># 1. Write to WAL first</span>
</span></span><span style=display:flex><span>    log_record <span style=color:#ff7b72;font-weight:700>=</span> LogRecord(
</span></span><span style=display:flex><span>        type<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;INSERT&#34;</span>,
</span></span><span style=display:flex><span>        key<span style=color:#ff7b72;font-weight:700>=</span>key,
</span></span><span style=display:flex><span>        value<span style=color:#ff7b72;font-weight:700>=</span>value,
</span></span><span style=display:flex><span>        page_id<span style=color:#ff7b72;font-weight:700>=</span>target_page<span style=color:#ff7b72;font-weight:700>.</span>id,
</span></span><span style=display:flex><span>        old_value<span style=color:#ff7b72;font-weight:700>=</span>target_page<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>wal<span style=color:#ff7b72;font-weight:700>.</span>append(log_record)
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>wal<span style=color:#ff7b72;font-weight:700>.</span>flush()  <span style=color:#8b949e;font-style:italic># Ensure on disk</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># 2. Modify the page in memory</span>
</span></span><span style=display:flex><span>    target_page<span style=color:#ff7b72;font-weight:700>.</span>insert(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># 3. Eventually write dirty pages to disk (checkpoint)</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Pages can be written in any order - WAL ensures recoverability</span>
</span></span></code></pre></div><h2 id="3-lsm-trees-the-write-optimized-alternative">3. LSM-Trees: The Write-Optimized Alternative</h2><p>Log-Structured Merge-Trees (LSM-Trees) were designed for write-heavy workloads. They power RocksDB, LevelDB, Cassandra, HBase, and many modern databases.</p><h3 id="31-core-idea">3.1 Core Idea</h3><p>Instead of modifying data in place, LSM-Trees:</p><ol><li>Buffer writes in memory (memtable)</li><li>Flush full memtables to disk as immutable sorted files (SSTables)</li><li>Periodically merge SSTables in the background (compaction)</li></ol><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Writes → [Memtable] → Flush → [L0 SSTables] → Compact → [L1] → ... → [Ln]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Memory:
</span></span><span style=display:flex><span>┌─────────────────┐
</span></span><span style=display:flex><span>│   Memtable      │  ← All writes go here first
</span></span><span style=display:flex><span>│ (sorted, mutable)│
</span></span><span style=display:flex><span>└─────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disk:
</span></span><span style=display:flex><span>┌─────────────────┐
</span></span><span style=display:flex><span>│   Level 0       │  ← Recently flushed, may overlap
</span></span><span style=display:flex><span>│ SST SST SST     │
</span></span><span style=display:flex><span>├─────────────────┤
</span></span><span style=display:flex><span>│   Level 1       │  ← Compacted, non-overlapping
</span></span><span style=display:flex><span>│ SST SST SST SST │
</span></span><span style=display:flex><span>├─────────────────┤
</span></span><span style=display:flex><span>│   Level 2       │  ← Larger, non-overlapping
</span></span><span style=display:flex><span>│ SST SST SST ... │
</span></span><span style=display:flex><span>└─────────────────┘
</span></span></code></pre></div><h3 id="32-the-memtable">3.2 The Memtable</h3><p>The memtable is an in-memory sorted data structure—typically a skip list or red-black tree:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Memtable</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, max_size):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>data <span style=color:#ff7b72;font-weight:700>=</span> SkipList()  <span style=color:#8b949e;font-style:italic># Or RedBlackTree</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>max_size <span style=color:#ff7b72;font-weight:700>=</span> max_size
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>wal <span style=color:#ff7b72;font-weight:700>=</span> WriteAheadLog()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key, value):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Write to WAL for durability</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>wal<span style=color:#ff7b72;font-weight:700>.</span>append(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Insert into sorted structure</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>insert(key, value)
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>+=</span> len(key) <span style=color:#ff7b72;font-weight:700>+</span> len(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>is_full</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> self<span style=color:#ff7b72;font-weight:700>.</span>max_size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>flush_to_sstable</span>(self, path):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Write sorted data to disk</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>with</span> SSTableWriter(path) <span style=color:#ff7b72>as</span> writer:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> key, value <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>iterate():
</span></span><span style=display:flex><span>                writer<span style=color:#ff7b72;font-weight:700>.</span>write(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Clear WAL after successful flush</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>wal<span style=color:#ff7b72;font-weight:700>.</span>truncate()
</span></span></code></pre></div><h3 id="33-sstables-sorted-string-tables">3.3 SSTables (Sorted String Tables)</h3><p>SSTables are immutable files containing sorted key-value pairs:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>SSTable File Structure:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Data Block 1                            │
</span></span><span style=display:flex><span>│   key1:value1, key2:value2, ...         │
</span></span><span style=display:flex><span>├─────────────────────────────────────────┤
</span></span><span style=display:flex><span>│ Data Block 2                            │
</span></span><span style=display:flex><span>│   key100:value100, key101:value101, ... │
</span></span><span style=display:flex><span>├─────────────────────────────────────────┤
</span></span><span style=display:flex><span>│ ...                                     │
</span></span><span style=display:flex><span>├─────────────────────────────────────────┤
</span></span><span style=display:flex><span>│ Index Block                             │
</span></span><span style=display:flex><span>│   block1_last_key → offset              │
</span></span><span style=display:flex><span>│   block2_last_key → offset              │
</span></span><span style=display:flex><span>├─────────────────────────────────────────┤
</span></span><span style=display:flex><span>│ Bloom Filter                            │
</span></span><span style=display:flex><span>│   (probabilistic membership test)       │
</span></span><span style=display:flex><span>├─────────────────────────────────────────┤
</span></span><span style=display:flex><span>│ Footer (metadata)                       │
</span></span><span style=display:flex><span>└─────────────────────────────────────────┘
</span></span></code></pre></div><p>Key features:</p><ul><li><strong>Block-based:</strong> Data is organized into fixed-size blocks for efficient I/O</li><li><strong>Sparse index:</strong> Only boundary keys are indexed, not every key</li><li><strong>Bloom filter:</strong> Quickly determine if a key might exist (avoiding disk reads)</li><li><strong>Compression:</strong> Blocks are typically compressed (LZ4, Snappy, Zstd)</li></ul><h3 id="34-point-lookup">3.4 Point Lookup</h3><p>Reading from an LSM-Tree requires checking multiple levels:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LSMTree</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># 1. Check memtable first (most recent data)</span>
</span></span><span style=display:flex><span>        value <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>is</span> <span style=color:#ff7b72;font-weight:700>not</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span> <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> TOMBSTONE <span style=color:#ff7b72>else</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># 2. Check immutable memtables (being flushed)</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> imm <span style=color:#ff7b72;font-weight:700>in</span> reversed(self<span style=color:#ff7b72;font-weight:700>.</span>immutable_memtables):
</span></span><span style=display:flex><span>            value <span style=color:#ff7b72;font-weight:700>=</span> imm<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>is</span> <span style=color:#ff7b72;font-weight:700>not</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span> <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> TOMBSTONE <span style=color:#ff7b72>else</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># 3. Check SSTables from newest to oldest</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> level <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>levels:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> sstable <span style=color:#ff7b72;font-weight:700>in</span> level<span style=color:#ff7b72;font-weight:700>.</span>get_candidates(key):
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic># Check bloom filter first</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> sstable<span style=color:#ff7b72;font-weight:700>.</span>bloom_filter<span style=color:#ff7b72;font-weight:700>.</span>might_contain(key):
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                value <span style=color:#ff7b72;font-weight:700>=</span> sstable<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>is</span> <span style=color:#ff7b72;font-weight:700>not</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span> <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> TOMBSTONE <span style=color:#ff7b72>else</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span>
</span></span></code></pre></div><p>This is the read amplification problem: a single lookup might check many SSTables.</p><h3 id="35-compaction">3.5 Compaction</h3><p>Compaction merges SSTables to reduce read amplification and reclaim space:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>compact_level</span>(self, level):
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;Merge SSTables from level L into level L+1.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Select SSTables to compact</span>
</span></span><span style=display:flex><span>    input_sstables <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>select_for_compaction(level)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Find overlapping SSTables in next level</span>
</span></span><span style=display:flex><span>    key_range <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>get_key_range(input_sstables)
</span></span><span style=display:flex><span>    target_sstables <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>levels[level <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>]<span style=color:#ff7b72;font-weight:700>.</span>get_overlapping(key_range)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Merge-sort all inputs</span>
</span></span><span style=display:flex><span>    merged <span style=color:#ff7b72;font-weight:700>=</span> MergingIterator(input_sstables <span style=color:#ff7b72;font-weight:700>+</span> target_sstables)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Write new SSTables</span>
</span></span><span style=display:flex><span>    new_sstables <span style=color:#ff7b72;font-weight:700>=</span> []
</span></span><span style=display:flex><span>    writer <span style=color:#ff7b72;font-weight:700>=</span> SSTableWriter()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> key, value <span style=color:#ff7b72;font-weight:700>in</span> merged:
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Skip older versions of the same key</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> key <span style=color:#ff7b72;font-weight:700>==</span> last_key:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Skip tombstones at the bottom level</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> TOMBSTONE <span style=color:#ff7b72;font-weight:700>and</span> level <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span> <span style=color:#ff7b72;font-weight:700>==</span> self<span style=color:#ff7b72;font-weight:700>.</span>max_level:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        writer<span style=color:#ff7b72;font-weight:700>.</span>write(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> writer<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> self<span style=color:#ff7b72;font-weight:700>.</span>target_sstable_size:
</span></span><span style=display:flex><span>            new_sstables<span style=color:#ff7b72;font-weight:700>.</span>append(writer<span style=color:#ff7b72;font-weight:700>.</span>finish())
</span></span><span style=display:flex><span>            writer <span style=color:#ff7b72;font-weight:700>=</span> SSTableWriter()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Atomically swap old SSTables for new ones</span>
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>apply_compaction(
</span></span><span style=display:flex><span>        level<span style=color:#ff7b72;font-weight:700>=</span>level,
</span></span><span style=display:flex><span>        old_sstables<span style=color:#ff7b72;font-weight:700>=</span>input_sstables <span style=color:#ff7b72;font-weight:700>+</span> target_sstables,
</span></span><span style=display:flex><span>        new_sstables<span style=color:#ff7b72;font-weight:700>=</span>new_sstables
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><h3 id="36-compaction-strategies">3.6 Compaction Strategies</h3><p>Different strategies trade off write amplification, space amplification, and read performance:</p><p><strong>Leveled Compaction (LevelDB, RocksDB default):</strong></p><ul><li>Each level is 10x larger than the previous</li><li>Non-overlapping SSTables within each level (except L0)</li><li>Low space amplification (~1.1x)</li><li>Higher write amplification (10-30x)</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>L0: [SST] [SST] [SST]     ← Overlapping, recently flushed
</span></span><span style=display:flex><span>L1: [--|--|--]            ← 10MB total, non-overlapping
</span></span><span style=display:flex><span>L2: [--|--|--|--|--|--]   ← 100MB total, non-overlapping
</span></span><span style=display:flex><span>L3: [--|--|--|--|--|...] ← 1GB total, non-overlapping
</span></span></code></pre></div><p><strong>Size-Tiered Compaction (Cassandra, HBase):</strong></p><ul><li>Group SSTables by size</li><li>Merge SSTables of similar size together</li><li>Lower write amplification (4-8x)</li><li>Higher space amplification (up to 2x)</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Tier 1: [small] [small] [small] [small] → merge → [medium]
</span></span><span style=display:flex><span>Tier 2: [medium] [medium] [medium]      → merge → [large]
</span></span><span style=display:flex><span>Tier 3: [large] [large]                 → merge → [huge]
</span></span></code></pre></div><p><strong>FIFO Compaction:</strong></p><ul><li>Simply delete oldest SSTables</li><li>Useful for time-series data with TTL</li></ul><p><strong>Universal Compaction (RocksDB):</strong></p><ul><li>Hybrid approach balancing write and space amplification</li><li>Adapts based on workload characteristics</li></ul><h3 id="37-bloom-filters">3.7 Bloom Filters</h3><p>Bloom filters dramatically reduce read amplification:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>BloomFilter</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, expected_items, false_positive_rate<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>0.01</span>):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Calculate optimal size and hash count</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>optimal_size(expected_items, false_positive_rate)
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>num_hashes <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>optimal_hashes(self<span style=color:#ff7b72;font-weight:700>.</span>size, expected_items)
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>bits <span style=color:#ff7b72;font-weight:700>=</span> bitarray(self<span style=color:#ff7b72;font-weight:700>.</span>size)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>add</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>in</span> range(self<span style=color:#ff7b72;font-weight:700>.</span>num_hashes):
</span></span><span style=display:flex><span>            idx <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>hash(key, i) <span style=color:#ff7b72;font-weight:700>%</span> self<span style=color:#ff7b72;font-weight:700>.</span>size
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>bits[idx] <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>might_contain</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>in</span> range(self<span style=color:#ff7b72;font-weight:700>.</span>num_hashes):
</span></span><span style=display:flex><span>            idx <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>hash(key, i) <span style=color:#ff7b72;font-weight:700>%</span> self<span style=color:#ff7b72;font-weight:700>.</span>size
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> self<span style=color:#ff7b72;font-weight:700>.</span>bits[idx]:
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>False</span>  <span style=color:#8b949e;font-style:italic># Definitely not present</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>True</span>  <span style=color:#8b949e;font-style:italic># Might be present (possible false positive)</span>
</span></span></code></pre></div><p>With a 1% false positive rate, a bloom filter uses about 10 bits per key. For an SSTable with 1 million keys, the bloom filter is only ~1.2MB—easily cached in memory.</p><h3 id="38-deletions-and-tombstones">3.8 Deletions and Tombstones</h3><p>LSM-Trees handle deletions with tombstones—special markers indicating a key is deleted:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>delete</span>(self, key):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Write a tombstone marker</span>
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>put(key, TOMBSTONE)
</span></span></code></pre></div><p>Tombstones are removed during compaction at the bottom level:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>should_keep_during_compaction</span>(self, key, value, level):
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>!=</span> TOMBSTONE:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Keep tombstones until they reach the bottom level</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># (to shadow older versions in lower levels)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> level <span style=color:#ff7b72;font-weight:700>&lt;</span> self<span style=color:#ff7b72;font-weight:700>.</span>max_level:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># At bottom level, tombstone can be removed</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>False</span>
</span></span></code></pre></div><p>This means deleted data isn&rsquo;t immediately reclaimed—space is freed only after compaction propagates tombstones to the bottom.</p><h2 id="4-b-trees-vs-lsm-trees-the-trade-offs">4. B-Trees vs. LSM-Trees: The Trade-offs</h2><h3 id="41-write-performance">4.1 Write Performance</h3><p><strong>LSM-Trees win for writes:</strong></p><ul><li>Sequential I/O for all writes (memtable flush, compaction)</li><li>Batching amortizes overhead</li><li>Write amplification: 10-30x (leveled) or 4-8x (size-tiered)</li></ul><p><strong>B-Trees have higher write cost:</strong></p><ul><li>Random I/O for in-place updates</li><li>Each write modifies a specific page</li><li>Write amplification: ~2x (page + WAL)</li></ul><p>However, B-Trees have lower tail latency—no background compaction causing jitter.</p><h3 id="42-read-performance">4.2 Read Performance</h3><p><strong>B-Trees win for point reads:</strong></p><ul><li>Guaranteed O(log n) with ~3-4 disk reads for billion-key datasets</li><li>No need to check multiple files</li><li>Consistent, predictable latency</li></ul><p><strong>LSM-Trees have higher read cost:</strong></p><ul><li>Must check multiple levels</li><li>Bloom filters help but aren&rsquo;t perfect</li><li>Read amplification can be 10x+ without careful tuning</li></ul><h3 id="43-space-efficiency">4.3 Space Efficiency</h3><p><strong>LSM-Trees can be more efficient:</strong></p><ul><li>Compression is more effective on sorted, immutable blocks</li><li>No page fragmentation</li><li>But tombstones and multiple versions consume space temporarily</li></ul><p><strong>B-Trees have consistent space usage:</strong></p><ul><li>Pages can be partially filled (typically 70-80%)</li><li>No temporary space overhead from compaction</li><li>Fragmentation over time requires rebuilding</li></ul><h3 id="44-summary-table">4.4 Summary Table</h3><table><thead><tr><th>Metric</th><th>B-Tree</th><th>LSM-Tree</th></tr></thead><tbody><tr><td>Write throughput</td><td>Lower</td><td>Higher</td></tr><tr><td>Write latency</td><td>Consistent</td><td>Variable (compaction)</td></tr><tr><td>Point read</td><td>Faster</td><td>Slower</td></tr><tr><td>Range scan</td><td>Fast</td><td>Fast</td></tr><tr><td>Write amplification</td><td>~2x</td><td>10-30x</td></tr><tr><td>Read amplification</td><td>1x</td><td>1-10x</td></tr><tr><td>Space amplification</td><td>1.3-1.5x</td><td>1.1-2x</td></tr><tr><td>Concurrency</td><td>Complex</td><td>Simpler</td></tr></tbody></table><h2 id="5-advanced-b-tree-techniques">5. Advanced B-Tree Techniques</h2><h3 id="51-prefix-compression">5.1 Prefix Compression</h3><p>Many keys share common prefixes. Compress them:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Without compression:
</span></span><span style=display:flex><span>  &#34;user:alice:profile&#34;
</span></span><span style=display:flex><span>  &#34;user:alice:settings&#34;
</span></span><span style=display:flex><span>  &#34;user:bob:profile&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>With prefix compression:
</span></span><span style=display:flex><span>  &#34;user:alice:profile&#34;
</span></span><span style=display:flex><span>  [8]&#34;settings&#34;        ← Share 8 bytes with previous key
</span></span><span style=display:flex><span>  [5]&#34;bob:profile&#34;     ← Share 5 bytes with previous key
</span></span></code></pre></div><p>This can reduce index size by 50% or more for certain key patterns.</p><h3 id="52-suffix-truncation">5.2 Suffix Truncation</h3><p>Internal nodes only need enough of the key to distinguish children:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Full keys in leaves:
</span></span><span style=display:flex><span>  &#34;application_server_1&#34;
</span></span><span style=display:flex><span>  &#34;application_server_2&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Truncated separator in internal node:
</span></span><span style=display:flex><span>  &#34;application_server_1&#34; vs &#34;application_server_2&#34;
</span></span><span style=display:flex><span>  Can use just &#34;application_server_2&#34; as separator
</span></span><span style=display:flex><span>  Or even just &#34;2&#34; if context is clear
</span></span></code></pre></div><h3 id="53-bulk-loading">5.3 Bulk Loading</h3><p>Building a B-Tree from sorted data is much faster than individual inserts:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>bulk_load</span>(sorted_data, page_size):
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;Build a B-Tree from sorted data, bottom-up.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Create leaf pages</span>
</span></span><span style=display:flex><span>    leaves <span style=color:#ff7b72;font-weight:700>=</span> []
</span></span><span style=display:flex><span>    current_page <span style=color:#ff7b72;font-weight:700>=</span> Page()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> key, value <span style=color:#ff7b72;font-weight:700>in</span> sorted_data:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> current_page<span style=color:#ff7b72;font-weight:700>.</span>is_full():
</span></span><span style=display:flex><span>            leaves<span style=color:#ff7b72;font-weight:700>.</span>append(current_page)
</span></span><span style=display:flex><span>            current_page <span style=color:#ff7b72;font-weight:700>=</span> Page()
</span></span><span style=display:flex><span>        current_page<span style=color:#ff7b72;font-weight:700>.</span>add(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> current_page<span style=color:#ff7b72;font-weight:700>.</span>is_empty():
</span></span><span style=display:flex><span>        leaves<span style=color:#ff7b72;font-weight:700>.</span>append(current_page)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Link leaves</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>in</span> range(len(leaves) <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>1</span>):
</span></span><span style=display:flex><span>        leaves[i]<span style=color:#ff7b72;font-weight:700>.</span>next <span style=color:#ff7b72;font-weight:700>=</span> leaves[i <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Build internal nodes bottom-up</span>
</span></span><span style=display:flex><span>    current_level <span style=color:#ff7b72;font-weight:700>=</span> leaves
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> len(current_level) <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>1</span>:
</span></span><span style=display:flex><span>        next_level <span style=color:#ff7b72;font-weight:700>=</span> []
</span></span><span style=display:flex><span>        current_page <span style=color:#ff7b72;font-weight:700>=</span> InternalPage()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> page <span style=color:#ff7b72;font-weight:700>in</span> current_level:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> current_page<span style=color:#ff7b72;font-weight:700>.</span>is_full():
</span></span><span style=display:flex><span>                next_level<span style=color:#ff7b72;font-weight:700>.</span>append(current_page)
</span></span><span style=display:flex><span>                current_page <span style=color:#ff7b72;font-weight:700>=</span> InternalPage()
</span></span><span style=display:flex><span>            current_page<span style=color:#ff7b72;font-weight:700>.</span>add_child(page<span style=color:#ff7b72;font-weight:700>.</span>first_key(), page)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> current_page<span style=color:#ff7b72;font-weight:700>.</span>is_empty():
</span></span><span style=display:flex><span>            next_level<span style=color:#ff7b72;font-weight:700>.</span>append(current_page)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        current_level <span style=color:#ff7b72;font-weight:700>=</span> next_level
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> BTree(root<span style=color:#ff7b72;font-weight:700>=</span>current_level[<span style=color:#a5d6ff>0</span>])
</span></span></code></pre></div><p>Bulk loading achieves 100% page fill factor and optimal layout.</p><h3 id="54-copy-on-write-b-trees">5.4 Copy-on-Write B-Trees</h3><p>Instead of in-place updates, create new pages:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put_cow</span>(self, key, value):
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;Copy-on-write insertion.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    path <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>find_path(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Create new leaf with the update</span>
</span></span><span style=display:flex><span>    new_leaf <span style=color:#ff7b72;font-weight:700>=</span> path[<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>]<span style=color:#ff7b72;font-weight:700>.</span>copy()
</span></span><span style=display:flex><span>    new_leaf<span style=color:#ff7b72;font-weight:700>.</span>insert(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Propagate new pages up to root</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>in</span> range(len(path) <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>2</span>, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>):
</span></span><span style=display:flex><span>        new_node <span style=color:#ff7b72;font-weight:700>=</span> path[i]<span style=color:#ff7b72;font-weight:700>.</span>copy()
</span></span><span style=display:flex><span>        new_node<span style=color:#ff7b72;font-weight:700>.</span>replace_child(path[i <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>], new_pages[<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>])
</span></span><span style=display:flex><span>        new_pages<span style=color:#ff7b72;font-weight:700>.</span>append(new_node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Atomic root pointer swap</span>
</span></span><span style=display:flex><span>    self<span style=color:#ff7b72;font-weight:700>.</span>root <span style=color:#ff7b72;font-weight:700>=</span> new_pages[<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Old pages can be garbage collected</span>
</span></span></code></pre></div><p>Benefits:</p><ul><li><strong>Crash safety:</strong> No torn writes (old tree is always consistent)</li><li><strong>Snapshots:</strong> Keep old root for point-in-time reads</li><li><strong>Concurrency:</strong> Readers never block writers</li></ul><p>Used by LMDB, BoltDB, and some file systems (Btrfs, ZFS).</p><h2 id="6-advanced-lsm-tree-techniques">6. Advanced LSM-Tree Techniques</h2><h3 id="61-partitioned-indexes">6.1 Partitioned Indexes</h3><p>Instead of one global index, partition by key range:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>PartitionedLSM</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, num_partitions):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>partitions <span style=color:#ff7b72;font-weight:700>=</span> [LSMTree() <span style=color:#ff7b72>for</span> _ <span style=color:#ff7b72;font-weight:700>in</span> range(num_partitions)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get_partition</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Consistent hashing or range-based partitioning</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>partitions[hash(key) <span style=color:#ff7b72;font-weight:700>%</span> len(self<span style=color:#ff7b72;font-weight:700>.</span>partitions)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key, value):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>get_partition(key)<span style=color:#ff7b72;font-weight:700>.</span>put(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>get_partition(key)<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span></code></pre></div><p>Benefits:</p><ul><li>Parallel compaction across partitions</li><li>Better cache locality</li><li>Isolation of hot key ranges</li></ul><h3 id="62-tiered--leveled-hybrid">6.2 Tiered + Leveled Hybrid</h3><p>Combine size-tiered compaction at L0-L1 with leveled compaction below:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>L0: [SST] [SST] [SST] [SST]  ← Size-tiered (fast ingestion)
</span></span><span style=display:flex><span>L1: [SST] [SST] [SST]        ← Size-tiered (buffer)
</span></span><span style=display:flex><span>L2: [--|--|--|--|--|--]      ← Leveled (good read performance)
</span></span><span style=display:flex><span>L3: [--|--|--|--|--|...]     ← Leveled
</span></span></code></pre></div><p>This balances write throughput (size-tiered at top) with read performance (leveled at bottom).</p><h3 id="63-remote-compaction">6.3 Remote Compaction</h3><p>Offload compaction to dedicated servers:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>RemoteCompaction</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>compact</span>(self, sstables):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Upload SSTables to compaction server</span>
</span></span><span style=display:flex><span>        uploaded <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>upload_to_remote(sstables)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Request compaction</span>
</span></span><span style=display:flex><span>        job_id <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>compaction_service<span style=color:#ff7b72;font-weight:700>.</span>submit(uploaded)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Wait for result</span>
</span></span><span style=display:flex><span>        result <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>compaction_service<span style=color:#ff7b72;font-weight:700>.</span>wait(job_id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Download compacted SSTables</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>download_result(result)
</span></span></code></pre></div><p>Benefits:</p><ul><li>Compaction doesn&rsquo;t consume local CPU/IO</li><li>Better resource isolation</li><li>Scales compaction independently</li></ul><p>Used by Neon (Postgres), TiDB, and cloud-native databases.</p><h3 id="64-learned-indexes">6.4 Learned Indexes</h3><p>Replace bloom filters with machine learning models:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LearnedBloomFilter</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, keys):
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Train a model to predict key membership</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>model <span style=color:#ff7b72;font-weight:700>=</span> train_classifier(keys)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Backup bloom filter for false negatives</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>backup_bloom <span style=color:#ff7b72;font-weight:700>=</span> BloomFilter(false_negative_keys)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>might_contain</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> self<span style=color:#ff7b72;font-weight:700>.</span>model<span style=color:#ff7b72;font-weight:700>.</span>predict(key) <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0.5</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>True</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>backup_bloom<span style=color:#ff7b72;font-weight:700>.</span>might_contain(key)
</span></span></code></pre></div><p>Learned filters can achieve the same false positive rate with less memory—up to 70% savings in some workloads.</p><h2 id="7-hybrid-approaches">7. Hybrid Approaches</h2><h3 id="71-bw-tree-microsoft">7.1 Bw-Tree (Microsoft)</h3><p>Combines B-Tree structure with log-structured updates:</p><ul><li>Base B-Tree pages are immutable</li><li>Updates are appended as delta records</li><li>Deltas are periodically consolidated</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Page 42:
</span></span><span style=display:flex><span>┌─────────────────┐
</span></span><span style=display:flex><span>│  Delta: DEL(k5) │ → ┌─────────────────┐
</span></span><span style=display:flex><span>└─────────────────┘   │  Delta: PUT(k3) │ → ┌─────────────────┐
</span></span><span style=display:flex><span>                      └─────────────────┘   │  Base Page      │
</span></span><span style=display:flex><span>                                            │  k1, k2, k3, k5 │
</span></span><span style=display:flex><span>                                            └─────────────────┘
</span></span></code></pre></div><p>Benefits:</p><ul><li>No write-ahead log needed (deltas are the log)</li><li>Latch-free operation using CAS</li><li>Used by Microsoft SQL Server Hekaton</li></ul><h3 id="72-bε-trees">7.2 Bε-Trees</h3><p>Bε-Trees (B-epsilon trees) are a middle ground:</p><ul><li>Like B-Trees, but internal nodes have buffers</li><li>Writes accumulate in buffers and trickle down</li><li>Asymptotically optimal for both reads and writes</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Internal node:
</span></span><span style=display:flex><span>┌─────────────────────────────────┐
</span></span><span style=display:flex><span>│ Keys: [30 | 60]                 │
</span></span><span style=display:flex><span>│ Children: [ptr1 | ptr2 | ptr3] │
</span></span><span style=display:flex><span>│ Buffer: [(k15, v15), (k45, v45), (k72, v72)] │
</span></span><span style=display:flex><span>└─────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When buffer fills, flush entries to appropriate children.
</span></span></code></pre></div><p>Used by TokuDB (Percona), BetrFS.</p><h3 id="73-cola-cache-oblivious-lookahead-array">7.3 COLA (Cache-Oblivious Lookahead Array)</h3><p>Achieves optimal write performance without knowing cache/memory hierarchy:</p><ul><li>Array of arrays, each double the previous size</li><li>Fractional cascading for efficient searches</li><li>Automatic adaptation to any cache size</li></ul><h2 id="8-choosing-the-right-storage-engine">8. Choosing the Right Storage Engine</h2><h3 id="81-workload-analysis">8.1 Workload Analysis</h3><p>Ask these questions:</p><ol><li><strong>Read/write ratio:</strong> >80% reads? B-Tree. Write-heavy? LSM-Tree.</li><li><strong>Key access patterns:</strong> Hot keys? Uniform? Time-ordered?</li><li><strong>Latency requirements:</strong> Need consistent P99? B-Tree. Can tolerate jitter? LSM-Tree.</li><li><strong>Data size:</strong> Fits in memory? Either works. Much larger? Consider compaction I/O.</li><li><strong>Durability requirements:</strong> Synchronous writes? Both can do it, but with different trade-offs.</li></ol><h3 id="82-decision-matrix">8.2 Decision Matrix</h3><table><thead><tr><th>Workload</th><th>Recommended</th><th>Reason</th></tr></thead><tbody><tr><td>OLTP (transactions)</td><td>B-Tree</td><td>Consistent latency, point queries</td></tr><tr><td>Time-series</td><td>LSM-Tree</td><td>Sequential writes, range scans</td></tr><tr><td>Analytics</td><td>Columnar (not covered)</td><td>Aggregations, compression</td></tr><tr><td>Key-value cache</td><td>LSM-Tree</td><td>High write throughput</td></tr><tr><td>Mixed</td><td>Depends</td><td>Profile your workload</td></tr></tbody></table><h3 id="83-tuning-parameters">8.3 Tuning Parameters</h3><p><strong>For B-Trees:</strong></p><ul><li>Page size: Match filesystem/storage block size</li><li>Fill factor: Trade insert performance for space efficiency</li><li>Checkpoint frequency: Balance durability vs. I/O</li></ul><p><strong>For LSM-Trees:</strong></p><ul><li>Memtable size: Larger = fewer flushes, more memory</li><li>Level size ratio: 10x is typical; lower = more levels, less write amplification</li><li>Compaction threads: More parallelism, more I/O contention</li><li>Bloom filter bits per key: 10 bits ≈ 1% false positive</li></ul><h2 id="9-debugging-and-monitoring">9. Debugging and Monitoring</h2><h3 id="91-key-metrics">9.1 Key Metrics</h3><p><strong>B-Tree:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>BTreeMetrics</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>report</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;height&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>tree<span style=color:#ff7b72;font-weight:700>.</span>height(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;total_pages&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>tree<span style=color:#ff7b72;font-weight:700>.</span>page_count(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;fill_factor&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>tree<span style=color:#ff7b72;font-weight:700>.</span>average_fill_factor(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;cache_hit_rate&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>buffer_pool<span style=color:#ff7b72;font-weight:700>.</span>hit_rate(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;checkpoint_lag&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>wal<span style=color:#ff7b72;font-weight:700>.</span>checkpoint_lag(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;page_splits_per_sec&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>split_counter<span style=color:#ff7b72;font-weight:700>.</span>rate(),
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>LSM-Tree:</strong></p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LSMMetrics</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>report</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;memtable_size&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>size,
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;levels&#34;</span>: [len(level<span style=color:#ff7b72;font-weight:700>.</span>sstables) <span style=color:#ff7b72>for</span> level <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>levels],
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;pending_compaction_bytes&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>compaction_queue<span style=color:#ff7b72;font-weight:700>.</span>total_bytes(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;write_stall_duration&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>stall_counter<span style=color:#ff7b72;font-weight:700>.</span>total_ms(),
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;bloom_filter_useful&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>bloom_useful <span style=color:#ff7b72;font-weight:700>/</span> self<span style=color:#ff7b72;font-weight:700>.</span>bloom_checks,
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>&#34;read_amplification&#34;</span>: self<span style=color:#ff7b72;font-weight:700>.</span>disk_reads <span style=color:#ff7b72;font-weight:700>/</span> self<span style=color:#ff7b72;font-weight:700>.</span>logical_reads,
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h3 id="92-common-problems">9.2 Common Problems</h3><p><strong>B-Tree issues:</strong></p><ul><li><strong>Page splits cascading:</strong> Bulk loading sorted data causes worst-case splits</li><li><strong>Lock contention:</strong> Hot pages become bottlenecks</li><li><strong>Checkpoint storms:</strong> Large buffer pools take long to flush</li></ul><p><strong>LSM-Tree issues:</strong></p><ul><li><strong>Write stalls:</strong> Compaction can&rsquo;t keep up with writes</li><li><strong>Space amplification spikes:</strong> During compaction, old and new SSTables coexist</li><li><strong>Read amplification:</strong> Too many L0 files or missing bloom filters</li></ul><h2 id="10-real-world-implementations">10. Real-World Implementations</h2><h3 id="101-postgresql-b-tree">10.1 PostgreSQL (B-Tree)</h3><p>PostgreSQL&rsquo;s B-Tree implementation is a masterclass in production engineering:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-sql" data-lang=sql><span style=display:flex><span><span style=color:#8b949e;font-style:italic>-- Create a B-Tree index
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>CREATE</span><span style=color:#6e7681> </span><span style=color:#ff7b72>INDEX</span><span style=color:#6e7681> </span>idx_users_email<span style=color:#6e7681> </span><span style=color:#ff7b72>ON</span><span style=color:#6e7681> </span>users<span style=color:#6e7681> </span>(email);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>-- Examine index structure
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>SELECT</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#6e7681> </span><span style=color:#ff7b72>FROM</span><span style=color:#6e7681> </span>bt_metap(<span style=color:#a5d6ff>&#39;idx_users_email&#39;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>-- Returns: magic, version, root, level, fastroot, fastlevel, ...
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>-- Page-level inspection
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>SELECT</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>*</span><span style=color:#6e7681> </span><span style=color:#ff7b72>FROM</span><span style=color:#6e7681> </span>bt_page_stats(<span style=color:#a5d6ff>&#39;idx_users_email&#39;</span>,<span style=color:#6e7681> </span><span style=color:#a5d6ff>1</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>-- Returns: blkno, type, live_items, dead_items, avg_item_size, ...
</span></span></span></code></pre></div><p>Key implementation details:</p><ul><li><strong>MVCC integration:</strong> Index entries point to heap tuples, visibility checked at read time</li><li><strong>HOT updates:</strong> Heap-Only Tuples avoid index updates for non-indexed column changes</li><li><strong>Deferred splits:</strong> Splits are logged and can be replayed during recovery</li><li><strong>Right-link pointers:</strong> Allow lock-free traversal of siblings during splits</li></ul><h3 id="102-rocksdb-lsm-tree">10.2 RocksDB (LSM-Tree)</h3><p>RocksDB is Facebook&rsquo;s production LSM-Tree, used by TiKV, CockroachDB, and many others:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Basic RocksDB usage
</span></span></span><span style=display:flex><span>rocksdb<span style=color:#ff7b72;font-weight:700>::</span>DB<span style=color:#ff7b72;font-weight:700>*</span> db;
</span></span><span style=display:flex><span>rocksdb<span style=color:#ff7b72;font-weight:700>::</span>Options options;
</span></span><span style=display:flex><span>options.create_if_missing <span style=color:#ff7b72;font-weight:700>=</span> true;
</span></span><span style=display:flex><span>options.write_buffer_size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>64</span> <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#a5d6ff>1024</span> <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#a5d6ff>1024</span>;  <span style=color:#8b949e;font-style:italic>// 64MB memtable
</span></span></span><span style=display:flex><span>options.max_write_buffer_number <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>3</span>;
</span></span><span style=display:flex><span>options.level0_file_num_compaction_trigger <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rocksdb<span style=color:#ff7b72;font-weight:700>::</span>Status status <span style=color:#ff7b72;font-weight:700>=</span> rocksdb<span style=color:#ff7b72;font-weight:700>::</span>DB<span style=color:#ff7b72;font-weight:700>::</span>Open(options, <span style=color:#a5d6ff>&#34;/tmp/testdb&#34;</span>, <span style=color:#ff7b72;font-weight:700>&amp;</span>db);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>db<span style=color:#ff7b72;font-weight:700>-&gt;</span>Put(rocksdb<span style=color:#ff7b72;font-weight:700>::</span>WriteOptions(), <span style=color:#a5d6ff>&#34;key1&#34;</span>, <span style=color:#a5d6ff>&#34;value1&#34;</span>);
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>string value;
</span></span><span style=display:flex><span>db<span style=color:#ff7b72;font-weight:700>-&gt;</span>Get(rocksdb<span style=color:#ff7b72;font-weight:700>::</span>ReadOptions(), <span style=color:#a5d6ff>&#34;key1&#34;</span>, <span style=color:#ff7b72;font-weight:700>&amp;</span>value);
</span></span></code></pre></div><p>Key features:</p><ul><li><strong>Column families:</strong> Multiple LSM-Trees sharing one WAL</li><li><strong>Prefix bloom filters:</strong> Efficient prefix scans</li><li><strong>Rate limiter:</strong> Control compaction I/O impact</li><li><strong>Blob storage:</strong> Large values stored separately for efficiency</li><li><strong>Transactions:</strong> Optimistic and pessimistic transaction support</li></ul><h3 id="103-wiredtiger-hybrid">10.3 WiredTiger (Hybrid)</h3><p>MongoDB&rsquo;s WiredTiger combines B-Tree structure with LSM-like techniques:</p><ul><li><strong>Lookaside table:</strong> Buffers updates to reduce page churn</li><li><strong>Hazard pointers:</strong> Lock-free concurrent access</li><li><strong>Page reconciliation:</strong> Converts in-memory pages to on-disk format</li><li><strong>Checkpoint curse prevention:</strong> Evicts pages incrementally</li></ul><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#8b949e;font-style:italic># MongoDB WiredTiger statistics</span>
</span></span><span style=display:flex><span>db<span style=color:#ff7b72;font-weight:700>.</span>serverStatus()<span style=color:#ff7b72;font-weight:700>.</span>wiredTiger<span style=color:#ff7b72;font-weight:700>.</span>cache
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Returns: bytes currently in cache, tracked dirty bytes, pages read/written</span>
</span></span></code></pre></div><h3 id="104-lmdb-copy-on-write-b-tree">10.4 LMDB (Copy-on-Write B-Tree)</h3><p>Lightning Memory-Mapped Database uses memory-mapped files with CoW B-Trees:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span>MDB_env <span style=color:#ff7b72;font-weight:700>*</span>env;
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_env_create</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>env);
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_env_set_mapsize</span>(env, <span style=color:#a5d6ff>10485760</span>);  <span style=color:#8b949e;font-style:italic>// 10MB
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_env_open</span>(env, <span style=color:#a5d6ff>&#34;./testdb&#34;</span>, <span style=color:#a5d6ff>0</span>, <span style=color:#a5d6ff>0644</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MDB_txn <span style=color:#ff7b72;font-weight:700>*</span>txn;
</span></span><span style=display:flex><span>MDB_dbi dbi;
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_txn_begin</span>(env, NULL, <span style=color:#a5d6ff>0</span>, <span style=color:#ff7b72;font-weight:700>&amp;</span>txn);
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_dbi_open</span>(txn, NULL, <span style=color:#a5d6ff>0</span>, <span style=color:#ff7b72;font-weight:700>&amp;</span>dbi);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MDB_val key <span style=color:#ff7b72;font-weight:700>=</span> {<span style=color:#a5d6ff>3</span>, <span style=color:#a5d6ff>&#34;foo&#34;</span>};
</span></span><span style=display:flex><span>MDB_val value <span style=color:#ff7b72;font-weight:700>=</span> {<span style=color:#a5d6ff>3</span>, <span style=color:#a5d6ff>&#34;bar&#34;</span>};
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_put</span>(txn, dbi, <span style=color:#ff7b72;font-weight:700>&amp;</span>key, <span style=color:#ff7b72;font-weight:700>&amp;</span>value, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>mdb_txn_commit</span>(txn);
</span></span></code></pre></div><p>Key benefits:</p><ul><li><strong>Zero-copy reads:</strong> Direct memory access, no serialization</li><li><strong>Single-writer, multi-reader:</strong> Simple concurrency model</li><li><strong>Crash-proof:</strong> CoW ensures consistent state at all times</li><li><strong>Small footprint:</strong> Minimal runtime dependencies</li></ul><h2 id="11-storage-engine-evolution">11. Storage Engine Evolution</h2><h3 id="111-historical-context">11.1 Historical Context</h3><p>The evolution of storage engines reflects changing hardware and workloads:</p><h4 id="1970s-1990s-b-tree-dominance">1970s-1990s: B-Tree Dominance</h4><ul><li>Disk seeks were expensive (10ms)</li><li>Sequential bandwidth was limited</li><li>B-Trees minimized seeks with high fanout</li><li>ISAM, B-Tree variants in mainframe databases</li></ul><h4 id="2000s-log-structured-renaissance">2000s: Log-Structured Renaissance</h4><ul><li>SSDs changed the calculus (no seek penalty)</li><li>Write amplification became critical (SSD wear)</li><li>LSM-Trees enabled write-heavy workloads</li><li>BigTable, LevelDB pioneered practical LSM implementations</li></ul><h4 id="2010s-hybrid-and-specialized">2010s: Hybrid and Specialized</h4><ul><li>Cloud storage added network latency considerations</li><li>Tiered storage (memory, SSD, HDD) required adaptation</li><li>Learned indexes emerged from ML research</li><li>Persistent memory (Intel Optane) blurred memory/storage boundary</li></ul><h4 id="2020s-disaggregated-and-cloud-native">2020s: Disaggregated and Cloud-Native</h4><ul><li>Compute and storage separation</li><li>Remote compaction offloading</li><li>Object storage as primary persistence</li><li>Serverless databases with pay-per-query</li></ul><h3 id="112-emerging-trends">11.2 Emerging Trends</h3><p><strong>Persistent Memory (PMEM):</strong></p><p>Traditional assumptions break down with byte-addressable persistent memory:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Intel Optane PMEM access
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#ff7b72;font-weight:700>*</span>pmem_addr <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>pmem_map_file</span>(<span style=color:#a5d6ff>&#34;/pmem/db&#34;</span>, size, ...);
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>pmem_memcpy_persist</span>(pmem_addr <span style=color:#ff7b72;font-weight:700>+</span> offset, data, len);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Data is durable after memcpy returns!
</span></span></span></code></pre></div><p>New data structures emerge:</p><ul><li><strong>FAST&amp;FAIR:</strong> B-Tree variant for PMEM</li><li><strong>SLM-DB:</strong> Single-level merge for PMEM</li><li><strong>FPTree:</strong> Fingerprint-based tree for hybrid DRAM/PMEM</li></ul><p><strong>GPU-Accelerated Storage:</strong></p><p>GPUs can accelerate certain storage operations:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-fallback" data-lang=fallback><span style=display:flex><span>// GPU-accelerated binary search
</span></span><span style=display:flex><span>__global__ void parallel_lookup(Key* keys, int n, Key target, int* result) {
</span></span><span style=display:flex><span>    int tid="blockIdx.x" * blockDim.x + threadIdx.x;
</span></span><span style=display:flex><span>    // Each thread searches a portion
</span></span><span style=display:flex><span>    int left = tid * (n / NUM_THREADS);
</span></span><span style=display:flex><span>    int right = (tid + 1) * (n / NUM_THREADS) - 1;
</span></span><span style=display:flex><span>    // Binary search in assigned range
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Programmable Storage (Computational Storage):</strong></p><p>Push computation to storage devices:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Computational storage pseudo-code</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>query_on_device</span>(ssd, predicate):
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Filter runs on SSD controller, not host CPU</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> ssd<span style=color:#ff7b72;font-weight:700>.</span>execute(
</span></span><span style=display:flex><span>        operation<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;SCAN&#34;</span>,
</span></span><span style=display:flex><span>        filter<span style=color:#ff7b72;font-weight:700>=</span>predicate,
</span></span><span style=display:flex><span>        projection<span style=color:#ff7b72;font-weight:700>=</span>[<span style=color:#a5d6ff>&#34;id&#34;</span>, <span style=color:#a5d6ff>&#34;name&#34;</span>]
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Only matching rows cross the PCIe bus</span>
</span></span></code></pre></div><h3 id="113-the-future-of-storage-engines">11.3 The Future of Storage Engines</h3><p>Several trends will shape storage engines:</p><ol><li><strong>Automatic tuning:</strong> ML-based configuration optimization</li><li><strong>Workload-adaptive structures:</strong> Data structures that morph based on access patterns</li><li><strong>Cross-layer optimization:</strong> Co-designing storage engine, file system, and device firmware</li><li><strong>Sustainable storage:</strong> Energy-aware algorithms as data centers face power constraints</li><li><strong>Verified implementations:</strong> Formal verification to eliminate subtle bugs</li></ol><h2 id="12-implementing-a-minimal-storage-engine">12. Implementing a Minimal Storage Engine</h2><p>Let&rsquo;s build a simple LSM-Tree from scratch to solidify understanding:</p><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-python" data-lang=python><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>os</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>json</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>struct</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>from</span> <span style=color:#ff7b72>collections</span> <span style=color:#ff7b72>import</span> OrderedDict
</span></span><span style=display:flex><span><span style=color:#ff7b72>from</span> <span style=color:#ff7b72>typing</span> <span style=color:#ff7b72>import</span> Optional, Iterator, Tuple
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Memtable</span>:
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;In-memory sorted buffer using an ordered dictionary.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, max_size: int <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1024</span> <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#a5d6ff>1024</span>):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>data <span style=color:#ff7b72;font-weight:700>=</span> OrderedDict()
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>max_size <span style=color:#ff7b72;font-weight:700>=</span> max_size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key: str, value: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        old_size <span style=color:#ff7b72;font-weight:700>=</span> len(self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>get(key, <span style=color:#a5d6ff>&#34;&#34;</span>)) <span style=color:#ff7b72;font-weight:700>+</span> len(key) <span style=color:#ff7b72>if</span> key <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>data <span style=color:#ff7b72>else</span> <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>data[key] <span style=color:#ff7b72;font-weight:700>=</span> value
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>+=</span> len(key) <span style=color:#ff7b72;font-weight:700>+</span> len(value) <span style=color:#ff7b72;font-weight:700>-</span> old_size
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Keep sorted</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>data <span style=color:#ff7b72;font-weight:700>=</span> OrderedDict(sorted(self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>items()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Optional[str]:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>delete</span>(self, key: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>put(key, <span style=color:#a5d6ff>&#34;__TOMBSTONE__&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>is_full</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> self<span style=color:#ff7b72;font-weight:700>.</span>size <span style=color:#ff7b72;font-weight:700>&gt;=</span> self<span style=color:#ff7b72;font-weight:700>.</span>max_size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>items</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Iterator[Tuple[str, str]]:
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> iter(self<span style=color:#ff7b72;font-weight:700>.</span>data<span style=color:#ff7b72;font-weight:700>.</span>items())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>SSTable</span>:
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;Immutable sorted string table on disk.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, path: str):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>path <span style=color:#ff7b72;font-weight:700>=</span> path
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>index <span style=color:#ff7b72;font-weight:700>=</span> {}  <span style=color:#8b949e;font-style:italic># Sparse index: first key of each block</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>_load_index()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>create</span>(cls, path: str, items: Iterator[Tuple[str, str]]) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#a5d6ff>&#39;SSTable&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Create a new SSTable from sorted key-value pairs.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>with</span> open(path, <span style=color:#a5d6ff>&#39;wb&#39;</span>) <span style=color:#ff7b72>as</span> f:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> key, value <span style=color:#ff7b72;font-weight:700>in</span> items:
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic># Simple format: key_len (4 bytes), key, value_len (4 bytes), value</span>
</span></span><span style=display:flex><span>                key_bytes <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>.</span>encode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>                value_bytes <span style=color:#ff7b72;font-weight:700>=</span> value<span style=color:#ff7b72;font-weight:700>.</span>encode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>                f<span style=color:#ff7b72;font-weight:700>.</span>write(struct<span style=color:#ff7b72;font-weight:700>.</span>pack(<span style=color:#a5d6ff>&#39;I&#39;</span>, len(key_bytes)))
</span></span><span style=display:flex><span>                f<span style=color:#ff7b72;font-weight:700>.</span>write(key_bytes)
</span></span><span style=display:flex><span>                f<span style=color:#ff7b72;font-weight:700>.</span>write(struct<span style=color:#ff7b72;font-weight:700>.</span>pack(<span style=color:#a5d6ff>&#39;I&#39;</span>, len(value_bytes)))
</span></span><span style=display:flex><span>                f<span style=color:#ff7b72;font-weight:700>.</span>write(value_bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> cls(path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>_load_index</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Load sparse index for faster lookups.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> os<span style=color:#ff7b72;font-weight:700>.</span>path<span style=color:#ff7b72;font-weight:700>.</span>exists(self<span style=color:#ff7b72;font-weight:700>.</span>path):
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>with</span> open(self<span style=color:#ff7b72;font-weight:700>.</span>path, <span style=color:#a5d6ff>&#39;rb&#39;</span>) <span style=color:#ff7b72>as</span> f:
</span></span><span style=display:flex><span>            offset <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>while</span> <span style=color:#79c0ff>True</span>:
</span></span><span style=display:flex><span>                pos <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>tell()
</span></span><span style=display:flex><span>                key_len_bytes <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> key_len_bytes:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                key_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, key_len_bytes)[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                key <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(key_len)<span style=color:#ff7b72;font-weight:700>.</span>decode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>                value_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>))[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                f<span style=color:#ff7b72;font-weight:700>.</span>seek(value_len, <span style=color:#a5d6ff>1</span>)  <span style=color:#8b949e;font-style:italic># Skip value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic># Index every 100th key for sparse index</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> offset <span style=color:#ff7b72;font-weight:700>%</span> <span style=color:#a5d6ff>100</span> <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>:
</span></span><span style=display:flex><span>                    self<span style=color:#ff7b72;font-weight:700>.</span>index[key] <span style=color:#ff7b72;font-weight:700>=</span> pos
</span></span><span style=display:flex><span>                offset <span style=color:#ff7b72;font-weight:700>+=</span> <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Optional[str]:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Look up a key in the SSTable.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Find starting position using sparse index</span>
</span></span><span style=display:flex><span>        start_pos <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> indexed_key, pos <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>index<span style=color:#ff7b72;font-weight:700>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> indexed_key <span style=color:#ff7b72;font-weight:700>&lt;=</span> key:
</span></span><span style=display:flex><span>                start_pos <span style=color:#ff7b72;font-weight:700>=</span> pos
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>with</span> open(self<span style=color:#ff7b72;font-weight:700>.</span>path, <span style=color:#a5d6ff>&#39;rb&#39;</span>) <span style=color:#ff7b72>as</span> f:
</span></span><span style=display:flex><span>            f<span style=color:#ff7b72;font-weight:700>.</span>seek(start_pos)
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>while</span> <span style=color:#79c0ff>True</span>:
</span></span><span style=display:flex><span>                key_len_bytes <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> key_len_bytes:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                key_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, key_len_bytes)[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                current_key <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(key_len)<span style=color:#ff7b72;font-weight:700>.</span>decode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>                value_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>))[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                value <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(value_len)<span style=color:#ff7b72;font-weight:700>.</span>decode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> current_key <span style=color:#ff7b72;font-weight:700>==</span> key:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span> <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>&#34;__TOMBSTONE__&#34;</span> <span style=color:#ff7b72>else</span> value
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> current_key <span style=color:#ff7b72;font-weight:700>&gt;</span> key:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span>  <span style=color:#8b949e;font-style:italic># Key not found (data is sorted)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>items</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Iterator[Tuple[str, str]]:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Iterate over all key-value pairs.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>with</span> open(self<span style=color:#ff7b72;font-weight:700>.</span>path, <span style=color:#a5d6ff>&#39;rb&#39;</span>) <span style=color:#ff7b72>as</span> f:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>while</span> <span style=color:#79c0ff>True</span>:
</span></span><span style=display:flex><span>                key_len_bytes <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>not</span> key_len_bytes:
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                key_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, key_len_bytes)[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                key <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(key_len)<span style=color:#ff7b72;font-weight:700>.</span>decode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>                value_len <span style=color:#ff7b72;font-weight:700>=</span> struct<span style=color:#ff7b72;font-weight:700>.</span>unpack(<span style=color:#a5d6ff>&#39;I&#39;</span>, f<span style=color:#ff7b72;font-weight:700>.</span>read(<span style=color:#a5d6ff>4</span>))[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>                value <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>read(value_len)<span style=color:#ff7b72;font-weight:700>.</span>decode(<span style=color:#a5d6ff>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>yield</span> key, value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>SimpleLSM</span>:
</span></span><span style=display:flex><span>    <span style=color:#a5d6ff>&#34;&#34;&#34;A minimal LSM-Tree implementation.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>__init__</span>(self, directory: str, memtable_size: int <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1024</span> <span style=color:#ff7b72;font-weight:700>*</span> <span style=color:#a5d6ff>1024</span>):
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>directory <span style=color:#ff7b72;font-weight:700>=</span> directory
</span></span><span style=display:flex><span>        os<span style=color:#ff7b72;font-weight:700>.</span>makedirs(directory, exist_ok<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>memtable <span style=color:#ff7b72;font-weight:700>=</span> Memtable(memtable_size)
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>sstables <span style=color:#ff7b72;font-weight:700>=</span> []
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>_load_sstables()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>_load_sstables</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Load existing SSTables from disk.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> filename <span style=color:#ff7b72;font-weight:700>in</span> sorted(os<span style=color:#ff7b72;font-weight:700>.</span>listdir(self<span style=color:#ff7b72;font-weight:700>.</span>directory)):
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> filename<span style=color:#ff7b72;font-weight:700>.</span>endswith(<span style=color:#a5d6ff>&#39;.sst&#39;</span>):
</span></span><span style=display:flex><span>                path <span style=color:#ff7b72;font-weight:700>=</span> os<span style=color:#ff7b72;font-weight:700>.</span>path<span style=color:#ff7b72;font-weight:700>.</span>join(self<span style=color:#ff7b72;font-weight:700>.</span>directory, filename)
</span></span><span style=display:flex><span>                self<span style=color:#ff7b72;font-weight:700>.</span>sstables<span style=color:#ff7b72;font-weight:700>.</span>append(SSTable(path))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>put</span>(self, key: str, value: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Insert or update a key-value pair.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>put(key, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>is_full():
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>_flush()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>get</span>(self, key: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> Optional[str]:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Retrieve the value for a key.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Check memtable first (most recent)</span>
</span></span><span style=display:flex><span>        value <span style=color:#ff7b72;font-weight:700>=</span> self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>is</span> <span style=color:#ff7b72;font-weight:700>not</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span> <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>&#34;__TOMBSTONE__&#34;</span> <span style=color:#ff7b72>else</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Check SSTables from newest to oldest</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> sstable <span style=color:#ff7b72;font-weight:700>in</span> reversed(self<span style=color:#ff7b72;font-weight:700>.</span>sstables):
</span></span><span style=display:flex><span>            value <span style=color:#ff7b72;font-weight:700>=</span> sstable<span style=color:#ff7b72;font-weight:700>.</span>get(key)
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> value <span style=color:#ff7b72;font-weight:700>is</span> <span style=color:#ff7b72;font-weight:700>not</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>delete</span>(self, key: str) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Delete a key by writing a tombstone.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>delete(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>is_full():
</span></span><span style=display:flex><span>            self<span style=color:#ff7b72;font-weight:700>.</span>_flush()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>_flush</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Flush memtable to disk as an SSTable.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        timestamp <span style=color:#ff7b72;font-weight:700>=</span> len(self<span style=color:#ff7b72;font-weight:700>.</span>sstables)
</span></span><span style=display:flex><span>        path <span style=color:#ff7b72;font-weight:700>=</span> os<span style=color:#ff7b72;font-weight:700>.</span>path<span style=color:#ff7b72;font-weight:700>.</span>join(self<span style=color:#ff7b72;font-weight:700>.</span>directory, <span style=color:#79c0ff>f</span><span style=color:#a5d6ff>&#34;</span><span style=color:#a5d6ff>{</span>timestamp<span style=color:#a5d6ff>:</span><span style=color:#a5d6ff>08d</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>.sst&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sstable <span style=color:#ff7b72;font-weight:700>=</span> SSTable<span style=color:#ff7b72;font-weight:700>.</span>create(path, self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>items())
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>sstables<span style=color:#ff7b72;font-weight:700>.</span>append(sstable)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>memtable <span style=color:#ff7b72;font-weight:700>=</span> Memtable(self<span style=color:#ff7b72;font-weight:700>.</span>memtable<span style=color:#ff7b72;font-weight:700>.</span>max_size)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>def</span> <span style=color:#d2a8ff;font-weight:700>compact</span>(self) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#79c0ff>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#a5d6ff>&#34;&#34;&#34;Merge all SSTables into one (simple full compaction).&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> len(self<span style=color:#ff7b72;font-weight:700>.</span>sstables) <span style=color:#ff7b72;font-weight:700>&lt;=</span> <span style=color:#a5d6ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Merge all SSTables</span>
</span></span><span style=display:flex><span>        merged <span style=color:#ff7b72;font-weight:700>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> sstable <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>sstables:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>for</span> key, value <span style=color:#ff7b72;font-weight:700>in</span> sstable<span style=color:#ff7b72;font-weight:700>.</span>items():
</span></span><span style=display:flex><span>                merged[key] <span style=color:#ff7b72;font-weight:700>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Remove tombstones and sort</span>
</span></span><span style=display:flex><span>        items <span style=color:#ff7b72;font-weight:700>=</span> sorted(
</span></span><span style=display:flex><span>            ((k, v) <span style=color:#ff7b72>for</span> k, v <span style=color:#ff7b72;font-weight:700>in</span> merged<span style=color:#ff7b72;font-weight:700>.</span>items() <span style=color:#ff7b72>if</span> v <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>&#34;__TOMBSTONE__&#34;</span>),
</span></span><span style=display:flex><span>            key<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#ff7b72>lambda</span> x: x[<span style=color:#a5d6ff>0</span>]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Write new SSTable</span>
</span></span><span style=display:flex><span>        new_path <span style=color:#ff7b72;font-weight:700>=</span> os<span style=color:#ff7b72;font-weight:700>.</span>path<span style=color:#ff7b72;font-weight:700>.</span>join(self<span style=color:#ff7b72;font-weight:700>.</span>directory, <span style=color:#a5d6ff>&#34;compacted.sst&#34;</span>)
</span></span><span style=display:flex><span>        new_sstable <span style=color:#ff7b72;font-weight:700>=</span> SSTable<span style=color:#ff7b72;font-weight:700>.</span>create(new_path, iter(items))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Remove old SSTables</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> sstable <span style=color:#ff7b72;font-weight:700>in</span> self<span style=color:#ff7b72;font-weight:700>.</span>sstables:
</span></span><span style=display:flex><span>            os<span style=color:#ff7b72;font-weight:700>.</span>remove(sstable<span style=color:#ff7b72;font-weight:700>.</span>path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic># Rename compacted file</span>
</span></span><span style=display:flex><span>        final_path <span style=color:#ff7b72;font-weight:700>=</span> os<span style=color:#ff7b72;font-weight:700>.</span>path<span style=color:#ff7b72;font-weight:700>.</span>join(self<span style=color:#ff7b72;font-weight:700>.</span>directory, <span style=color:#a5d6ff>&#34;00000000.sst&#34;</span>)
</span></span><span style=display:flex><span>        os<span style=color:#ff7b72;font-weight:700>.</span>rename(new_path, final_path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff7b72;font-weight:700>.</span>sstables <span style=color:#ff7b72;font-weight:700>=</span> [SSTable(final_path)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Usage example</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>if</span> <span style=color:#79c0ff>__name__</span> <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    db <span style=color:#ff7b72;font-weight:700>=</span> SimpleLSM(<span style=color:#a5d6ff>&#34;/tmp/simple_lsm&#34;</span>, memtable_size<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>1024</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Write some data</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>in</span> range(<span style=color:#a5d6ff>1000</span>):
</span></span><span style=display:flex><span>        db<span style=color:#ff7b72;font-weight:700>.</span>put(<span style=color:#79c0ff>f</span><span style=color:#a5d6ff>&#34;key</span><span style=color:#a5d6ff>{</span>i<span style=color:#a5d6ff>:</span><span style=color:#a5d6ff>04d</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>, <span style=color:#79c0ff>f</span><span style=color:#a5d6ff>&#34;value</span><span style=color:#a5d6ff>{</span>i<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Read it back</span>
</span></span><span style=display:flex><span>    print(db<span style=color:#ff7b72;font-weight:700>.</span>get(<span style=color:#a5d6ff>&#34;key0042&#34;</span>))  <span style=color:#8b949e;font-style:italic># value42</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Delete a key</span>
</span></span><span style=display:flex><span>    db<span style=color:#ff7b72;font-weight:700>.</span>delete(<span style=color:#a5d6ff>&#34;key0042&#34;</span>)
</span></span><span style=display:flex><span>    print(db<span style=color:#ff7b72;font-weight:700>.</span>get(<span style=color:#a5d6ff>&#34;key0042&#34;</span>))  <span style=color:#8b949e;font-style:italic># None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic># Compact</span>
</span></span><span style=display:flex><span>    db<span style=color:#ff7b72;font-weight:700>.</span>compact()
</span></span></code></pre></div><p>This implementation demonstrates the core concepts while being readable. Production systems add:</p><ul><li>Write-ahead logging for durability</li><li>Bloom filters for faster negative lookups</li><li>Block-based storage with compression</li><li>Concurrent access support</li><li>Leveled compaction with size thresholds</li></ul><h2 id="13-summary">13. Summary</h2><p>B-Trees and LSM-Trees represent two fundamental approaches to the storage engine problem:</p><p><strong>B-Trees:</strong></p><ul><li>Optimized for reads with O(log n) guaranteed</li><li>In-place updates with write-ahead logging</li><li>Consistent latency, complex concurrency</li><li>Best for read-heavy OLTP workloads</li></ul><p><strong>LSM-Trees:</strong></p><ul><li>Optimized for writes with sequential I/O</li><li>Immutable SSTables with background compaction</li><li>Higher write throughput, variable latency</li><li>Best for write-heavy and time-series workloads</li></ul><p>Key insights:</p><ol><li><strong>There is no free lunch:</strong> Every optimization trades off something else</li><li><strong>Measure your workload:</strong> Synthetic benchmarks lie; profile production traffic</li><li><strong>Hybrid approaches exist:</strong> Bw-Tree, Bε-Trees, and others blend the best of both</li><li><strong>Tuning matters:</strong> Default configurations rarely match your specific needs</li><li><strong>The right choice can change:</strong> As your workload evolves, re-evaluate</li></ol><p>Understanding these data structures is foundational for anyone working with databases. Whether you&rsquo;re choosing a database, tuning performance, or building storage systems, this knowledge transforms how you think about data persistence.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/systems/>systems</a>, <a href=/categories/databases/>databases</a></div><div>Tags:
<a href=/tags/databases/>#databases</a>, <a href=/tags/storage-engines/>#storage-engines</a>, <a href=/tags/b-trees/>#b-trees</a>, <a href=/tags/lsm-trees/>#lsm-trees</a>, <a href=/tags/data-structures/>#data-structures</a>, <a href=/tags/performance/>#performance</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>