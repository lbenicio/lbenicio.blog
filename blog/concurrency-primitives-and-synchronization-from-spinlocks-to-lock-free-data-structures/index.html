<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>Concurrency Primitives and Synchronization: From Spinlocks to Lock-Free Data Structures · Leonardo Benicio</title><meta name=description content="A comprehensive exploration of concurrent programming fundamentals, covering mutexes, spinlocks, semaphores, condition variables, memory ordering, and lock-free programming techniques that enable safe parallel execution."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/concurrency-primitives-and-synchronization-from-spinlocks-to-lock-free-data-structures/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="Concurrency Primitives and Synchronization: From Spinlocks to Lock-Free Data Structures · Leonardo Benicio"><meta property="og:description" content="A comprehensive exploration of concurrent programming fundamentals, covering mutexes, spinlocks, semaphores, condition variables, memory ordering, and lock-free programming techniques that enable safe parallel execution."><meta property="og:url" content="https://blog.lbenicio.dev/blog/concurrency-primitives-and-synchronization-from-spinlocks-to-lock-free-data-structures/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/concurrency-primitives-locks-synchronization.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Concurrency Primitives and Synchronization: From Spinlocks to Lock-Free Data Structures · Leonardo Benicio"><meta name=twitter:description content="A comprehensive exploration of concurrent programming fundamentals, covering mutexes, spinlocks, semaphores, condition variables, memory ordering, and lock-free programming techniques that enable safe parallel execution."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/concurrency-primitives-and-synchronization-from-spinlocks-to-lock-free-data-structures/","name":"Concurrency Primitives and Synchronization From Spinlocks to Lock Free Data Structures","position":3}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Concurrency Primitives and Synchronization From Spinlocks to Lock Free Data Structures</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">Concurrency Primitives and Synchronization From Spinlocks to Lock Free Data Structures</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">Concurrency Primitives and Synchronization: From Spinlocks to Lock-Free Data Structures</h1><div class="c277478 c3ecea6 c8fb24a">2024-03-15
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/concurrency-primitives-locks-synchronization.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">A comprehensive exploration of concurrent programming fundamentals, covering mutexes, spinlocks, semaphores, condition variables, memory ordering, and lock-free programming techniques that enable safe parallel execution.</p></header><div class="content"><p>Concurrent programming transforms sequential code into parallel execution, unlocking the power of modern multicore processors. But with parallelism comes the challenge of coordinating access to shared resources. Race conditions lurk in code that appears correct, and subtle bugs emerge only under specific timing conditions. Understanding synchronization primitives from the hardware level up through high-level abstractions provides the foundation for writing correct, efficient concurrent programs.</p><h2 id="1-the-concurrency-challenge">1. The Concurrency Challenge</h2><p>Why synchronization matters and what problems it solves.</p><h3 id="11-race-conditions">1.1 Race Conditions</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>The fundamental problem with shared mutable state:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Two threads incrementing a counter:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Initial: counter = 0                                   │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Thread A              Thread B                         │
</span></span><span style=display:flex><span>│  ─────────             ─────────                        │
</span></span><span style=display:flex><span>│  read counter (0)                                       │
</span></span><span style=display:flex><span>│                        read counter (0)                 │
</span></span><span style=display:flex><span>│  add 1 → 1                                             │
</span></span><span style=display:flex><span>│                        add 1 → 1                        │
</span></span><span style=display:flex><span>│  write counter (1)                                      │
</span></span><span style=display:flex><span>│                        write counter (1)                │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Final: counter = 1  (should be 2!)                    │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The increment operation (counter++) is not atomic:
</span></span><span style=display:flex><span>1. Load value from memory
</span></span><span style=display:flex><span>2. Add one to value
</span></span><span style=display:flex><span>3. Store result to memory
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Any interleaving of these steps between threads causes bugs.
</span></span></code></pre></div><h3 id="12-critical-sections">1.2 Critical Sections</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Protecting shared resources:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Critical section: Code that accesses shared resources │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Non-critical section (thread-local work)           │
</span></span><span style=display:flex><span>│  prepare_data();                                       │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Enter critical section                             │
</span></span><span style=display:flex><span>│  lock(mutex);                                          │
</span></span><span style=display:flex><span>│  ┌─────────────────────────────────────────┐           │
</span></span><span style=display:flex><span>│  │  shared_counter++;                       │ Critical │
</span></span><span style=display:flex><span>│  │  shared_list.append(item);               │ Section  │
</span></span><span style=display:flex><span>│  └─────────────────────────────────────────┘           │
</span></span><span style=display:flex><span>│  unlock(mutex);                                        │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Non-critical section                               │
</span></span><span style=display:flex><span>│  process_results();                                    │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Goals:
</span></span><span style=display:flex><span>- Mutual exclusion: Only one thread in critical section
</span></span><span style=display:flex><span>- Progress: If no thread in CS, one waiting thread can enter
</span></span><span style=display:flex><span>- Bounded waiting: No thread waits forever
</span></span><span style=display:flex><span>- Performance: Minimize time spent in synchronization
</span></span></code></pre></div><h3 id="13-atomicity-levels">1.3 Atomicity Levels</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Different guarantees for different operations:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Level 1: Single memory access
</span></span><span style=display:flex><span>- Reading/writing aligned word is atomic on most architectures
</span></span><span style=display:flex><span>- int x = 5; // Atomic if x is aligned
</span></span><span style=display:flex><span>- But: No ordering guarantees with other operations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Level 2: Read-modify-write (RMW)
</span></span><span style=display:flex><span>- Atomic increment, compare-and-swap, etc.
</span></span><span style=display:flex><span>- Hardware provides special instructions
</span></span><span style=display:flex><span>- x.fetch_add(1); // Atomic increment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Level 3: Multiple operations
</span></span><span style=display:flex><span>- Update multiple variables atomically
</span></span><span style=display:flex><span>- Requires explicit synchronization
</span></span><span style=display:flex><span>- transfer(a, b, amount); // Needs lock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Level 4: Transactions
</span></span><span style=display:flex><span>- Arbitrary code executed atomically
</span></span><span style=display:flex><span>- Database transactions, software transactional memory
</span></span><span style=display:flex><span>- Most complex, highest overhead
</span></span></code></pre></div><h2 id="2-hardware-foundations">2. Hardware Foundations</h2><p>The atomic operations that make synchronization possible.</p><h3 id="21-atomic-instructions">2.1 Atomic Instructions</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>CPU provides atomic read-modify-write instructions:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Compare-And-Swap (CAS):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Atomic: if *addr == expected, set *addr = desired  │
</span></span><span style=display:flex><span>│  bool CAS(int *addr, int expected, int desired) {      │
</span></span><span style=display:flex><span>│      // Hardware ensures atomicity                     │
</span></span><span style=display:flex><span>│      if (*addr == expected) {                          │
</span></span><span style=display:flex><span>│          *addr = desired;                              │
</span></span><span style=display:flex><span>│          return true;                                  │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│      return false;                                     │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  x86: CMPXCHG instruction                              │
</span></span><span style=display:flex><span>│  ARM: LDREX/STREX (load-link/store-conditional)        │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fetch-And-Add:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Atomic: return old value, add to memory            │
</span></span><span style=display:flex><span>│  int fetch_add(int *addr, int value) {                 │
</span></span><span style=display:flex><span>│      int old = *addr;                                  │
</span></span><span style=display:flex><span>│      *addr = old + value;                              │
</span></span><span style=display:flex><span>│      return old;                                       │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  x86: LOCK XADD instruction                            │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Test-And-Set:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Atomic: set to 1, return previous value            │
</span></span><span style=display:flex><span>│  int test_and_set(int *addr) {                         │
</span></span><span style=display:flex><span>│      int old = *addr;                                  │
</span></span><span style=display:flex><span>│      *addr = 1;                                        │
</span></span><span style=display:flex><span>│      return old;                                       │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  x86: LOCK XCHG instruction                            │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="22-memory-barriers">2.2 Memory Barriers</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>CPUs reorder memory operations for performance:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Without barriers:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Thread A                // Thread B                 │
</span></span><span style=display:flex><span>│  data = 42;                 while (!ready);            │
</span></span><span style=display:flex><span>│  ready = true;              print(data);               │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Problem: CPU might reorder ready = true before data!  │
</span></span><span style=display:flex><span>│  Thread B could see ready=true but data=0              │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Memory barrier types:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Load barrier (acquire):
</span></span><span style=display:flex><span>- All loads after barrier see effects of loads before barrier
</span></span><span style=display:flex><span>- Prevents load-load reordering
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Store barrier (release):
</span></span><span style=display:flex><span>- All stores before barrier complete before stores after
</span></span><span style=display:flex><span>- Prevents store-store reordering
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Full barrier:
</span></span><span style=display:flex><span>- Combines load and store barriers
</span></span><span style=display:flex><span>- Most expensive, strongest guarantee
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x86 example:
</span></span><span style=display:flex><span>// Store barrier
</span></span><span style=display:flex><span>_mm_sfence();  // All prior stores complete
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Load barrier
</span></span><span style=display:flex><span>_mm_lfence();  // All prior loads complete
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Full barrier
</span></span><span style=display:flex><span>_mm_mfence();  // All prior memory ops complete
</span></span><span style=display:flex><span>__sync_synchronize();  // GCC built-in
</span></span></code></pre></div><h3 id="23-cache-coherence-effects">2.3 Cache Coherence Effects</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Atomic operations interact with cache coherence:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CAS on cached line:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  1. Acquire exclusive ownership of cache line (MESI)   │
</span></span><span style=display:flex><span>│  2. Perform atomic operation                           │
</span></span><span style=display:flex><span>│  3. Other cores see invalidation                       │
</span></span><span style=display:flex><span>│  4. They must re-fetch line to access                  │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Cost: 50-100+ cycles for cross-core communication    │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contention impact:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Threads    │ Uncontended CAS │ Contended CAS          │
</span></span><span style=display:flex><span>│  ───────────┼─────────────────┼────────────────────────│
</span></span><span style=display:flex><span>│      1      │     10 ns       │    N/A                 │
</span></span><span style=display:flex><span>│      2      │     10 ns       │    50 ns               │
</span></span><span style=display:flex><span>│      4      │     10 ns       │   150 ns               │
</span></span><span style=display:flex><span>│      8      │     10 ns       │   400 ns               │
</span></span><span style=display:flex><span>│     16      │     10 ns       │  1000+ ns              │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cache line bouncing:
</span></span><span style=display:flex><span>- High contention = line constantly moving between cores
</span></span><span style=display:flex><span>- Each CAS pays full coherence penalty
</span></span><span style=display:flex><span>- Solution: Reduce contention, use local operations
</span></span></code></pre></div><h2 id="3-spinlocks">3. Spinlocks</h2><p>The simplest synchronization primitive.</p><h3 id="31-basic-spinlock">3.1 Basic Spinlock</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Simplest spinlock using test-and-set
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>volatile</span> <span style=color:#ff7b72>int</span> locked;
</span></span><span style=display:flex><span>} <span style=color:#ff7b72>spinlock_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>spin_lock</span>(<span style=color:#ff7b72>spinlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>lock) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (<span style=color:#d2a8ff;font-weight:700>__sync_lock_test_and_set</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock<span style=color:#ff7b72;font-weight:700>-&gt;</span>locked, <span style=color:#a5d6ff>1</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Spin until we acquire the lock
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>spin_unlock</span>(<span style=color:#ff7b72>spinlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>lock) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>__sync_lock_release</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock<span style=color:#ff7b72;font-weight:700>-&gt;</span>locked);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Usage:
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>spinlock_t</span> lock <span style=color:#ff7b72;font-weight:700>=</span> {<span style=color:#a5d6ff>0</span>};
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>spin_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Critical section
</span></span></span><span style=display:flex><span>shared_counter<span style=color:#ff7b72;font-weight:700>++</span>;
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>spin_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock);
</span></span></code></pre></div><h3 id="32-test-and-test-and-set">3.2 Test-and-Test-and-Set</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Problem with basic spinlock: Constant cache line bouncing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Every test_and_set acquires line exclusively, even while spinning.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solution: Test-and-Test-and-Set (TTAS)
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  void spin_lock_ttas(spinlock_t *lock) {               │
</span></span><span style=display:flex><span>│      while (1) {                                       │
</span></span><span style=display:flex><span>│          // Spin on local cache (read-only)            │
</span></span><span style=display:flex><span>│          while (lock-&gt;locked) {                        │
</span></span><span style=display:flex><span>│              // No bus traffic while spinning          │
</span></span><span style=display:flex><span>│              cpu_relax();  // Hint: we&#39;re spinning    │
</span></span><span style=display:flex><span>│          }                                             │
</span></span><span style=display:flex><span>│          // Try to acquire                             │
</span></span><span style=display:flex><span>│          if (!__sync_lock_test_and_set(&amp;lock-&gt;locked, 1))│
</span></span><span style=display:flex><span>│              return;  // Got the lock!                 │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance difference:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Threads │ TAS spinlock │ TTAS spinlock                │
</span></span><span style=display:flex><span>│  ────────┼──────────────┼────────────────────────────  │
</span></span><span style=display:flex><span>│     4    │   2.5M ops/s │   8M ops/s                   │
</span></span><span style=display:flex><span>│     8    │   800K ops/s │   5M ops/s                   │
</span></span><span style=display:flex><span>│    16    │   200K ops/s │   3M ops/s                   │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="33-ticket-lock">3.3 Ticket Lock</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Problem: Basic spinlocks don&#39;t guarantee fairness
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread might wait forever while others repeatedly acquire lock.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Ticket lock provides FIFO ordering:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  typedef struct {                                       │
</span></span><span style=display:flex><span>│      volatile unsigned int next_ticket;                │
</span></span><span style=display:flex><span>│      volatile unsigned int now_serving;                │
</span></span><span style=display:flex><span>│  } ticket_lock_t;                                      │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void ticket_lock(ticket_lock_t *lock) {               │
</span></span><span style=display:flex><span>│      // Get my ticket (atomic increment)              │
</span></span><span style=display:flex><span>│      unsigned int my_ticket =                          │
</span></span><span style=display:flex><span>│          __sync_fetch_and_add(&amp;lock-&gt;next_ticket, 1);  │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│      // Wait until my number is called                 │
</span></span><span style=display:flex><span>│      while (lock-&gt;now_serving != my_ticket) {          │
</span></span><span style=display:flex><span>│          cpu_relax();                                  │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void ticket_unlock(ticket_lock_t *lock) {             │
</span></span><span style=display:flex><span>│      // Call next number                               │
</span></span><span style=display:flex><span>│      lock-&gt;now_serving++;                              │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Visualization:
</span></span><span style=display:flex><span>next_ticket: 5  (next thread gets ticket 5)
</span></span><span style=display:flex><span>now_serving: 3  (currently serving ticket 3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads waiting: [3:running] [4:spinning] [5:spinning]...
</span></span></code></pre></div><h3 id="34-when-to-use-spinlocks">3.4 When to Use Spinlocks</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Spinlocks are appropriate when:
</span></span><span style=display:flex><span>✓ Critical section is very short (&lt; 1 microsecond)
</span></span><span style=display:flex><span>✓ Lock hold time is predictable
</span></span><span style=display:flex><span>✓ Thread won&#39;t be preempted while holding lock
</span></span><span style=display:flex><span>✓ Running on dedicated cores (no oversubscription)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Spinlocks are inappropriate when:
</span></span><span style=display:flex><span>✗ Critical section might block (I/O, allocation)
</span></span><span style=display:flex><span>✗ Hold time varies significantly
</span></span><span style=display:flex><span>✗ More threads than cores
</span></span><span style=display:flex><span>✗ Thread might be preempted (priority inversion)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CPU hint for spinning:
</span></span><span style=display:flex><span>// x86: PAUSE instruction
</span></span><span style=display:flex><span>// ARM: YIELD instruction
</span></span><span style=display:flex><span>// Reduces power, helps hyperthreading
</span></span><span style=display:flex><span>void cpu_relax() {
</span></span><span style=display:flex><span>    __asm__ __volatile__(&#34;pause&#34; ::: &#34;memory&#34;);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="4-mutexes-and-blocking-locks">4. Mutexes and Blocking Locks</h2><p>When spinning wastes resources.</p><h3 id="41-mutex-internals">4.1 Mutex Internals</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Mutex: Block thread instead of spinning
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Conceptual implementation:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  typedef struct {                                       │
</span></span><span style=display:flex><span>│      int locked;                                       │
</span></span><span style=display:flex><span>│      queue_t waiters;  // Threads waiting for lock     │
</span></span><span style=display:flex><span>│  } mutex_t;                                            │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void mutex_lock(mutex_t *m) {                         │
</span></span><span style=display:flex><span>│      if (!try_lock(&amp;m-&gt;locked)) {                      │
</span></span><span style=display:flex><span>│          // Add self to wait queue                     │
</span></span><span style=display:flex><span>│          enqueue(&amp;m-&gt;waiters, current_thread);         │
</span></span><span style=display:flex><span>│          // Block until woken                          │
</span></span><span style=display:flex><span>│          block_current_thread();                       │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void mutex_unlock(mutex_t *m) {                       │
</span></span><span style=display:flex><span>│      m-&gt;locked = 0;                                    │
</span></span><span style=display:flex><span>│      if (!empty(&amp;m-&gt;waiters)) {                        │
</span></span><span style=display:flex><span>│          thread_t *next = dequeue(&amp;m-&gt;waiters);        │
</span></span><span style=display:flex><span>│          wake_thread(next);                            │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Linux futex (Fast Userspace muTEX):
</span></span><span style=display:flex><span>- Uncontended case: No system call needed
</span></span><span style=display:flex><span>- Contended: System call to block/wake
</span></span><span style=display:flex><span>- Best of both worlds
</span></span></code></pre></div><h3 id="42-futex-details">4.2 Futex Details</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Linux futex-based mutex
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> state;  <span style=color:#8b949e;font-style:italic>// 0=unlocked, 1=locked-no-waiters, 2=locked-with-waiters
</span></span></span><span style=display:flex><span>} <span style=color:#ff7b72>futex_mutex_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>futex_lock</span>(<span style=color:#ff7b72>futex_mutex_t</span> <span style=color:#ff7b72;font-weight:700>*</span>m) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> c;
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Fast path: uncontended
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> ((c <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>__sync_val_compare_and_swap</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, <span style=color:#a5d6ff>0</span>, <span style=color:#a5d6ff>1</span>)) <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span>;  <span style=color:#8b949e;font-style:italic>// Got lock, no syscall needed
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Slow path: contended
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Mark as having waiters
</span></span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> (c <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>2</span> <span style=color:#ff7b72;font-weight:700>||</span> <span style=color:#d2a8ff;font-weight:700>__sync_val_compare_and_swap</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, <span style=color:#a5d6ff>1</span>, <span style=color:#a5d6ff>2</span>) <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-style:italic>// Block in kernel until state changes
</span></span></span><span style=display:flex><span>            <span style=color:#d2a8ff;font-weight:700>syscall</span>(SYS_futex, <span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, FUTEX_WAIT, <span style=color:#a5d6ff>2</span>, NULL, NULL, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#ff7b72>while</span> ((c <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>__sync_val_compare_and_swap</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, <span style=color:#a5d6ff>0</span>, <span style=color:#a5d6ff>2</span>)) <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>futex_unlock</span>(<span style=color:#ff7b72>futex_mutex_t</span> <span style=color:#ff7b72;font-weight:700>*</span>m) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Unlock
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>__sync_fetch_and_sub</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// There were waiters
</span></span></span><span style=display:flex><span>        m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>syscall</span>(SYS_futex, <span style=color:#ff7b72;font-weight:700>&amp;</span>m<span style=color:#ff7b72;font-weight:700>-&gt;</span>state, FUTEX_WAKE, <span style=color:#a5d6ff>1</span>, NULL, NULL, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="43-adaptive-mutexes">4.3 Adaptive Mutexes</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Hybrid approach: Spin briefly, then block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  void adaptive_lock(mutex_t *m) {                      │
</span></span><span style=display:flex><span>│      int spin_count = 0;                               │
</span></span><span style=display:flex><span>│      const int MAX_SPINS = 1000;                       │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│      while (!try_lock(m)) {                            │
</span></span><span style=display:flex><span>│          if (spin_count &lt; MAX_SPINS) {                 │
</span></span><span style=display:flex><span>│              // Owner is running? Spin a bit          │
</span></span><span style=display:flex><span>│              if (is_owner_running(m)) {                │
</span></span><span style=display:flex><span>│                  cpu_relax();                          │
</span></span><span style=display:flex><span>│                  spin_count++;                         │
</span></span><span style=display:flex><span>│                  continue;                             │
</span></span><span style=display:flex><span>│              }                                         │
</span></span><span style=display:flex><span>│          }                                             │
</span></span><span style=display:flex><span>│          // Spinning didn&#39;t help, block               │
</span></span><span style=display:flex><span>│          block_wait(m);                                │
</span></span><span style=display:flex><span>│          spin_count = 0;                               │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Why this works:
</span></span><span style=display:flex><span>- Short critical sections: Spinning avoids syscall overhead
</span></span><span style=display:flex><span>- Long critical sections: Blocking avoids wasting CPU
</span></span><span style=display:flex><span>- Owner preempted: Blocking is better than spinning
</span></span></code></pre></div><h3 id="44-priority-inheritance">4.4 Priority Inheritance</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Priority inversion problem:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Without priority inheritance:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Low priority thread L holds lock                      │
</span></span><span style=display:flex><span>│  High priority thread H waits for lock                 │
</span></span><span style=display:flex><span>│  Medium priority thread M preempts L                   │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Result: H waits for M (lower priority!) to finish    │
</span></span><span style=display:flex><span>│  This is priority inversion                            │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>With priority inheritance:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  L holds lock, H waits                                 │
</span></span><span style=display:flex><span>│  L temporarily inherits H&#39;s priority                   │
</span></span><span style=display:flex><span>│  M cannot preempt L                                    │
</span></span><span style=display:flex><span>│  L finishes, releases lock, priority returns to normal│
</span></span><span style=display:flex><span>│  H gets lock immediately                               │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Real-world: Mars Pathfinder (1997)
</span></span><span style=display:flex><span>- Priority inversion caused system resets
</span></span><span style=display:flex><span>- Fixed with priority inheritance
</span></span></code></pre></div><h2 id="5-reader-writer-locks">5. Reader-Writer Locks</h2><p>Optimizing for read-heavy workloads.</p><h3 id="51-basic-reader-writer-lock">5.1 Basic Reader-Writer Lock</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Allow multiple readers OR one writer:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  State transitions:                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  ┌─────────┐  read_lock   ┌─────────┐                  │
</span></span><span style=display:flex><span>│  │  Free   │ ───────────► │ Reading │                  │
</span></span><span style=display:flex><span>│  │         │ ◄─────────── │ (n &gt; 0) │                  │
</span></span><span style=display:flex><span>│  └────┬────┘  read_unlock └────┬────┘                  │
</span></span><span style=display:flex><span>│       │                        │                        │
</span></span><span style=display:flex><span>│       │write_lock              │ (blocked)             │
</span></span><span style=display:flex><span>│       ▼                        │                        │
</span></span><span style=display:flex><span>│  ┌─────────┐                   │                        │
</span></span><span style=display:flex><span>│  │ Writing │ ◄─────────────────┘ (when n = 0)          │
</span></span><span style=display:flex><span>│  │         │                                            │
</span></span><span style=display:flex><span>│  └─────────┘                                            │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Concurrent readers: ✓ Yes                             │
</span></span><span style=display:flex><span>│  Reader + Writer:    ✗ No                              │
</span></span><span style=display:flex><span>│  Writer + Writer:    ✗ No                              │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="52-implementation">5.2 Implementation</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> readers;        <span style=color:#8b949e;font-style:italic>// Number of active readers
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> writer;         <span style=color:#8b949e;font-style:italic>// Writer active flag
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> write_waiters;  <span style=color:#8b949e;font-style:italic>// Writers waiting
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>mutex_t</span> mutex;      <span style=color:#8b949e;font-style:italic>// Protects state
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>cond_t</span> read_ok;     <span style=color:#8b949e;font-style:italic>// Readers can proceed
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>cond_t</span> write_ok;    <span style=color:#8b949e;font-style:italic>// Writer can proceed
</span></span></span><span style=display:flex><span>} <span style=color:#ff7b72>rwlock_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>read_lock</span>(<span style=color:#ff7b72>rwlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>rw) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Wait if writer active or writers waiting (writer preference)
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>writer <span style=color:#ff7b72;font-weight:700>||</span> rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_waiters <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>cond_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>read_ok, <span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>readers<span style=color:#ff7b72;font-weight:700>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>read_unlock</span>(<span style=color:#ff7b72>rwlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>rw) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>readers<span style=color:#ff7b72;font-weight:700>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>readers <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>cond_signal</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_ok);  <span style=color:#8b949e;font-style:italic>// Wake waiting writer
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_lock</span>(<span style=color:#ff7b72>rwlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>rw) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_waiters<span style=color:#ff7b72;font-weight:700>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>readers <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span> <span style=color:#ff7b72;font-weight:700>||</span> rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>writer) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>cond_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_ok, <span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_waiters<span style=color:#ff7b72;font-weight:700>--</span>;
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>writer <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_unlock</span>(<span style=color:#ff7b72>rwlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>rw) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>writer <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>cond_broadcast</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>read_ok);  <span style=color:#8b949e;font-style:italic>// Wake all readers
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>cond_signal</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>write_ok);    <span style=color:#8b949e;font-style:italic>// Wake one writer
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>rw<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="53-scalability-issues">5.3 Scalability Issues</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Problem: Reader lock still causes contention
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Every read_lock/read_unlock modifies shared counter:
</span></span><span style=display:flex><span>- Cache line bounces between cores
</span></span><span style=display:flex><span>- Scales poorly with many readers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solutions:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Per-CPU reader counts:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  struct percpu_rwlock {                                │
</span></span><span style=display:flex><span>│      int reader_count[NUM_CPUS];  // Per-CPU counters  │
</span></span><span style=display:flex><span>│      int writer;                                       │
</span></span><span style=display:flex><span>│  };                                                    │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  read_lock: increment local CPU&#39;s counter (no sharing) │
</span></span><span style=display:flex><span>│  write_lock: Wait for ALL per-CPU counters to be 0    │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Seqlock (optimistic readers):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Readers don&#39;t acquire lock at all                     │
</span></span><span style=display:flex><span>│  Writers increment sequence number before/after        │
</span></span><span style=display:flex><span>│  Readers check: did sequence change during read?       │
</span></span><span style=display:flex><span>│  If so, retry                                          │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. RCU (Read-Copy-Update):
</span></span><span style=display:flex><span>- Readers are wait-free (no synchronization)
</span></span><span style=display:flex><span>- Writers create new version, wait for readers to finish
</span></span><span style=display:flex><span>- Covered in advanced section
</span></span></code></pre></div><h3 id="54-seqlock-implementation">5.4 Seqlock Implementation</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> sequence;  <span style=color:#8b949e;font-style:italic>// Even = unlocked, Odd = write in progress
</span></span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Protected data follows
</span></span></span><span style=display:flex><span>} <span style=color:#ff7b72>seqlock_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Writer side
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_seqlock</span>(<span style=color:#ff7b72>seqlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>sl) {
</span></span><span style=display:flex><span>    sl<span style=color:#ff7b72;font-weight:700>-&gt;</span>sequence<span style=color:#ff7b72;font-weight:700>++</span>;  <span style=color:#8b949e;font-style:italic>// Odd: write starting
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>__sync_synchronize</span>();  <span style=color:#8b949e;font-style:italic>// Memory barrier
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>write_sequnlock</span>(<span style=color:#ff7b72>seqlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>sl) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>__sync_synchronize</span>();  <span style=color:#8b949e;font-style:italic>// Memory barrier
</span></span></span><span style=display:flex><span>    sl<span style=color:#ff7b72;font-weight:700>-&gt;</span>sequence<span style=color:#ff7b72;font-weight:700>++</span>;  <span style=color:#8b949e;font-style:italic>// Even again: write complete
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Reader side (no lock!)
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>read_seqbegin</span>(<span style=color:#ff7b72>seqlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>sl) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> seq;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>do</span> {
</span></span><span style=display:flex><span>        seq <span style=color:#ff7b72;font-weight:700>=</span> sl<span style=color:#ff7b72;font-weight:700>-&gt;</span>sequence;
</span></span><span style=display:flex><span>    } <span style=color:#ff7b72>while</span> (seq <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#a5d6ff>1</span>);  <span style=color:#8b949e;font-style:italic>// Wait if write in progress
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>__sync_synchronize</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> seq;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>read_seqretry</span>(<span style=color:#ff7b72>seqlock_t</span> <span style=color:#ff7b72;font-weight:700>*</span>sl, <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> seq) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>__sync_synchronize</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> sl<span style=color:#ff7b72;font-weight:700>-&gt;</span>sequence <span style=color:#ff7b72;font-weight:700>!=</span> seq;  <span style=color:#8b949e;font-style:italic>// True if must retry
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Usage:
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> seq;
</span></span><span style=display:flex><span><span style=color:#ff7b72>do</span> {
</span></span><span style=display:flex><span>    seq <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read_seqbegin</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Read shared data (might be inconsistent)
</span></span></span><span style=display:flex><span>    value <span style=color:#ff7b72;font-weight:700>=</span> shared_data;
</span></span><span style=display:flex><span>} <span style=color:#ff7b72>while</span> (<span style=color:#d2a8ff;font-weight:700>read_seqretry</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>lock, seq));
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Now value is consistent
</span></span></span></code></pre></div><h2 id="6-condition-variables">6. Condition Variables</h2><p>Waiting for arbitrary conditions.</p><h3 id="61-condition-variable-basics">6.1 Condition Variable Basics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Wait for a condition to become true:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Producer-Consumer with condition variable:            │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Producer:                                             │
</span></span><span style=display:flex><span>│  mutex_lock(&amp;m);                                       │
</span></span><span style=display:flex><span>│  buffer[tail++] = item;                                │
</span></span><span style=display:flex><span>│  cond_signal(&amp;not_empty);  // Wake one consumer        │
</span></span><span style=display:flex><span>│  mutex_unlock(&amp;m);                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Consumer:                                             │
</span></span><span style=display:flex><span>│  mutex_lock(&amp;m);                                       │
</span></span><span style=display:flex><span>│  while (is_empty()) {  // While, not if!              │
</span></span><span style=display:flex><span>│      cond_wait(&amp;not_empty, &amp;m);  // Releases mutex     │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│  item = buffer[head++];                                │
</span></span><span style=display:flex><span>│  mutex_unlock(&amp;m);                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Why &#34;while&#34; not &#34;if&#34;?
</span></span><span style=display:flex><span>- Spurious wakeups (pthread allows them)
</span></span><span style=display:flex><span>- Multiple waiters: Only one gets the item
</span></span><span style=display:flex><span>- Condition might change before we reacquire mutex
</span></span></code></pre></div><h3 id="62-wait-mechanics">6.2 Wait Mechanics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>cond_wait() does three things atomically:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Release the mutex
</span></span><span style=display:flex><span>2. Add thread to condition&#39;s wait queue
</span></span><span style=display:flex><span>3. Block thread
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // This would be wrong (race condition):              │
</span></span><span style=display:flex><span>│  mutex_unlock(&amp;m);   // ← Another thread could signal │
</span></span><span style=display:flex><span>│  wait(&amp;cond);        //   here and we&#39;d miss it!      │
</span></span><span style=display:flex><span>│  mutex_lock(&amp;m);                                       │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // cond_wait does this atomically:                    │
</span></span><span style=display:flex><span>│  cond_wait(&amp;cond, &amp;m) {                                │
</span></span><span style=display:flex><span>│      atomically {                                      │
</span></span><span style=display:flex><span>│          unlock(m);                                    │
</span></span><span style=display:flex><span>│          add_to_waitqueue(cond, self);                 │
</span></span><span style=display:flex><span>│          block();                                      │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│      // When woken:                                    │
</span></span><span style=display:flex><span>│      lock(m);  // Reacquire before returning          │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="63-signal-vs-broadcast">6.3 Signal vs Broadcast</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>cond_signal(): Wake ONE waiting thread
</span></span><span style=display:flex><span>cond_broadcast(): Wake ALL waiting threads
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When to use signal:
</span></span><span style=display:flex><span>- Any waiter can handle the condition
</span></span><span style=display:flex><span>- Exactly one thread should proceed
</span></span><span style=display:flex><span>- Producer-consumer with single item
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When to use broadcast:
</span></span><span style=display:flex><span>- Waiters have different predicates
</span></span><span style=display:flex><span>- State change affects multiple waiters
</span></span><span style=display:flex><span>- Shutdown notification
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Example needing broadcast:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Thread 1 waits for x &gt; 10                          │
</span></span><span style=display:flex><span>│  while (x &lt;= 10) cond_wait(&amp;c, &amp;m);                    │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Thread 2 waits for x &gt; 20                          │
</span></span><span style=display:flex><span>│  while (x &lt;= 20) cond_wait(&amp;c, &amp;m);                    │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Thread 3 sets x = 15                               │
</span></span><span style=display:flex><span>│  x = 15;                                               │
</span></span><span style=display:flex><span>│  cond_signal(&amp;c);  // Wrong! Might wake Thread 2      │
</span></span><span style=display:flex><span>│  cond_broadcast(&amp;c);  // Correct: both check condition│
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="64-bounded-buffer-example">6.4 Bounded Buffer Example</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> buffer[SIZE];
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> head, tail, count;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>mutex_t</span> mutex;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>cond_t</span> not_full;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>cond_t</span> not_empty;
</span></span><span style=display:flex><span>} <span style=color:#ff7b72>bounded_buffer_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>produce</span>(<span style=color:#ff7b72>bounded_buffer_t</span> <span style=color:#ff7b72;font-weight:700>*</span>bb, <span style=color:#ff7b72>int</span> item) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Wait while buffer is full
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>count <span style=color:#ff7b72;font-weight:700>==</span> SIZE) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>cond_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>not_full, <span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Add item
</span></span></span><span style=display:flex><span>    bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>buffer[bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>tail] <span style=color:#ff7b72;font-weight:700>=</span> item;
</span></span><span style=display:flex><span>    bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>tail <span style=color:#ff7b72;font-weight:700>=</span> (bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>tail <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>%</span> SIZE;
</span></span><span style=display:flex><span>    bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>count<span style=color:#ff7b72;font-weight:700>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Signal: buffer is no longer empty
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>cond_signal</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>not_empty);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>consume</span>(<span style=color:#ff7b72>bounded_buffer_t</span> <span style=color:#ff7b72;font-weight:700>*</span>bb) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_lock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Wait while buffer is empty
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>while</span> (bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>count <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>cond_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>not_empty, <span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Remove item
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> item <span style=color:#ff7b72;font-weight:700>=</span> bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>buffer[bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>head];
</span></span><span style=display:flex><span>    bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>head <span style=color:#ff7b72;font-weight:700>=</span> (bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>head <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>%</span> SIZE;
</span></span><span style=display:flex><span>    bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>count<span style=color:#ff7b72;font-weight:700>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Signal: buffer is no longer full
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>cond_signal</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>not_full);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>mutex_unlock</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>bb<span style=color:#ff7b72;font-weight:700>-&gt;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> item;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="7-semaphores">7. Semaphores</h2><p>Generalized synchronization counters.</p><h3 id="71-semaphore-operations">7.1 Semaphore Operations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Semaphore: Integer counter with atomic operations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>P (wait/down): Decrement, block if would go negative
</span></span><span style=display:flex><span>V (signal/up): Increment, wake one waiter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  void sem_wait(sem_t *s) {                             │
</span></span><span style=display:flex><span>│      while (s-&gt;count &lt;= 0) {                           │
</span></span><span style=display:flex><span>│          block();                                      │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│      s-&gt;count--;  // Atomic with check                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void sem_post(sem_t *s) {                             │
</span></span><span style=display:flex><span>│      s-&gt;count++;                                       │
</span></span><span style=display:flex><span>│      if (waiters_exist()) {                            │
</span></span><span style=display:flex><span>│          wake_one();                                   │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Types:
</span></span><span style=display:flex><span>- Binary semaphore (count 0 or 1): Like mutex
</span></span><span style=display:flex><span>- Counting semaphore: Track multiple resources
</span></span></code></pre></div><h3 id="72-common-patterns">7.2 Common Patterns</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>1. Mutual exclusion (binary semaphore):
</span></span><span style=display:flex><span>sem_t mutex = 1;
</span></span><span style=display:flex><span>sem_wait(&amp;mutex);  // Enter critical section
</span></span><span style=display:flex><span>// Critical section
</span></span><span style=display:flex><span>sem_post(&amp;mutex);  // Leave critical section
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Resource pool:
</span></span><span style=display:flex><span>sem_t pool = N;  // N resources available
</span></span><span style=display:flex><span>sem_wait(&amp;pool);  // Get a resource
</span></span><span style=display:flex><span>use_resource();
</span></span><span style=display:flex><span>sem_post(&amp;pool);  // Return resource
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Signaling between threads:
</span></span><span style=display:flex><span>sem_t done = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread A:                Thread B:
</span></span><span style=display:flex><span>do_work();               sem_wait(&amp;done);
</span></span><span style=display:flex><span>sem_post(&amp;done);         use_result();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Barrier (rendezvous):
</span></span><span style=display:flex><span>sem_t barrier1 = 0, barrier2 = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread A:                Thread B:
</span></span><span style=display:flex><span>phase1_A();              phase1_B();
</span></span><span style=display:flex><span>sem_post(&amp;barrier1);     sem_post(&amp;barrier2);
</span></span><span style=display:flex><span>sem_wait(&amp;barrier2);     sem_wait(&amp;barrier1);
</span></span><span style=display:flex><span>phase2_A();              phase2_B();
</span></span></code></pre></div><h3 id="73-producer-consumer-with-semaphores">7.3 Producer-Consumer with Semaphores</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#define BUFFER_SIZE 10
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> buffer[BUFFER_SIZE];
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> in <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>, out <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>sem_t</span> empty;  <span style=color:#8b949e;font-style:italic>// Count of empty slots
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>sem_t</span> full;   <span style=color:#8b949e;font-style:italic>// Count of filled slots
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>sem_t</span> mutex;  <span style=color:#8b949e;font-style:italic>// Mutual exclusion
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_init</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>empty, BUFFER_SIZE);  <span style=color:#8b949e;font-style:italic>// All slots empty
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_init</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>full, <span style=color:#a5d6ff>0</span>);             <span style=color:#8b949e;font-style:italic>// No items yet
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_init</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>mutex, <span style=color:#a5d6ff>1</span>);            <span style=color:#8b949e;font-style:italic>// Binary semaphore
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>producer</span>(<span style=color:#ff7b72>int</span> item) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>empty);     <span style=color:#8b949e;font-style:italic>// Wait for empty slot
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>mutex);     <span style=color:#8b949e;font-style:italic>// Enter critical section
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buffer[in] <span style=color:#ff7b72;font-weight:700>=</span> item;
</span></span><span style=display:flex><span>    in <span style=color:#ff7b72;font-weight:700>=</span> (in <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>%</span> BUFFER_SIZE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_post</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>mutex);     <span style=color:#8b949e;font-style:italic>// Leave critical section
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_post</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>full);      <span style=color:#8b949e;font-style:italic>// Signal: one more item
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>consumer</span>() {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>full);      <span style=color:#8b949e;font-style:italic>// Wait for item
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_wait</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>mutex);     <span style=color:#8b949e;font-style:italic>// Enter critical section
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> item <span style=color:#ff7b72;font-weight:700>=</span> buffer[out];
</span></span><span style=display:flex><span>    out <span style=color:#ff7b72;font-weight:700>=</span> (out <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>%</span> BUFFER_SIZE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_post</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>mutex);     <span style=color:#8b949e;font-style:italic>// Leave critical section
</span></span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>sem_post</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>empty);     <span style=color:#8b949e;font-style:italic>// Signal: one more empty slot
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> item;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id="74-semaphores-vs-condition-variables">7.4 Semaphores vs Condition Variables</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Semaphores:
</span></span><span style=display:flex><span>✓ Simpler mental model (just a counter)
</span></span><span style=display:flex><span>✓ Can signal before wait (signal is &#34;remembered&#34;)
</span></span><span style=display:flex><span>✓ Good for counting resources
</span></span><span style=display:flex><span>✗ No built-in mutex, must manage separately
</span></span><span style=display:flex><span>✗ Easy to misuse (forget to signal)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Condition Variables:
</span></span><span style=display:flex><span>✓ Paired with mutex (clearer ownership)
</span></span><span style=display:flex><span>✓ Flexible predicates (any condition)
</span></span><span style=display:flex><span>✓ broadcast() for multiple waiters
</span></span><span style=display:flex><span>✗ Spurious wakeups require while loop
</span></span><span style=display:flex><span>✗ Signal is &#34;lost&#34; if no one waiting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Generally prefer condition variables for new code.
</span></span><span style=display:flex><span>Semaphores still useful for specific patterns.
</span></span></code></pre></div><h2 id="8-memory-ordering-and-atomics">8. Memory Ordering and Atomics</h2><p>The foundation of lock-free programming.</p><h3 id="81-c11c11-memory-model">8.1 C++11/C11 Memory Model</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Memory orderings from weakest to strongest:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memory_order_relaxed:
</span></span><span style=display:flex><span>- Only guarantees atomicity
</span></span><span style=display:flex><span>- No ordering constraints
</span></span><span style=display:flex><span>- Fastest, but hardest to reason about
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memory_order_acquire:
</span></span><span style=display:flex><span>- All reads/writes after this see prior writes
</span></span><span style=display:flex><span>- Used for lock acquisition
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memory_order_release:
</span></span><span style=display:flex><span>- All prior reads/writes complete before this
</span></span><span style=display:flex><span>- Used for lock release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memory_order_acq_rel:
</span></span><span style=display:flex><span>- Combines acquire and release
</span></span><span style=display:flex><span>- For read-modify-write operations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memory_order_seq_cst:
</span></span><span style=display:flex><span>- Sequential consistency
</span></span><span style=display:flex><span>- All threads see same order
</span></span><span style=display:flex><span>- Slowest, but easiest to reason about
</span></span></code></pre></div><h3 id="82-atomic-operations">8.2 Atomic Operations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;atomic&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>&gt;</span> counter{<span style=color:#a5d6ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Relaxed: Just atomic, no ordering
</span></span></span><span style=display:flex><span>counter.store(<span style=color:#a5d6ff>5</span>, std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> x <span style=color:#ff7b72;font-weight:700>=</span> counter.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Acquire-release: Synchronization
</span></span></span><span style=display:flex><span>std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>bool</span><span style=color:#ff7b72;font-weight:700>&gt;</span> ready{false};
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Writer (release)
</span></span></span><span style=display:flex><span>data <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>42</span>;
</span></span><span style=display:flex><span>ready.store(true, std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_release);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Reader (acquire)
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>while</span> (<span style=color:#ff7b72;font-weight:700>!</span>ready.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acquire));
</span></span><span style=display:flex><span>assert(data <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>42</span>);  <span style=color:#8b949e;font-style:italic>// Guaranteed!
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Compare-and-swap
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> expected <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#ff7b72>bool</span> success <span style=color:#ff7b72;font-weight:700>=</span> counter.compare_exchange_strong(
</span></span><span style=display:flex><span>    expected, <span style=color:#a5d6ff>1</span>, std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acq_rel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Fetch-and-add
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> old <span style=color:#ff7b72;font-weight:700>=</span> counter.fetch_add(<span style=color:#a5d6ff>1</span>, std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed);
</span></span></code></pre></div><h3 id="83-the-happens-before-relationship">8.3 The Happens-Before Relationship</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Happens-before establishes ordering:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A happens-before B if:
</span></span><span style=display:flex><span>1. A is sequenced-before B in same thread
</span></span><span style=display:flex><span>2. A synchronizes-with B (release/acquire pair)
</span></span><span style=display:flex><span>3. A happens-before X and X happens-before B (transitive)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Example:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Thread 1:                Thread 2:                     │
</span></span><span style=display:flex><span>│  x = 1;           (a)                                   │
</span></span><span style=display:flex><span>│  y = 2;           (b)                                   │
</span></span><span style=display:flex><span>│  flag.store(true, (c)     while(!flag.load(acquire));(d)│
</span></span><span style=display:flex><span>│    release);              r1 = y;               (e)     │
</span></span><span style=display:flex><span>│                           r2 = x;               (f)     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  (a) sequenced-before (b) sequenced-before (c)         │
</span></span><span style=display:flex><span>│  (c) synchronizes-with (d)                             │
</span></span><span style=display:flex><span>│  (d) sequenced-before (e) sequenced-before (f)         │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Therefore: (a),(b) happen-before (e),(f)              │
</span></span><span style=display:flex><span>│  Result: r1 = 2, r2 = 1 guaranteed                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="84-common-pitfalls">8.4 Common Pitfalls</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>1. Data race (undefined behavior):
</span></span><span style=display:flex><span>int x = 0;
</span></span><span style=display:flex><span>// Thread 1: x = 1;
</span></span><span style=display:flex><span>// Thread 2: int y = x;
</span></span><span style=display:flex><span>// Not atomic, not synchronized = UB!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Relaxed ordering surprise:
</span></span><span style=display:flex><span>std::atomic&lt;int&gt; x{0}, y{0};
</span></span><span style=display:flex><span>// Thread 1: x.store(1, relaxed); y.store(1, relaxed);
</span></span><span style=display:flex><span>// Thread 2: r1 = y.load(relaxed); r2 = x.load(relaxed);
</span></span><span style=display:flex><span>// Possible: r1 = 1, r2 = 0 (reordering allowed!)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. ABA problem:
</span></span><span style=display:flex><span>// CAS sees expected value, assumes nothing changed
</span></span><span style=display:flex><span>// But: value changed A→B→A, state is different!
</span></span><span style=display:flex><span>// Solution: Use tagged pointers or hazard pointers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. False sharing:
</span></span><span style=display:flex><span>struct { std::atomic&lt;int&gt; a; std::atomic&lt;int&gt; b; };
</span></span><span style=display:flex><span>// a and b in same cache line = contention!
</span></span><span style=display:flex><span>// Solution: alignas(64) padding
</span></span></code></pre></div><h2 id="9-lock-free-data-structures">9. Lock-Free Data Structures</h2><p>Synchronization without locks.</p><h3 id="91-lock-free-stack">9.1 Lock-Free Stack</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LockFreeStack</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>struct</span> <span style=color:#f0883e;font-weight:700>Node</span> {
</span></span><span style=display:flex><span>        T data;
</span></span><span style=display:flex><span>        Node<span style=color:#ff7b72;font-weight:700>*</span> next;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span>Node<span style=color:#ff7b72;font-weight:700>*&gt;</span> head{<span style=color:#ff7b72>nullptr</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#ff7b72;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span> push(T value) {
</span></span><span style=display:flex><span>        Node<span style=color:#ff7b72;font-weight:700>*</span> new_node <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Node{value, <span style=color:#ff7b72>nullptr</span>};
</span></span><span style=display:flex><span>        new_node<span style=color:#ff7b72;font-weight:700>-&gt;</span>next <span style=color:#ff7b72;font-weight:700>=</span> head.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>// Keep trying until CAS succeeds
</span></span></span><span style=display:flex><span>        <span style=color:#ff7b72>while</span> (<span style=color:#ff7b72;font-weight:700>!</span>head.compare_exchange_weak(
</span></span><span style=display:flex><span>            new_node<span style=color:#ff7b72;font-weight:700>-&gt;</span>next, new_node,
</span></span><span style=display:flex><span>            std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_release,
</span></span><span style=display:flex><span>            std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>bool</span> <span style=color:#d2a8ff;font-weight:700>pop</span>(T<span style=color:#ff7b72;font-weight:700>&amp;</span> result) {
</span></span><span style=display:flex><span>        Node<span style=color:#ff7b72;font-weight:700>*</span> old_head <span style=color:#ff7b72;font-weight:700>=</span> head.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>while</span> (old_head <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#ff7b72>nullptr</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> (head.compare_exchange_weak(
</span></span><span style=display:flex><span>                old_head, old_head<span style=color:#ff7b72;font-weight:700>-&gt;</span>next,
</span></span><span style=display:flex><span>                std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acquire,
</span></span><span style=display:flex><span>                std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_relaxed)) {
</span></span><span style=display:flex><span>                result <span style=color:#ff7b72;font-weight:700>=</span> old_head<span style=color:#ff7b72;font-weight:700>-&gt;</span>data;
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>// Problem: When to delete old_head?
</span></span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>// Other threads might still reference it!
</span></span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> false;  <span style=color:#8b949e;font-style:italic>// Stack was empty
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id="92-memory-reclamation-problem">9.2 Memory Reclamation Problem</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>When can we free memory in lock-free structures?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Problem:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Thread A                    Thread B                   │
</span></span><span style=display:flex><span>│  old = head.load()                                      │
</span></span><span style=display:flex><span>│                              pop() removes old         │
</span></span><span style=display:flex><span>│                              delete old  ← WRONG!       │
</span></span><span style=display:flex><span>│  access old-&gt;next  ← CRASH!                            │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solutions:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Hazard pointers:
</span></span><span style=display:flex><span>- Each thread publishes pointers it&#39;s using
</span></span><span style=display:flex><span>- Before freeing, check no thread has hazard on it
</span></span><span style=display:flex><span>- Safe but adds overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Epoch-based reclamation:
</span></span><span style=display:flex><span>- Global epoch counter
</span></span><span style=display:flex><span>- Thread records current epoch when accessing
</span></span><span style=display:flex><span>- Free only when all threads moved past epoch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Reference counting:
</span></span><span style=display:flex><span>- Each node has atomic reference count
</span></span><span style=display:flex><span>- Increment before access, decrement after
</span></span><span style=display:flex><span>- Free when count reaches zero
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. RCU (Read-Copy-Update):
</span></span><span style=display:flex><span>- Readers never block
</span></span><span style=display:flex><span>- Writers wait for grace period
</span></span><span style=display:flex><span>- Linux kernel uses extensively
</span></span></code></pre></div><h3 id="93-lock-free-queue">9.3 Lock-Free Queue</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-cpp" data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>LockFreeQueue</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>struct</span> <span style=color:#f0883e;font-weight:700>Node</span> {
</span></span><span style=display:flex><span>        T data;
</span></span><span style=display:flex><span>        std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span>Node<span style=color:#ff7b72;font-weight:700>*&gt;</span> next{<span style=color:#ff7b72>nullptr</span>};
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span>Node<span style=color:#ff7b72;font-weight:700>*&gt;</span> head;
</span></span><span style=display:flex><span>    std<span style=color:#ff7b72;font-weight:700>::</span>atomic<span style=color:#ff7b72;font-weight:700>&lt;</span>Node<span style=color:#ff7b72;font-weight:700>*&gt;</span> tail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#ff7b72;font-weight:700>:</span>
</span></span><span style=display:flex><span>    LockFreeQueue() {
</span></span><span style=display:flex><span>        Node<span style=color:#ff7b72;font-weight:700>*</span> dummy <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Node{};
</span></span><span style=display:flex><span>        head.store(dummy);
</span></span><span style=display:flex><span>        tail.store(dummy);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>enqueue</span>(T value) {
</span></span><span style=display:flex><span>        Node<span style=color:#ff7b72;font-weight:700>*</span> new_node <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Node{value};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>while</span> (true) {
</span></span><span style=display:flex><span>            Node<span style=color:#ff7b72;font-weight:700>*</span> last <span style=color:#ff7b72;font-weight:700>=</span> tail.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acquire);
</span></span><span style=display:flex><span>            Node<span style=color:#ff7b72;font-weight:700>*</span> next <span style=color:#ff7b72;font-weight:700>=</span> last<span style=color:#ff7b72;font-weight:700>-&gt;</span>next.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acquire);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> (last <span style=color:#ff7b72;font-weight:700>==</span> tail.load(std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_acquire)) {
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> (next <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#ff7b72>nullptr</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#8b949e;font-style:italic>// Try to link new node
</span></span></span><span style=display:flex><span>                    <span style=color:#ff7b72>if</span> (last<span style=color:#ff7b72;font-weight:700>-&gt;</span>next.compare_exchange_weak(
</span></span><span style=display:flex><span>                            next, new_node,
</span></span><span style=display:flex><span>                            std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_release)) {
</span></span><span style=display:flex><span>                        <span style=color:#8b949e;font-style:italic>// Success, try to move tail
</span></span></span><span style=display:flex><span>                        tail.compare_exchange_weak(
</span></span><span style=display:flex><span>                            last, new_node,
</span></span><span style=display:flex><span>                            std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_release);
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#8b949e;font-style:italic>// Tail fell behind, help move it
</span></span></span><span style=display:flex><span>                    tail.compare_exchange_weak(
</span></span><span style=display:flex><span>                        last, next,
</span></span><span style=display:flex><span>                        std<span style=color:#ff7b72;font-weight:700>::</span>memory_order_release);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Dequeue similar but from head...
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id="94-when-to-use-lock-free">9.4 When to Use Lock-Free</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Lock-free advantages:
</span></span><span style=display:flex><span>✓ No deadlock possible
</span></span><span style=display:flex><span>✓ No priority inversion
</span></span><span style=display:flex><span>✓ Progress guarantee (system-wide)
</span></span><span style=display:flex><span>✓ Often better under high contention
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Lock-free disadvantages:
</span></span><span style=display:flex><span>✗ Much harder to implement correctly
</span></span><span style=display:flex><span>✗ Memory reclamation is tricky
</span></span><span style=display:flex><span>✗ May have worse single-thread performance
</span></span><span style=display:flex><span>✗ Debugging is extremely difficult
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use lock-free when:
</span></span><span style=display:flex><span>- High contention expected
</span></span><span style=display:flex><span>- Hard real-time requirements
</span></span><span style=display:flex><span>- Need to avoid priority inversion
</span></span><span style=display:flex><span>- Simple data structure (stack, queue)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use locks when:
</span></span><span style=display:flex><span>- Low contention
</span></span><span style=display:flex><span>- Complex operations
</span></span><span style=display:flex><span>- Easier maintenance preferred
</span></span><span style=display:flex><span>- Performance isn&#39;t extreme requirement
</span></span></code></pre></div><h3 id="95-read-copy-update-rcu">9.5 Read-Copy-Update (RCU)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>RCU: Optimized for read-heavy workloads in kernel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Core idea:
</span></span><span style=display:flex><span>- Readers access data without any synchronization
</span></span><span style=display:flex><span>- Writers create new version, atomically swap pointer
</span></span><span style=display:flex><span>- Old version freed after all readers finish
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Reading (no locks!):                                   │
</span></span><span style=display:flex><span>│  rcu_read_lock();     // Just disable preemption       │
</span></span><span style=display:flex><span>│  ptr = rcu_dereference(global_ptr);                    │
</span></span><span style=display:flex><span>│  use(ptr-&gt;data);                                       │
</span></span><span style=display:flex><span>│  rcu_read_unlock();                                    │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Writing:                                              │
</span></span><span style=display:flex><span>│  new = kmalloc(sizeof(*new));                          │
</span></span><span style=display:flex><span>│  *new = *old;         // Copy old data                 │
</span></span><span style=display:flex><span>│  new-&gt;field = value;  // Modify                        │
</span></span><span style=display:flex><span>│  rcu_assign_pointer(global_ptr, new);  // Publish      │
</span></span><span style=display:flex><span>│  synchronize_rcu();   // Wait for readers              │
</span></span><span style=display:flex><span>│  kfree(old);          // Now safe to free              │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Grace period:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Time →                                                 │
</span></span><span style=display:flex><span>│  ├──────────────────────────────────────────────────►  │
</span></span><span style=display:flex><span>│  │     update     │← grace period →│ reclaim          │
</span></span><span style=display:flex><span>│  │                │                 │                  │
</span></span><span style=display:flex><span>│  Reader A: ████████                                    │
</span></span><span style=display:flex><span>│  Reader B:     ████████████                            │
</span></span><span style=display:flex><span>│  Reader C:              ██████                         │
</span></span><span style=display:flex><span>│                                 │                      │
</span></span><span style=display:flex><span>│  After all readers that started before update finish,  │
</span></span><span style=display:flex><span>│  it&#39;s safe to free old data.                           │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Advantages:
</span></span><span style=display:flex><span>- Zero-overhead readers (no atomics, no cache bouncing)
</span></span><span style=display:flex><span>- Scales perfectly with reader count
</span></span><span style=display:flex><span>- Widely used in Linux kernel
</span></span></code></pre></div><h2 id="10-practical-guidelines">10. Practical Guidelines</h2><p>Applying concurrency knowledge effectively.</p><h3 id="101-design-principles">10.1 Design Principles</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>1. Minimize shared mutable state:
</span></span><span style=display:flex><span>- Thread-local data where possible
</span></span><span style=display:flex><span>- Immutable shared data
</span></span><span style=display:flex><span>- Message passing over shared memory
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Coarse vs fine-grained locking:
</span></span><span style=display:flex><span>- Start coarse (one big lock)
</span></span><span style=display:flex><span>- Profile to find contention
</span></span><span style=display:flex><span>- Split locks where needed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Lock ordering:
</span></span><span style=display:flex><span>- Always acquire locks in same order
</span></span><span style=display:flex><span>- Prevents deadlock
</span></span><span style=display:flex><span>- Document and enforce order
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Avoid holding locks across I/O:
</span></span><span style=display:flex><span>- I/O is slow and unpredictable
</span></span><span style=display:flex><span>- Hold lock, copy data, release, then do I/O
</span></span></code></pre></div><h3 id="102-common-patterns">10.2 Common Patterns</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Thread-safe singleton:
</span></span><span style=display:flex><span>static MyClass&amp; getInstance() {
</span></span><span style=display:flex><span>    static MyClass instance;  // C++11: thread-safe
</span></span><span style=display:flex><span>    return instance;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Double-checked locking (fixed):
</span></span><span style=display:flex><span>std::atomic&lt;MyClass*&gt; instance{nullptr};
</span></span><span style=display:flex><span>std::mutex mtx;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MyClass* getInstance() {
</span></span><span style=display:flex><span>    MyClass* tmp = instance.load(std::memory_order_acquire);
</span></span><span style=display:flex><span>    if (tmp == nullptr) {
</span></span><span style=display:flex><span>        std::lock_guard&lt;std::mutex&gt; lock(mtx);
</span></span><span style=display:flex><span>        tmp = instance.load(std::memory_order_relaxed);
</span></span><span style=display:flex><span>        if (tmp == nullptr) {
</span></span><span style=display:flex><span>            tmp = new MyClass();
</span></span><span style=display:flex><span>            instance.store(tmp, std::memory_order_release);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    return tmp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread pool pattern:
</span></span><span style=display:flex><span>- Fixed set of worker threads
</span></span><span style=display:flex><span>- Task queue with mutex + condition variable
</span></span><span style=display:flex><span>- Workers wait for tasks, execute, repeat
</span></span></code></pre></div><h3 id="103-debugging-concurrent-code">10.3 Debugging Concurrent Code</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Tools for finding concurrency bugs:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread Sanitizer (TSan):
</span></span><span style=display:flex><span>g++ -fsanitize=thread program.cpp
</span></span><span style=display:flex><span>./a.out
</span></span><span style=display:flex><span># Reports data races at runtime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Helgrind (Valgrind):
</span></span><span style=display:flex><span>valgrind --tool=helgrind ./program
</span></span><span style=display:flex><span># Detects lock order violations, races
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Static analysis:
</span></span><span style=display:flex><span>- Clang Thread Safety Analysis
</span></span><span style=display:flex><span>- Annotate code with thread safety attributes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Stress testing:
</span></span><span style=display:flex><span>- Run with many threads
</span></span><span style=display:flex><span>- Vary timing with delays
</span></span><span style=display:flex><span>- Use CPU affinity to force interleaving
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Logging:
</span></span><span style=display:flex><span>- Log lock acquisitions/releases
</span></span><span style=display:flex><span>- Include thread ID and timestamp
</span></span><span style=display:flex><span>- Replay to understand ordering
</span></span></code></pre></div><h3 id="104-performance-tuning">10.4 Performance Tuning</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Contention profiling:
</span></span><span style=display:flex><span>perf record -e lock:* ./program
</span></span><span style=display:flex><span>perf report
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Linux lock statistics:
</span></span><span style=display:flex><span>echo 1 &gt; /proc/sys/kernel/lock_stat
</span></span><span style=display:flex><span>cat /proc/lock_stat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reducing contention:
</span></span><span style=display:flex><span>1. Shorten critical sections
</span></span><span style=display:flex><span>2. Use reader-writer locks for read-heavy
</span></span><span style=display:flex><span>3. Partition data (per-thread or per-CPU)
</span></span><span style=display:flex><span>4. Batch operations to reduce lock frequency
</span></span><span style=display:flex><span>5. Consider lock-free for hot paths
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cache-friendly synchronization:
</span></span><span style=display:flex><span>- Align lock structures to cache lines
</span></span><span style=display:flex><span>- Avoid false sharing between locks
</span></span><span style=display:flex><span>- Group related data under same lock
</span></span></code></pre></div><h3 id="105-deadlock-prevention-and-detection">10.5 Deadlock Prevention and Detection</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Deadlock conditions (all four required):
</span></span><span style=display:flex><span>1. Mutual exclusion: Resources held exclusively
</span></span><span style=display:flex><span>2. Hold and wait: Hold one, wait for another
</span></span><span style=display:flex><span>3. No preemption: Can&#39;t force release
</span></span><span style=display:flex><span>4. Circular wait: A waits for B waits for A
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Prevention strategies:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Lock ordering:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Always acquire in consistent order                 │
</span></span><span style=display:flex><span>│  #define LOCK_ACCOUNT 1                                │
</span></span><span style=display:flex><span>│  #define LOCK_TRANSFER 2                               │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  void transfer(Account *from, Account *to, int amt) {  │
</span></span><span style=display:flex><span>│      // Order by address to ensure consistency         │
</span></span><span style=display:flex><span>│      Account *first = from &lt; to ? from : to;          │
</span></span><span style=display:flex><span>│      Account *second = from &lt; to ? to : from;         │
</span></span><span style=display:flex><span>│      lock(&amp;first-&gt;mutex);                              │
</span></span><span style=display:flex><span>│      lock(&amp;second-&gt;mutex);                             │
</span></span><span style=display:flex><span>│      // Transfer...                                    │
</span></span><span style=display:flex><span>│      unlock(&amp;second-&gt;mutex);                           │
</span></span><span style=display:flex><span>│      unlock(&amp;first-&gt;mutex);                            │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Try-lock with backoff:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  bool acquire_both(mutex *a, mutex *b) {               │
</span></span><span style=display:flex><span>│      while (true) {                                    │
</span></span><span style=display:flex><span>│          lock(a);                                      │
</span></span><span style=display:flex><span>│          if (try_lock(b)) {                            │
</span></span><span style=display:flex><span>│              return true;  // Got both                 │
</span></span><span style=display:flex><span>│          }                                             │
</span></span><span style=display:flex><span>│          unlock(a);                                    │
</span></span><span style=display:flex><span>│          // Backoff to avoid livelock                  │
</span></span><span style=display:flex><span>│          usleep(rand() % 1000);                        │
</span></span><span style=display:flex><span>│      }                                                 │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deadlock detection:
</span></span><span style=display:flex><span>- Build lock graph at runtime
</span></span><span style=display:flex><span>- Detect cycles periodically
</span></span><span style=display:flex><span>- Break deadlock by aborting transaction
</span></span><span style=display:flex><span>- Used in databases (transaction rollback)
</span></span></code></pre></div><h3 id="106-testing-concurrent-code">10.6 Testing Concurrent Code</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Concurrency testing is notoriously difficult:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Stress testing:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Run many threads with random timing                │
</span></span><span style=display:flex><span>│  for (int t = 0; t &lt; NUM_THREADS; t++) {               │
</span></span><span style=display:flex><span>│      spawn_thread([&amp;] {                                │
</span></span><span style=display:flex><span>│          for (int i = 0; i &lt; ITERATIONS; i++) {        │
</span></span><span style=display:flex><span>│              random_delay();                           │
</span></span><span style=display:flex><span>│              do_operation();                           │
</span></span><span style=display:flex><span>│              verify_invariants();                      │
</span></span><span style=display:flex><span>│          }                                             │
</span></span><span style=display:flex><span>│      });                                               │
</span></span><span style=display:flex><span>│  }                                                     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Systematic testing (model checking):
</span></span><span style=display:flex><span>- Explore all possible interleavings
</span></span><span style=display:flex><span>- Tools: CHESS, CDSChecker, Relacy
</span></span><span style=display:flex><span>- Exhaustive but slow
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Fuzzing with thread scheduling:
</span></span><span style=display:flex><span>- Inject random delays at sync points
</span></span><span style=display:flex><span>- Force unusual interleavings
</span></span><span style=display:flex><span>- Often finds bugs stress testing misses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Assertions and invariants:
</span></span><span style=display:flex><span>- Check data structure consistency
</span></span><span style=display:flex><span>- Assert lock is held when accessing data
</span></span><span style=display:flex><span>- Use debug builds with extra checks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. Logging and replay:
</span></span><span style=display:flex><span>- Record thread schedules and operations
</span></span><span style=display:flex><span>- Replay deterministically to reproduce bugs
</span></span><span style=display:flex><span>- Essential for debugging heisenbugs
</span></span></code></pre></div><p>Concurrent programming requires thinking about not just what operations occur, but in what order they might occur across threads. From the hardware-level atomic instructions through spinlocks, mutexes, and condition variables to sophisticated lock-free algorithms, each layer builds on the foundations below. The key insights remain constant: minimize sharing, protect what must be shared, understand the memory model, and always verify correctness with appropriate tools. Mastering these primitives enables you to harness the full power of modern multicore systems while avoiding the subtle bugs that make concurrent programming notoriously difficult. Whether you choose locks for their simplicity or venture into lock-free territory for performance, the principles of synchronization guide you toward correct, efficient parallel programs.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/fundamentals/>fundamentals</a>, <a href=/categories/systems/>systems</a></div><div>Tags:
<a href=/tags/concurrency/>#concurrency</a>, <a href=/tags/locks/>#locks</a>, <a href=/tags/synchronization/>#synchronization</a>, <a href=/tags/multithreading/>#multithreading</a>, <a href=/tags/atomics/>#atomics</a>, <a href=/tags/fundamentals/>#fundamentals</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>