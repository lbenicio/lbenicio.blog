<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>Network Sockets and the TCP/IP Stack: How Data Travels Across Networks · Leonardo Benicio</title><meta name=description content="A comprehensive exploration of network programming internals, from socket system calls through the TCP/IP protocol stack to the network interface. Understand connection establishment, flow control, and the kernel's role in networking."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/network-sockets-and-the-tcp/ip-stack-how-data-travels-across-networks/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="Network Sockets and the TCP/IP Stack: How Data Travels Across Networks · Leonardo Benicio"><meta property="og:description" content="A comprehensive exploration of network programming internals, from socket system calls through the TCP/IP protocol stack to the network interface. Understand connection establishment, flow control, and the kernel's role in networking."><meta property="og:url" content="https://blog.lbenicio.dev/blog/network-sockets-and-the-tcp/ip-stack-how-data-travels-across-networks/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/network-sockets-tcp-ip-stack-internals.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Network Sockets and the TCP/IP Stack: How Data Travels Across Networks · Leonardo Benicio"><meta name=twitter:description content="A comprehensive exploration of network programming internals, from socket system calls through the TCP/IP protocol stack to the network interface. Understand connection establishment, flow control, and the kernel's role in networking."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/network-sockets-and-the-tcp/","name":"Network Sockets and the Tcp","position":3},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/network-sockets-and-the-tcp/ip-stack-how-data-travels-across-networks/","name":"IP Stack How Data Travels Across Networks","position":4}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/blog/network-sockets-and-the-tcp/ class="c19ee42 c71bae8 cfac1ac">Network Sockets and the Tcp</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">IP Stack How Data Travels Across Networks</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/blog/network-sockets-and-the-tcp/ class="c19ee42 c71bae8 cfac1ac">Network Sockets and the Tcp</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">IP Stack How Data Travels Across Networks</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">Network Sockets and the TCP/IP Stack: How Data Travels Across Networks</h1><div class="c277478 c3ecea6 c8fb24a">2020-11-08
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/network-sockets-tcp-ip-stack-internals.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">A comprehensive exploration of network programming internals, from socket system calls through the TCP/IP protocol stack to the network interface. Understand connection establishment, flow control, and the kernel's role in networking.</p></header><div class="content"><p>Every web request, database query, and API call travels through the network stack. The simple act of opening a connection hides layers of protocol machinery handling packet routing, reliable delivery, congestion control, and flow management. Understanding how sockets work and how data traverses the TCP/IP stack illuminates why networks behave as they do and how to build efficient networked applications.</p><h2 id="1-the-network-stack-overview">1. The Network Stack Overview</h2><p>Before diving into details, let&rsquo;s see the complete picture.</p><h3 id="11-the-osi-and-tcpip-models">1.1 The OSI and TCP/IP Models</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>OSI Model                    TCP/IP Model           Examples
</span></span><span style=display:flex><span>┌─────────────────┐          ┌─────────────────┐
</span></span><span style=display:flex><span>│  Application    │          │                 │    HTTP, DNS, SSH
</span></span><span style=display:flex><span>├─────────────────┤          │  Application    │
</span></span><span style=display:flex><span>│  Presentation   │          │                 │    TLS, JSON, XML
</span></span><span style=display:flex><span>├─────────────────┤          │                 │
</span></span><span style=display:flex><span>│  Session        │          │                 │    Sockets API
</span></span><span style=display:flex><span>├─────────────────┤          ├─────────────────┤
</span></span><span style=display:flex><span>│  Transport      │          │  Transport      │    TCP, UDP
</span></span><span style=display:flex><span>├─────────────────┤          ├─────────────────┤
</span></span><span style=display:flex><span>│  Network        │          │  Internet       │    IP, ICMP
</span></span><span style=display:flex><span>├─────────────────┤          ├─────────────────┤
</span></span><span style=display:flex><span>│  Data Link      │          │                 │    Ethernet, WiFi
</span></span><span style=display:flex><span>├─────────────────┤          │  Link           │
</span></span><span style=display:flex><span>│  Physical       │          │                 │    Cables, Radio
</span></span><span style=display:flex><span>└─────────────────┘          └─────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data flow (sending):
</span></span><span style=display:flex><span>Application → Transport → Network → Link → Physical → Wire
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data flow (receiving):
</span></span><span style=display:flex><span>Wire → Physical → Link → Network → Transport → Application
</span></span></code></pre></div><h3 id="12-encapsulation">1.2 Encapsulation</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Each layer wraps data in its own header:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Application data:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                    HTTP Request                          │
</span></span><span style=display:flex><span>│  &#34;GET /index.html HTTP/1.1\r\nHost: example.com...&#34;     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Transport layer (TCP) adds header:
</span></span><span style=display:flex><span>┌──────────────┬─────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  TCP Header  │              HTTP Request                │
</span></span><span style=display:flex><span>│  (20 bytes)  │                                          │
</span></span><span style=display:flex><span>└──────────────┴─────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Network layer (IP) adds header:
</span></span><span style=display:flex><span>┌──────────────┬──────────────┬──────────────────────────┐
</span></span><span style=display:flex><span>│  IP Header   │  TCP Header  │       HTTP Request       │
</span></span><span style=display:flex><span>│  (20 bytes)  │  (20 bytes)  │                          │
</span></span><span style=display:flex><span>└──────────────┴──────────────┴──────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Link layer (Ethernet) adds header and trailer:
</span></span><span style=display:flex><span>┌──────────────┬──────────────┬──────────────┬────────────────────┬─────────┐
</span></span><span style=display:flex><span>│ Eth Header   │  IP Header   │  TCP Header  │    HTTP Request    │Eth Trail│
</span></span><span style=display:flex><span>│  (14 bytes)  │  (20 bytes)  │  (20 bytes)  │                    │(4 bytes)│
</span></span><span style=display:flex><span>└──────────────┴──────────────┴──────────────┴────────────────────┴─────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>This complete unit is a &#34;frame&#34; ready for transmission.
</span></span></code></pre></div><h3 id="13-kernel-networking-components">1.3 Kernel Networking Components</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Linux network stack architecture:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                     User Space                               │
</span></span><span style=display:flex><span>│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   │
</span></span><span style=display:flex><span>│  │ Application  │  │ Application  │  │   Application    │   │
</span></span><span style=display:flex><span>│  │  (browser)   │  │  (server)    │  │   (database)     │   │
</span></span><span style=display:flex><span>│  └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘   │
</span></span><span style=display:flex><span>└─────────┼─────────────────┼───────────────────┼─────────────┘
</span></span><span style=display:flex><span>          │ Socket API      │                   │
</span></span><span style=display:flex><span>──────────┼─────────────────┼───────────────────┼──────────────
</span></span><span style=display:flex><span>          ▼                 ▼                   ▼
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                     Kernel Space                             │
</span></span><span style=display:flex><span>│  ┌──────────────────────────────────────────────────────┐   │
</span></span><span style=display:flex><span>│  │                   Socket Layer                        │   │
</span></span><span style=display:flex><span>│  │         (struct socket, file descriptor)              │   │
</span></span><span style=display:flex><span>│  └──────────────────────────┬───────────────────────────┘   │
</span></span><span style=display:flex><span>│  ┌──────────────────────────┴───────────────────────────┐   │
</span></span><span style=display:flex><span>│  │              Protocol Layer (TCP/UDP)                 │   │
</span></span><span style=display:flex><span>│  │       (struct sock, connection state, buffers)        │   │
</span></span><span style=display:flex><span>│  └──────────────────────────┬───────────────────────────┘   │
</span></span><span style=display:flex><span>│  ┌──────────────────────────┴───────────────────────────┐   │
</span></span><span style=display:flex><span>│  │                   IP Layer                            │   │
</span></span><span style=display:flex><span>│  │            (routing, fragmentation)                   │   │
</span></span><span style=display:flex><span>│  └──────────────────────────┬───────────────────────────┘   │
</span></span><span style=display:flex><span>│  ┌──────────────────────────┴───────────────────────────┐   │
</span></span><span style=display:flex><span>│  │               Network Device Layer                    │   │
</span></span><span style=display:flex><span>│  │           (driver interface, queues)                  │   │
</span></span><span style=display:flex><span>│  └──────────────────────────┬───────────────────────────┘   │
</span></span><span style=display:flex><span>└─────────────────────────────┼───────────────────────────────┘
</span></span><span style=display:flex><span>                              ▼
</span></span><span style=display:flex><span>                    ┌─────────────────┐
</span></span><span style=display:flex><span>                    │   NIC Hardware  │
</span></span><span style=display:flex><span>                    └─────────────────┘
</span></span></code></pre></div><h2 id="2-the-socket-api">2. The Socket API</h2><p>Sockets provide the programming interface to the network.</p><h3 id="21-socket-system-calls">2.1 Socket System Calls</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Server side
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> server_fd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#a5d6ff>0</span>);  <span style=color:#8b949e;font-style:italic>// Create socket
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> sockaddr_in addr <span style=color:#ff7b72;font-weight:700>=</span> {
</span></span><span style=display:flex><span>    .sin_family <span style=color:#ff7b72;font-weight:700>=</span> AF_INET,
</span></span><span style=display:flex><span>    .sin_port <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>htons</span>(<span style=color:#a5d6ff>8080</span>),
</span></span><span style=display:flex><span>    .sin_addr.s_addr <span style=color:#ff7b72;font-weight:700>=</span> INADDR_ANY
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>bind</span>(server_fd, (<span style=color:#ff7b72>struct</span> sockaddr<span style=color:#ff7b72;font-weight:700>*</span>)<span style=color:#ff7b72;font-weight:700>&amp;</span>addr, <span style=color:#ff7b72>sizeof</span>(addr));  <span style=color:#8b949e;font-style:italic>// Bind to port
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>listen</span>(server_fd, <span style=color:#a5d6ff>128</span>);  <span style=color:#8b949e;font-style:italic>// Mark as listening, backlog = 128
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> client_fd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>accept</span>(server_fd, NULL, NULL);  <span style=color:#8b949e;font-style:italic>// Accept connection
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// client_fd is a new socket for this connection
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>char</span> buffer[<span style=color:#a5d6ff>1024</span>];
</span></span><span style=display:flex><span><span style=color:#ff7b72>ssize_t</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read</span>(client_fd, buffer, <span style=color:#ff7b72>sizeof</span>(buffer));  <span style=color:#8b949e;font-style:italic>// Receive data
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>write</span>(client_fd, <span style=color:#a5d6ff>&#34;Hello&#34;</span>, <span style=color:#a5d6ff>5</span>);  <span style=color:#8b949e;font-style:italic>// Send data
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>close</span>(client_fd);  <span style=color:#8b949e;font-style:italic>// Close connection
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>close</span>(server_fd);  <span style=color:#8b949e;font-style:italic>// Close listening socket
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Client side
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> sock <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> sockaddr_in server <span style=color:#ff7b72;font-weight:700>=</span> {
</span></span><span style=display:flex><span>    .sin_family <span style=color:#ff7b72;font-weight:700>=</span> AF_INET,
</span></span><span style=display:flex><span>    .sin_port <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>htons</span>(<span style=color:#a5d6ff>8080</span>)
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>inet_pton</span>(AF_INET, <span style=color:#a5d6ff>&#34;192.168.1.1&#34;</span>, <span style=color:#ff7b72;font-weight:700>&amp;</span>server.sin_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>connect</span>(sock, (<span style=color:#ff7b72>struct</span> sockaddr<span style=color:#ff7b72;font-weight:700>*</span>)<span style=color:#ff7b72;font-weight:700>&amp;</span>server, <span style=color:#ff7b72>sizeof</span>(server));  <span style=color:#8b949e;font-style:italic>// Connect
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>write</span>(sock, <span style=color:#a5d6ff>&#34;Hello&#34;</span>, <span style=color:#a5d6ff>5</span>);  <span style=color:#8b949e;font-style:italic>// Send
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>read</span>(sock, buffer, <span style=color:#ff7b72>sizeof</span>(buffer));  <span style=color:#8b949e;font-style:italic>// Receive
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>close</span>(sock);
</span></span></code></pre></div><h3 id="22-socket-data-structures">2.2 Socket Data Structures</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Kernel socket structures:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>struct socket (VFS interface):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  state: SS_CONNECTED                                   │
</span></span><span style=display:flex><span>│  type: SOCK_STREAM                                     │
</span></span><span style=display:flex><span>│  flags: various options                                │
</span></span><span style=display:flex><span>│  ops: pointer to protocol operations                   │
</span></span><span style=display:flex><span>│  sk: pointer to struct sock (protocol layer)          │
</span></span><span style=display:flex><span>│  file: pointer to struct file (for fd)                │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>            │
</span></span><span style=display:flex><span>            ▼
</span></span><span style=display:flex><span>struct sock (protocol layer):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Protocol state (TCP: ESTABLISHED, etc.)              │
</span></span><span style=display:flex><span>│  Source/destination addresses and ports               │
</span></span><span style=display:flex><span>│  Send buffer (sk_write_queue)                         │
</span></span><span style=display:flex><span>│  Receive buffer (sk_receive_queue)                    │
</span></span><span style=display:flex><span>│  Timers (retransmit, keepalive, etc.)                 │
</span></span><span style=display:flex><span>│  Congestion control state                             │
</span></span><span style=display:flex><span>│  Window sizes                                          │
</span></span><span style=display:flex><span>│  Sequence numbers                                      │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>struct sk_buff (packet buffer):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Pointers: head, data, tail, end                      │
</span></span><span style=display:flex><span>│  Protocol headers at various offsets                  │
</span></span><span style=display:flex><span>│  Reference count                                       │
</span></span><span style=display:flex><span>│  Device reference                                      │
</span></span><span style=display:flex><span>│  Timestamp                                             │
</span></span><span style=display:flex><span>│  Actual packet data follows                            │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="23-file-descriptor-integration">2.3 File Descriptor Integration</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Sockets are file descriptors:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Process file descriptor table:
</span></span><span style=display:flex><span>┌─────┬───────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ fd  │ struct file*                              │
</span></span><span style=display:flex><span>├─────┼───────────────────────────────────────────┤
</span></span><span style=display:flex><span>│  0  │ → stdin (terminal)                        │
</span></span><span style=display:flex><span>│  1  │ → stdout (terminal)                       │
</span></span><span style=display:flex><span>│  2  │ → stderr (terminal)                       │
</span></span><span style=display:flex><span>│  3  │ → socket (struct socket → TCP connection) │
</span></span><span style=display:flex><span>│  4  │ → regular file (/tmp/data.txt)           │
</span></span><span style=display:flex><span>│  5  │ → socket (listening server socket)        │
</span></span><span style=display:flex><span>└─────┴───────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Because sockets are fds:
</span></span><span style=display:flex><span>- read()/write() work on sockets
</span></span><span style=display:flex><span>- select()/poll()/epoll work on sockets
</span></span><span style=display:flex><span>- Can pass sockets between processes (via Unix sockets)
</span></span><span style=display:flex><span>- close() closes the connection
</span></span><span style=display:flex><span>- dup()/dup2() create socket aliases
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Socket-specific operations:
</span></span><span style=display:flex><span>- send()/recv() with flags
</span></span><span style=display:flex><span>- sendto()/recvfrom() for UDP
</span></span><span style=display:flex><span>- sendmsg()/recvmsg() for advanced use
</span></span><span style=display:flex><span>- getsockopt()/setsockopt() for options
</span></span></code></pre></div><h3 id="24-blocking-vs-non-blocking">2.4 Blocking vs Non-Blocking</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-c" data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Blocking (default): calls wait until complete
</span></span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>read</span>(sock, buf, len);  <span style=color:#8b949e;font-style:italic>// Blocks until data available
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Non-blocking: calls return immediately
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> flags <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>fcntl</span>(sock, F_GETFL, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>fcntl</span>(sock, F_SETFL, flags <span style=color:#ff7b72;font-weight:700>|</span> O_NONBLOCK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>ssize_t</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read</span>(sock, buf, len);
</span></span><span style=display:flex><span><span style=color:#ff7b72>if</span> (n <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> errno <span style=color:#ff7b72;font-weight:700>==</span> EAGAIN) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// No data available, try again later
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Or set at socket creation
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> sock <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>socket</span>(AF_INET, SOCK_STREAM <span style=color:#ff7b72;font-weight:700>|</span> SOCK_NONBLOCK, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Common pattern with epoll:
</span></span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> epfd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>epoll_create1</span>(<span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> epoll_event ev <span style=color:#ff7b72;font-weight:700>=</span> {
</span></span><span style=display:flex><span>    .events <span style=color:#ff7b72;font-weight:700>=</span> EPOLLIN <span style=color:#ff7b72;font-weight:700>|</span> EPOLLET,  <span style=color:#8b949e;font-style:italic>// Edge-triggered
</span></span></span><span style=display:flex><span>    .data.fd <span style=color:#ff7b72;font-weight:700>=</span> sock
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock, <span style=color:#ff7b72;font-weight:700>&amp;</span>ev);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> epoll_event events[MAX_EVENTS];
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> nfds <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>epoll_wait</span>(epfd, events, MAX_EVENTS, <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>&lt;</span> nfds; i<span style=color:#ff7b72;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>handle_event</span>(events[i]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id="3-tcp-connection-lifecycle">3. TCP Connection Lifecycle</h2><p>Understanding TCP&rsquo;s reliable connection protocol.</p><h3 id="31-three-way-handshake">3.1 Three-Way Handshake</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Connection establishment:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Client                              Server
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ──────── SYN (seq=x) ──────────► │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ◄─── SYN-ACK (seq=y, ack=x+1) ── │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ──────── ACK (ack=y+1) ────────► │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   ESTABLISHED                        ESTABLISHED
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sequence numbers:
</span></span><span style=display:flex><span>- Client picks random initial sequence number (ISN): x
</span></span><span style=display:flex><span>- Server picks its own ISN: y
</span></span><span style=display:flex><span>- Each side acknowledges the other&#39;s ISN + 1
</span></span><span style=display:flex><span>- Prevents old duplicate packets from being accepted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SYN queue and accept queue:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│               Server Kernel                              │
</span></span><span style=display:flex><span>│                                                          │
</span></span><span style=display:flex><span>│  Incoming SYN:                                           │
</span></span><span style=display:flex><span>│  ┌─────────────────────────────────┐                     │
</span></span><span style=display:flex><span>│  │       SYN Queue (half-open)     │ ← SYN received     │
</span></span><span style=display:flex><span>│  │  Connection 1 (SYN_RECV)        │   SYN-ACK sent     │
</span></span><span style=display:flex><span>│  │  Connection 2 (SYN_RECV)        │                     │
</span></span><span style=display:flex><span>│  │  Connection 3 (SYN_RECV)        │                     │
</span></span><span style=display:flex><span>│  └─────────────────────────────────┘                     │
</span></span><span style=display:flex><span>│              │ ACK received                              │
</span></span><span style=display:flex><span>│              ▼                                           │
</span></span><span style=display:flex><span>│  ┌─────────────────────────────────┐                     │
</span></span><span style=display:flex><span>│  │    Accept Queue (established)   │                     │
</span></span><span style=display:flex><span>│  │  Connection A (ESTABLISHED)     │ ← Ready for        │
</span></span><span style=display:flex><span>│  │  Connection B (ESTABLISHED)     │   accept()         │
</span></span><span style=display:flex><span>│  └─────────────────────────────────┘                     │
</span></span><span style=display:flex><span>│              │                                           │
</span></span><span style=display:flex><span>│              ▼ accept() returns                          │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="32-data-transfer">3.2 Data Transfer</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Reliable data transfer:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sender                                  Receiver
</span></span><span style=display:flex><span>   │                                       │
</span></span><span style=display:flex><span>   │ ─── Data (seq=1000, len=1000) ──────► │
</span></span><span style=display:flex><span>   │                                       │
</span></span><span style=display:flex><span>   │ ◄─────── ACK (ack=2000) ────────────  │
</span></span><span style=display:flex><span>   │                                       │
</span></span><span style=display:flex><span>   │ ─── Data (seq=2000, len=1000) ──────► │
</span></span><span style=display:flex><span>   │ ─── Data (seq=3000, len=1000) ──────► │
</span></span><span style=display:flex><span>   │ ─── Data (seq=4000, len=1000) ──────► │
</span></span><span style=display:flex><span>   │                                       │
</span></span><span style=display:flex><span>   │ ◄─────── ACK (ack=5000) ────────────  │ (cumulative)
</span></span><span style=display:flex><span>   │                                       │
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cumulative acknowledgment:
</span></span><span style=display:flex><span>- ACK number = next expected byte
</span></span><span style=display:flex><span>- ACK 5000 means &#34;received all bytes up to 4999&#34;
</span></span><span style=display:flex><span>- Multiple segments can be ACKed with single ACK
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Retransmission:
</span></span><span style=display:flex><span>- Sender sets timer for each segment
</span></span><span style=display:flex><span>- If ACK not received in time, retransmit
</span></span><span style=display:flex><span>- Exponential backoff on repeated failures
</span></span></code></pre></div><h3 id="33-connection-termination">3.3 Connection Termination</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Four-way handshake for graceful close:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Client                              Server
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ───────── FIN (seq=x) ─────────► │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   FIN_WAIT_1                         CLOSE_WAIT
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ◄──────── ACK (ack=x+1) ──────── │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   FIN_WAIT_2                         (Server may send more data)
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ◄──────── FIN (seq=y) ────────── │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   TIME_WAIT                          LAST_ACK
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>      │ ───────── ACK (ack=y+1) ────────► │
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   (wait 2×MSL)                       CLOSED
</span></span><span style=display:flex><span>      │                                   │
</span></span><span style=display:flex><span>   CLOSED                                 │
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TIME_WAIT:
</span></span><span style=display:flex><span>- Lasts 2 × Maximum Segment Lifetime (typically 60 seconds)
</span></span><span style=display:flex><span>- Ensures final ACK reaches server
</span></span><span style=display:flex><span>- Prevents old duplicate packets from being accepted
</span></span><span style=display:flex><span>- Can cause &#34;address already in use&#34; on quick restart
</span></span><span style=display:flex><span>- SO_REUSEADDR socket option helps
</span></span></code></pre></div><h3 id="34-tcp-state-machine">3.4 TCP State Machine</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Complete TCP state diagram:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                              ┌──────────────┐
</span></span><span style=display:flex><span>                              │    CLOSED    │
</span></span><span style=display:flex><span>                              └──────┬───────┘
</span></span><span style=display:flex><span>                    passive open     │     active open
</span></span><span style=display:flex><span>                     (listen)        │      (connect)
</span></span><span style=display:flex><span>                         ┌───────────┴───────────┐
</span></span><span style=display:flex><span>                         ▼                       ▼
</span></span><span style=display:flex><span>                  ┌──────────────┐        ┌──────────────┐
</span></span><span style=display:flex><span>                  │    LISTEN    │        │   SYN_SENT   │
</span></span><span style=display:flex><span>                  └──────┬───────┘        └──────┬───────┘
</span></span><span style=display:flex><span>              rcv SYN    │                       │ rcv SYN-ACK
</span></span><span style=display:flex><span>              send SYN-ACK                       │ send ACK
</span></span><span style=display:flex><span>                         │         ┌─────────────┘
</span></span><span style=display:flex><span>                         ▼         ▼
</span></span><span style=display:flex><span>                  ┌──────────────────────┐
</span></span><span style=display:flex><span>                  │     SYN_RECEIVED     │
</span></span><span style=display:flex><span>                  └──────────┬───────────┘
</span></span><span style=display:flex><span>                   rcv ACK   │
</span></span><span style=display:flex><span>                             ▼
</span></span><span style=display:flex><span>                  ┌──────────────────────┐
</span></span><span style=display:flex><span>                  │     ESTABLISHED      │ ← Normal data transfer
</span></span><span style=display:flex><span>                  └──────────┬───────────┘
</span></span><span style=display:flex><span>             close           │           rcv FIN
</span></span><span style=display:flex><span>             send FIN        │           send ACK
</span></span><span style=display:flex><span>           ┌─────────────────┴─────────────────┐
</span></span><span style=display:flex><span>           ▼                                   ▼
</span></span><span style=display:flex><span>    ┌──────────────┐                    ┌──────────────┐
</span></span><span style=display:flex><span>    │  FIN_WAIT_1  │                    │  CLOSE_WAIT  │
</span></span><span style=display:flex><span>    └──────┬───────┘                    └──────┬───────┘
</span></span><span style=display:flex><span>           │                                   │ close
</span></span><span style=display:flex><span>           ▼                                   │ send FIN
</span></span><span style=display:flex><span>    ┌──────────────┐                    ┌──────┴───────┐
</span></span><span style=display:flex><span>    │  FIN_WAIT_2  │                    │   LAST_ACK   │
</span></span><span style=display:flex><span>    └──────┬───────┘                    └──────┬───────┘
</span></span><span style=display:flex><span>   rcv FIN │                           rcv ACK │
</span></span><span style=display:flex><span>   send ACK│                                   │
</span></span><span style=display:flex><span>           ▼                                   ▼
</span></span><span style=display:flex><span>    ┌──────────────┐                    ┌──────────────┐
</span></span><span style=display:flex><span>    │  TIME_WAIT   │                    │    CLOSED    │
</span></span><span style=display:flex><span>    └──────┬───────┘                    └──────────────┘
</span></span><span style=display:flex><span>   timeout │
</span></span><span style=display:flex><span>           ▼
</span></span><span style=display:flex><span>    ┌──────────────┐
</span></span><span style=display:flex><span>    │    CLOSED    │
</span></span><span style=display:flex><span>    └──────────────┘
</span></span></code></pre></div><h2 id="4-tcp-flow-control-and-congestion-control">4. TCP Flow Control and Congestion Control</h2><p>Preventing overwhelming receivers and networks.</p><h3 id="41-flow-control-receive-window">4.1 Flow Control: Receive Window</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Receive window prevents sender from overwhelming receiver:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Receiver advertises available buffer space:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Receiver Buffer (64KB)                                 │
</span></span><span style=display:flex><span>│  ┌──────────────────────────┬───────────────────────┐  │
</span></span><span style=display:flex><span>│  │      Data waiting for    │    Available space    │  │
</span></span><span style=display:flex><span>│  │      application read    │    (receive window)   │  │
</span></span><span style=display:flex><span>│  │         32KB             │         32KB          │  │
</span></span><span style=display:flex><span>│  └──────────────────────────┴───────────────────────┘  │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  ACK packet includes: Window = 32768                    │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sender side:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Must keep: unacked_data + in_flight ≤ receiver_window  │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  If window = 0: Stop sending, probe periodically        │
</span></span><span style=display:flex><span>│  As receiver reads data: Window opens, ACK sent         │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Window scaling (for high bandwidth-delay networks):
</span></span><span style=display:flex><span>- Original window: 16 bits = max 64KB
</span></span><span style=display:flex><span>- Window scale option: Multiply by 2^scale
</span></span><span style=display:flex><span>- Scale up to 14 = 64KB × 16384 = 1GB window
</span></span></code></pre></div><h3 id="42-congestion-control">4.2 Congestion Control</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Preventing network congestion collapse:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Congestion window (cwnd): Sender-side limit
</span></span><span style=display:flex><span>- Independent of receive window
</span></span><span style=display:flex><span>- Grows when network seems uncongested
</span></span><span style=display:flex><span>- Shrinks on packet loss (sign of congestion)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Effective window = min(cwnd, receive_window)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Classic algorithms:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Slow Start:
</span></span><span style=display:flex><span>- Initial cwnd = 1-10 MSS (Maximum Segment Size)
</span></span><span style=display:flex><span>- Double cwnd each RTT (exponential growth)
</span></span><span style=display:flex><span>- Until: loss occurs OR cwnd &gt; ssthresh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Congestion Avoidance:
</span></span><span style=display:flex><span>- Linear growth: cwnd += 1 per RTT
</span></span><span style=display:flex><span>- After loss: ssthresh = cwnd/2, restart
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  cwnd                                                   │
</span></span><span style=display:flex><span>│   │                               ×(loss)               │
</span></span><span style=display:flex><span>│   │                          ╱    │                     │
</span></span><span style=display:flex><span>│   │                     ╱        │                     │
</span></span><span style=display:flex><span>│   │                ╱             │     Linear          │
</span></span><span style=display:flex><span>│   │           ╱                  │    ╱                │
</span></span><span style=display:flex><span>│   │      ╱                       │ ╱                   │
</span></span><span style=display:flex><span>│   │ ╱ Slow start                 ╱                     │
</span></span><span style=display:flex><span>│   └──────────────────────────────────────────── time   │
</span></span><span style=display:flex><span>│        Exponential growth    ssthresh                   │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="43-modern-congestion-control">4.3 Modern Congestion Control</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>CUBIC (Linux default):
</span></span><span style=display:flex><span>- Designed for high bandwidth-delay product networks
</span></span><span style=display:flex><span>- Cubic function of time since last loss
</span></span><span style=display:flex><span>- More aggressive window growth than classic TCP
</span></span><span style=display:flex><span>- Used by most Linux servers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BBR (Bottleneck Bandwidth and RTT):
</span></span><span style=display:flex><span>- Developed by Google
</span></span><span style=display:flex><span>- Model-based rather than loss-based
</span></span><span style=display:flex><span>- Estimates bandwidth and RTT
</span></span><span style=display:flex><span>- Maintains low queue occupancy
</span></span><span style=display:flex><span>- Better performance on lossy links
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Comparison:
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Algorithm │ Loss-based │ Queue │ Fairness            │
</span></span><span style=display:flex><span>├────────────┼────────────┼───────┼─────────────────────┤
</span></span><span style=display:flex><span>│  Reno      │    Yes     │ High  │ Poor with others    │
</span></span><span style=display:flex><span>│  CUBIC     │    Yes     │ High  │ Good with CUBIC     │
</span></span><span style=display:flex><span>│  BBR       │    No      │ Low   │ Issues with others  │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Setting congestion control:
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_congestion_control=bbr
</span></span><span style=display:flex><span># Or per-socket:
</span></span><span style=display:flex><span>setsockopt(sock, IPPROTO_TCP, TCP_CONGESTION, &#34;bbr&#34;, 3);
</span></span></code></pre></div><h3 id="44-nagles-algorithm-and-delayed-acks">4.4 Nagle&rsquo;s Algorithm and Delayed ACKs</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Nagle&#39;s algorithm (reduce small packets):
</span></span><span style=display:flex><span>- If there&#39;s unacknowledged data AND new data is small:
</span></span><span style=display:flex><span>  Buffer it until ACK arrives or buffer fills
</span></span><span style=display:flex><span>- Prevents sending many tiny packets
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Delayed ACKs:
</span></span><span style=display:flex><span>- Don&#39;t ACK every packet immediately
</span></span><span style=display:flex><span>- Wait up to 40ms for more data to piggyback ACK
</span></span><span style=display:flex><span>- Or ACK after every 2 full-size segments
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The interaction problem:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Client (Nagle)          Server (Delayed ACK)          │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  send(100 bytes) ──────►  (received, waiting for more) │
</span></span><span style=display:flex><span>│  send(100 bytes)          │                            │
</span></span><span style=display:flex><span>│    │ waiting for ACK      │ waiting 40ms to ACK        │
</span></span><span style=display:flex><span>│    │                      │                            │
</span></span><span style=display:flex><span>│    ▼                      ▼                            │
</span></span><span style=display:flex><span>│       40ms delay before next data sent!                │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solutions:
</span></span><span style=display:flex><span>- TCP_NODELAY: Disable Nagle (send immediately)
</span></span><span style=display:flex><span>- TCP_QUICKACK: Disable delayed ACK
</span></span><span style=display:flex><span>- Batch writes: Larger writes avoid the issue
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;one, sizeof(one));
</span></span></code></pre></div><h2 id="5-the-ip-layer">5. The IP Layer</h2><p>Network layer handles addressing and routing.</p><h3 id="51-ip-packet-structure">5.1 IP Packet Structure</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>IPv4 Header (20-60 bytes):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  0                   1                   2              │
</span></span><span style=display:flex><span>│  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 ... │
</span></span><span style=display:flex><span>│ ├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤  │
</span></span><span style=display:flex><span>│ │Version│  IHL  │    DSCP   │ECN│     Total Length    │  │
</span></span><span style=display:flex><span>│ ├───────────────┼───────────┴───┴─────────────────────┤  │
</span></span><span style=display:flex><span>│ │         Identification          │Flags│ Frag Offset │  │
</span></span><span style=display:flex><span>│ ├───────────────┼─────────────────┴───────────────────┤  │
</span></span><span style=display:flex><span>│ │      TTL      │    Protocol     │  Header Checksum  │  │
</span></span><span style=display:flex><span>│ ├───────────────┴─────────────────┴───────────────────┤  │
</span></span><span style=display:flex><span>│ │                  Source Address                      │  │
</span></span><span style=display:flex><span>│ ├──────────────────────────────────────────────────────┤  │
</span></span><span style=display:flex><span>│ │               Destination Address                    │  │
</span></span><span style=display:flex><span>│ ├──────────────────────────────────────────────────────┤  │
</span></span><span style=display:flex><span>│ │                  Options (if any)                    │  │
</span></span><span style=display:flex><span>│ └──────────────────────────────────────────────────────┘  │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Key fields:
</span></span><span style=display:flex><span>- Version: 4 for IPv4, 6 for IPv6
</span></span><span style=display:flex><span>- TTL: Decremented at each hop, prevents loops
</span></span><span style=display:flex><span>- Protocol: 6 = TCP, 17 = UDP, 1 = ICMP
</span></span><span style=display:flex><span>- Addresses: 32-bit source and destination
</span></span></code></pre></div><h3 id="52-ip-fragmentation">5.2 IP Fragmentation</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Large packets may need fragmentation:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Original packet (4000 bytes data, MTU = 1500):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ IP Header │              4000 bytes of data            │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fragmented into 3 packets:
</span></span><span style=display:flex><span>┌─────────────────────────────┐
</span></span><span style=display:flex><span>│ IP │ Frag 0: 1480 bytes     │  Offset = 0, MF = 1
</span></span><span style=display:flex><span>└─────────────────────────────┘
</span></span><span style=display:flex><span>┌─────────────────────────────┐
</span></span><span style=display:flex><span>│ IP │ Frag 1: 1480 bytes     │  Offset = 1480, MF = 1
</span></span><span style=display:flex><span>└─────────────────────────────┘
</span></span><span style=display:flex><span>┌─────────────────────────────┐
</span></span><span style=display:flex><span>│ IP │ Frag 2: 1040 bytes     │  Offset = 2960, MF = 0
</span></span><span style=display:flex><span>└─────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Problems with fragmentation:
</span></span><span style=display:flex><span>- Receiver must reassemble (buffer, timeout)
</span></span><span style=display:flex><span>- One lost fragment = entire packet lost
</span></span><span style=display:flex><span>- Security issues (fragment attacks)
</span></span><span style=display:flex><span>- Performance overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Modern approach: Path MTU Discovery
</span></span><span style=display:flex><span>- Set &#34;Don&#39;t Fragment&#34; (DF) bit
</span></span><span style=display:flex><span>- If router can&#39;t forward, it sends ICMP &#34;too big&#34;
</span></span><span style=display:flex><span>- Sender reduces packet size
</span></span><span style=display:flex><span>- Avoids fragmentation in network
</span></span></code></pre></div><h3 id="53-routing">5.3 Routing</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Routing table lookup:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ip route show
</span></span><span style=display:flex><span>default via 192.168.1.1 dev eth0
</span></span><span style=display:flex><span>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100
</span></span><span style=display:flex><span>10.0.0.0/8 via 192.168.1.254 dev eth0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For destination 10.5.3.2:
</span></span><span style=display:flex><span>1. Check most specific matching prefix
</span></span><span style=display:flex><span>2. 10.0.0.0/8 matches (8 bits)
</span></span><span style=display:flex><span>3. Next hop: 192.168.1.254 via eth0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Routing decision in kernel:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                   Packet arrives                         │
</span></span><span style=display:flex><span>│                         │                                │
</span></span><span style=display:flex><span>│                         ▼                                │
</span></span><span style=display:flex><span>│              ┌───────────────────┐                       │
</span></span><span style=display:flex><span>│              │ Is dest local?    │                       │
</span></span><span style=display:flex><span>│              └─────────┬─────────┘                       │
</span></span><span style=display:flex><span>│                 Yes    │    No                           │
</span></span><span style=display:flex><span>│              ┌─────────┴─────────┐                       │
</span></span><span style=display:flex><span>│              ▼                   ▼                       │
</span></span><span style=display:flex><span>│     Deliver locally      Route lookup                    │
</span></span><span style=display:flex><span>│     (pass up stack)      (forward out interface)         │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="54-arp-address-resolution">5.4 ARP: Address Resolution</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Mapping IP addresses to MAC addresses:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Host wants to send to 192.168.1.1:
</span></span><span style=display:flex><span>1. Check ARP cache: ip neigh show
</span></span><span style=display:flex><span>2. If not found, broadcast ARP request:
</span></span><span style=display:flex><span>   &#34;Who has 192.168.1.1? Tell 192.168.1.100&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Owner responds (unicast):
</span></span><span style=display:flex><span>   &#34;192.168.1.1 is at aa:bb:cc:dd:ee:ff&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Cache the mapping, send packet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ARP cache:
</span></span><span style=display:flex><span>$ ip neigh show
</span></span><span style=display:flex><span>192.168.1.1 dev eth0 lladdr aa:bb:cc:dd:ee:ff REACHABLE
</span></span><span style=display:flex><span>192.168.1.50 dev eth0 lladdr 11:22:33:44:55:66 STALE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>States:
</span></span><span style=display:flex><span>- REACHABLE: Recently confirmed
</span></span><span style=display:flex><span>- STALE: May need refresh
</span></span><span style=display:flex><span>- INCOMPLETE: ARP request sent, waiting
</span></span><span style=display:flex><span>- FAILED: No response received
</span></span></code></pre></div><h2 id="6-udp-the-simple-alternative">6. UDP: The Simple Alternative</h2><p>When you don&rsquo;t need TCP&rsquo;s guarantees.</p><h3 id="61-udp-characteristics">6.1 UDP Characteristics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>UDP Header (8 bytes only!):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│       Source Port        │      Destination Port        │
</span></span><span style=display:flex><span>├──────────────────────────┼──────────────────────────────┤
</span></span><span style=display:flex><span>│          Length          │         Checksum             │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>UDP provides:
</span></span><span style=display:flex><span>✓ Multiplexing (ports)
</span></span><span style=display:flex><span>✓ Optional checksum
</span></span><span style=display:flex><span>✗ No connection setup
</span></span><span style=display:flex><span>✗ No reliability (no retransmission)
</span></span><span style=display:flex><span>✗ No ordering guarantee
</span></span><span style=display:flex><span>✗ No flow control
</span></span><span style=display:flex><span>✗ No congestion control
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>UDP code:
</span></span><span style=display:flex><span>int sock = socket(AF_INET, SOCK_DGRAM, 0);  // DGRAM = UDP
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// No connect needed (but can use connect for default dest)
</span></span><span style=display:flex><span>sendto(sock, data, len, 0, &amp;dest_addr, addr_len);
</span></span><span style=display:flex><span>recvfrom(sock, buf, size, 0, &amp;src_addr, &amp;addr_len);
</span></span></code></pre></div><h3 id="62-when-to-use-udp">6.2 When to Use UDP</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Good use cases for UDP:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DNS queries:
</span></span><span style=display:flex><span>- Small request/response
</span></span><span style=display:flex><span>- Timeout and retry at application level
</span></span><span style=display:flex><span>- Connection setup overhead &gt; actual data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Video/audio streaming:
</span></span><span style=display:flex><span>- Real-time, can&#39;t wait for retransmissions
</span></span><span style=display:flex><span>- Missing frame less bad than delayed frame
</span></span><span style=display:flex><span>- Application handles packet loss gracefully
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Gaming:
</span></span><span style=display:flex><span>- Low latency critical
</span></span><span style=display:flex><span>- Old state updates can be skipped
</span></span><span style=display:flex><span>- Game protocol handles reliability if needed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>QUIC (HTTP/3):
</span></span><span style=display:flex><span>- UDP-based transport
</span></span><span style=display:flex><span>- Implements reliability on top
</span></span><span style=display:flex><span>- Avoids TCP head-of-line blocking
</span></span><span style=display:flex><span>- Faster connection establishment
</span></span></code></pre></div><h3 id="63-udp-reliability-when-needed">6.3 UDP Reliability When Needed</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Building reliability on UDP:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Application-level acknowledgment:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  struct packet {                                        │
</span></span><span style=display:flex><span>│      uint32_t sequence;    // Packet number             │
</span></span><span style=display:flex><span>│      uint32_t ack;         // What we&#39;ve received       │
</span></span><span style=display:flex><span>│      uint16_t flags;       // Control flags             │
</span></span><span style=display:flex><span>│      uint8_t  data[];      // Payload                   │
</span></span><span style=display:flex><span>│  };                                                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Sender:                                                │
</span></span><span style=display:flex><span>│  - Track sent packets and timestamps                    │
</span></span><span style=display:flex><span>│  - Retransmit if no ACK within timeout                 │
</span></span><span style=display:flex><span>│  - Implement own congestion control                     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Receiver:                                              │
</span></span><span style=display:flex><span>│  - Track received sequence numbers                      │
</span></span><span style=display:flex><span>│  - Reorder if needed                                    │
</span></span><span style=display:flex><span>│  - Send ACKs (possibly with SACK)                      │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Libraries: QUIC, KCP, ENet, Reliable UDP implementations
</span></span></code></pre></div><h3 id="64-multicast-and-broadcast">6.4 Multicast and Broadcast</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>UDP supports one-to-many communication:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Broadcast (same subnet only):
</span></span><span style=display:flex><span>struct sockaddr_in addr;
</span></span><span style=display:flex><span>addr.sin_addr.s_addr = INADDR_BROADCAST;  // 255.255.255.255
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int broadcast = 1;
</span></span><span style=display:flex><span>setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &amp;broadcast, sizeof(broadcast));
</span></span><span style=display:flex><span>sendto(sock, data, len, 0, &amp;addr, sizeof(addr));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Multicast (across networks):
</span></span><span style=display:flex><span>// Join a multicast group
</span></span><span style=display:flex><span>struct ip_mreq mreq;
</span></span><span style=display:flex><span>mreq.imr_multiaddr.s_addr = inet_addr(&#34;239.0.0.1&#34;);
</span></span><span style=display:flex><span>mreq.imr_interface.s_addr = INADDR_ANY;
</span></span><span style=display:flex><span>setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Send to multicast group
</span></span><span style=display:flex><span>struct sockaddr_in mcast_addr;
</span></span><span style=display:flex><span>mcast_addr.sin_addr.s_addr = inet_addr(&#34;239.0.0.1&#34;);
</span></span><span style=display:flex><span>sendto(sock, data, len, 0, &amp;mcast_addr, sizeof(mcast_addr));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use cases:
</span></span><span style=display:flex><span>- Service discovery (mDNS, SSDP)
</span></span><span style=display:flex><span>- Live video/audio streaming
</span></span><span style=display:flex><span>- Financial data feeds
</span></span><span style=display:flex><span>- Cluster heartbeats
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IGMP (Internet Group Management Protocol):
</span></span><span style=display:flex><span>- Hosts tell routers which groups they want
</span></span><span style=display:flex><span>- Routers only forward multicast to interested subnets
</span></span><span style=display:flex><span>- Reduces unnecessary network traffic
</span></span></code></pre></div><h2 id="7-network-performance">7. Network Performance</h2><p>Understanding and optimizing network throughput.</p><h3 id="71-bandwidth-delay-product">7.1 Bandwidth-Delay Product</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>BDP = Bandwidth × Round-Trip Time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Example:
</span></span><span style=display:flex><span>100 Mbps link, 50ms RTT
</span></span><span style=display:flex><span>BDP = 100,000,000 bits/s × 0.050 s = 5,000,000 bits = 625 KB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>What this means:
</span></span><span style=display:flex><span>- 625 KB of data can be &#34;in flight&#34; at any time
</span></span><span style=display:flex><span>- Need send/receive buffers at least this large
</span></span><span style=display:flex><span>- TCP window must be at least BDP for full utilization
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>If buffer &lt; BDP:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Sender                         Receiver                │
</span></span><span style=display:flex><span>│  ┌────────┐                     ┌────────┐             │
</span></span><span style=display:flex><span>│  │ Buffer │─── data ───────────►│ Buffer │             │
</span></span><span style=display:flex><span>│  │ 64 KB  │                     │ 64 KB  │             │
</span></span><span style=display:flex><span>│  └────────┘◄── ACK ─────────────└────────┘             │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  With 625KB BDP but 64KB buffer:                       │
</span></span><span style=display:flex><span>│  Can only send 64KB before waiting for ACK             │
</span></span><span style=display:flex><span>│  Utilization: 64/625 ≈ 10% of available bandwidth!     │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="72-buffer-sizing">7.2 Buffer Sizing</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Socket buffer tuning:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># View current settings
</span></span><span style=display:flex><span>sysctl net.core.rmem_max
</span></span><span style=display:flex><span>sysctl net.core.wmem_max
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_rmem
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_wmem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># tcp_rmem and tcp_wmem: min, default, max
</span></span><span style=display:flex><span>net.ipv4.tcp_rmem = 4096 131072 6291456
</span></span><span style=display:flex><span>net.ipv4.tcp_wmem = 4096 16384 4194304
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Per-socket setting:
</span></span><span style=display:flex><span>int size = 4 * 1024 * 1024;  // 4 MB
</span></span><span style=display:flex><span>setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size));
</span></span><span style=display:flex><span>setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Auto-tuning:
</span></span><span style=display:flex><span>- Linux automatically adjusts buffer sizes
</span></span><span style=display:flex><span>- Based on observed RTT and bandwidth
</span></span><span style=display:flex><span>- Generally leave auto-tuning enabled
</span></span><span style=display:flex><span>- Manual tuning for special cases (high BDP, etc.)
</span></span></code></pre></div><h3 id="73-connection-scalability">7.3 Connection Scalability</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Handling many connections:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>File descriptor limits:
</span></span><span style=display:flex><span>$ ulimit -n    # Soft limit
</span></span><span style=display:flex><span>$ ulimit -Hn   # Hard limit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Raise in /etc/security/limits.conf:
</span></span><span style=display:flex><span>* soft nofile 65535
</span></span><span style=display:flex><span>* hard nofile 65535
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Memory per connection:
</span></span><span style=display:flex><span>- Socket structure: ~2 KB
</span></span><span style=display:flex><span>- Send buffer: 16 KB - 4 MB
</span></span><span style=display:flex><span>- Receive buffer: 4 KB - 6 MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10,000 connections × 200 KB average = 2 GB memory
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Event handling efficiency:
</span></span><span style=display:flex><span>select():  O(n) per call, limited to 1024 fds
</span></span><span style=display:flex><span>poll():    O(n) per call, no fd limit
</span></span><span style=display:flex><span>epoll():   O(1) per event, O(n) setup, scalable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For high connection counts: use epoll (Linux), kqueue (BSD)
</span></span></code></pre></div><h3 id="74-latency-optimization">7.4 Latency Optimization</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Sources of network latency:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Serialization delay: packet_size / bandwidth
</span></span><span style=display:flex><span>   1500 bytes / 1 Gbps = 12 μs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Propagation delay: distance / speed_of_light
</span></span><span style=display:flex><span>   Coast to coast US ≈ 40 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Queuing delay: Waiting in router/switch buffers
</span></span><span style=display:flex><span>   Variable, depends on congestion
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Processing delay: Router/host packet processing
</span></span><span style=display:flex><span>   Usually negligible (~1 μs per hop)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Optimization strategies:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reduce round trips:
</span></span><span style=display:flex><span>- Connection pooling (reuse connections)
</span></span><span style=display:flex><span>- TCP Fast Open (data in SYN)
</span></span><span style=display:flex><span>- HTTP/2 multiplexing (one connection, many requests)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reduce processing:
</span></span><span style=display:flex><span>- Zero-copy where possible
</span></span><span style=display:flex><span>- Kernel bypass (DPDK, io_uring)
</span></span><span style=display:flex><span>- Jumbo frames (reduce packet count)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reduce queuing:
</span></span><span style=display:flex><span>- ECN (Explicit Congestion Notification)
</span></span><span style=display:flex><span>- BBR congestion control
</span></span><span style=display:flex><span>- QoS prioritization
</span></span></code></pre></div><h3 id="75-zero-copy-techniques">7.5 Zero-Copy Techniques</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Avoiding memory copies for high throughput:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traditional send path:
</span></span><span style=display:flex><span>User buffer → Kernel socket buffer → NIC DMA buffer → Wire
</span></span><span style=display:flex><span>(2 copies minimum)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sendfile() - File to socket without user space:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Send file directly to socket                        │
</span></span><span style=display:flex><span>│  sendfile(socket_fd, file_fd, &amp;offset, count);         │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  File → Page cache → NIC DMA (with scatter-gather)     │
</span></span><span style=display:flex><span>│  Avoids: user buffer entirely!                          │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>splice() - Move data between file descriptors:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  // Create pipe for zero-copy transfer                  │
</span></span><span style=display:flex><span>│  int pipefd[2];                                        │
</span></span><span style=display:flex><span>│  pipe(pipefd);                                         │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Move from socket to pipe                           │
</span></span><span style=display:flex><span>│  splice(socket_in, NULL, pipefd[1], NULL, len, 0);     │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  // Move from pipe to file                             │
</span></span><span style=display:flex><span>│  splice(pipefd[0], NULL, file_fd, NULL, len, 0);       │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MSG_ZEROCOPY for sends:
</span></span><span style=display:flex><span>int one = 1;
</span></span><span style=display:flex><span>setsockopt(sock, SOL_SOCKET, SO_ZEROCOPY, &amp;one, sizeof(one));
</span></span><span style=display:flex><span>send(sock, buf, len, MSG_ZEROCOPY);
</span></span><span style=display:flex><span>// Kernel uses page pinning, notifies via error queue when done
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When zero-copy helps:
</span></span><span style=display:flex><span>- Large data transfers (MB+)
</span></span><span style=display:flex><span>- High bandwidth links
</span></span><span style=display:flex><span>- CPU-bound scenarios
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When it doesn&#39;t help:
</span></span><span style=display:flex><span>- Small messages (overhead &gt; savings)
</span></span><span style=display:flex><span>- Already memory-bound
</span></span><span style=display:flex><span>- Latency-critical (may add delay)
</span></span></code></pre></div><h2 id="8-kernel-bypass-and-high-performance">8. Kernel Bypass and High Performance</h2><p>When the kernel isn&rsquo;t fast enough.</p><h3 id="81-the-kernel-overhead-problem">8.1 The Kernel Overhead Problem</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Traditional network path:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NIC → DMA to kernel buffer → Interrupt → softirq processing →
</span></span><span style=display:flex><span>Protocol processing → Copy to user buffer → Wake application
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Overhead sources:
</span></span><span style=display:flex><span>1. Interrupts: 5-15 μs each
</span></span><span style=display:flex><span>2. Context switches: 1-10 μs
</span></span><span style=display:flex><span>3. Memory copies: Bandwidth limited
</span></span><span style=display:flex><span>4. System calls: ~100 ns each
</span></span><span style=display:flex><span>5. Protocol processing: CPU time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For 10-100 Gbps: Kernel can&#39;t keep up!
</span></span></code></pre></div><h3 id="82-dpdk-data-plane-development-kit">8.2 DPDK: Data Plane Development Kit</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>DPDK approach:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>User space                  Kernel space
</span></span><span style=display:flex><span>┌──────────────────────┐   ┌──────────────────┐
</span></span><span style=display:flex><span>│   DPDK Application   │   │   (bypassed)     │
</span></span><span style=display:flex><span>│   ┌──────────────┐   │   │                  │
</span></span><span style=display:flex><span>│   │ Poll Mode    │   │   │                  │
</span></span><span style=display:flex><span>│   │ Driver       │   │   │                  │
</span></span><span style=display:flex><span>│   └──────┬───────┘   │   │                  │
</span></span><span style=display:flex><span>└──────────┼───────────┘   └──────────────────┘
</span></span><span style=display:flex><span>           │ Direct access via huge pages
</span></span><span style=display:flex><span>           ▼
</span></span><span style=display:flex><span>      ┌──────────┐
</span></span><span style=display:flex><span>      │   NIC    │
</span></span><span style=display:flex><span>      └──────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benefits:
</span></span><span style=display:flex><span>- Zero kernel involvement
</span></span><span style=display:flex><span>- No interrupts (busy polling)
</span></span><span style=display:flex><span>- No memory copies (zero-copy)
</span></span><span style=display:flex><span>- Millions of packets per second per core
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Costs:
</span></span><span style=display:flex><span>- Dedicated cores (100% CPU polling)
</span></span><span style=display:flex><span>- Must implement protocols
</span></span><span style=display:flex><span>- Lose kernel features (iptables, etc.)
</span></span><span style=display:flex><span>- Complex programming model
</span></span></code></pre></div><h3 id="83-io_uring-for-networking">8.3 io_uring for Networking</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>io_uring: Async I/O with kernel involvement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Submission Queue              Completion Queue
</span></span><span style=display:flex><span>┌─────────────┐              ┌─────────────┐
</span></span><span style=display:flex><span>│   Entry 0   │              │  Result 0   │
</span></span><span style=display:flex><span>│   Entry 1   │   ───────►   │  Result 1   │
</span></span><span style=display:flex><span>│   Entry 2   │   Kernel     │  Result 2   │
</span></span><span style=display:flex><span>└─────────────┘   process    └─────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Advantages for networking:
</span></span><span style=display:flex><span>- Batched system calls (fewer context switches)
</span></span><span style=display:flex><span>- Zero-copy send/receive
</span></span><span style=display:flex><span>- Registered buffers (avoid allocation)
</span></span><span style=display:flex><span>- Linked operations (chains of I/O)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Submit multiple operations at once
</span></span><span style=display:flex><span>io_uring_prep_recv(sqe1, sock1, buf1, len1, 0);
</span></span><span style=display:flex><span>io_uring_prep_recv(sqe2, sock2, buf2, len2, 0);
</span></span><span style=display:flex><span>io_uring_prep_send(sqe3, sock3, buf3, len3, 0);
</span></span><span style=display:flex><span>io_uring_submit(&amp;ring);  // One syscall for three operations
</span></span></code></pre></div><h3 id="84-xdp-express-data-path">8.4 XDP: eXpress Data Path</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>XDP: eBPF programs at NIC driver level
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Packet arrives at NIC:
</span></span><span style=display:flex><span>        │
</span></span><span style=display:flex><span>        ▼
</span></span><span style=display:flex><span>┌───────────────────────┐
</span></span><span style=display:flex><span>│   XDP Program (eBPF)  │
</span></span><span style=display:flex><span>│                       │
</span></span><span style=display:flex><span>│   Decision:           │
</span></span><span style=display:flex><span>│   - XDP_DROP         │ ← Drop packet (fastest)
</span></span><span style=display:flex><span>│   - XDP_PASS         │ ← Normal kernel processing
</span></span><span style=display:flex><span>│   - XDP_TX           │ ← Bounce back out same NIC
</span></span><span style=display:flex><span>│   - XDP_REDIRECT     │ ← Send to different NIC/CPU
</span></span><span style=display:flex><span>└───────────────────────┘
</span></span><span style=display:flex><span>        │
</span></span><span style=display:flex><span>    (if PASS)
</span></span><span style=display:flex><span>        ▼
</span></span><span style=display:flex><span>   Normal stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use cases:
</span></span><span style=display:flex><span>- DDoS mitigation (drop bad packets early)
</span></span><span style=display:flex><span>- Load balancing
</span></span><span style=display:flex><span>- Packet filtering
</span></span><span style=display:flex><span>- Fast forwarding
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance: Millions of packets per second
</span></span></code></pre></div><h2 id="9-observability-and-debugging">9. Observability and Debugging</h2><p>Tools for understanding network behavior.</p><h3 id="91-socket-statistics">9.1 Socket Statistics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Connection state summary</span>
</span></span><span style=display:flex><span>ss -s
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Total: 1024 (kernel 0)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># TCP:   500 (estab 400, closed 50, orphaned 10, timewait 30)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># All TCP connections with details</span>
</span></span><span style=display:flex><span>ss -tan
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># State   Recv-Q Send-Q Local:Port   Peer:Port</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># ESTAB   0      0      10.0.0.1:443 10.0.0.2:54321</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Show socket memory usage</span>
</span></span><span style=display:flex><span>ss -tm
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Includes: skmem:(r,rb,t,tb,f,w,o,bl,d)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># r: receive queue, t: send queue, etc.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Filter by state</span>
</span></span><span style=display:flex><span>ss -tan state established <span style=color:#a5d6ff>&#39;( dport = :443 )&#39;</span>
</span></span></code></pre></div><h3 id="92-network-statistics">9.2 Network Statistics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Interface statistics</span>
</span></span><span style=display:flex><span>ip -s link show eth0
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># RX: bytes packets errors dropped</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># TX: bytes packets errors dropped</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Protocol statistics</span>
</span></span><span style=display:flex><span>netstat -s
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># IP, TCP, UDP, ICMP statistics</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Detailed TCP stats</span>
</span></span><span style=display:flex><span>cat /proc/net/tcp
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Or parsed: ss --info</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Real-time monitoring</span>
</span></span><span style=display:flex><span>sar -n DEV <span style=color:#a5d6ff>1</span>    <span style=color:#8b949e;font-style:italic># Per-interface</span>
</span></span><span style=display:flex><span>sar -n TCP <span style=color:#a5d6ff>1</span>    <span style=color:#8b949e;font-style:italic># TCP stats</span>
</span></span></code></pre></div><h3 id="93-packet-capture">9.3 Packet Capture</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># tcpdump: Command-line capture</span>
</span></span><span style=display:flex><span>tcpdump -i eth0 port <span style=color:#a5d6ff>80</span>
</span></span><span style=display:flex><span>tcpdump -i any tcp and host 192.168.1.1
</span></span><span style=display:flex><span>tcpdump -w capture.pcap  <span style=color:#8b949e;font-style:italic># Save to file</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Wireshark: GUI analysis</span>
</span></span><span style=display:flex><span>wireshark capture.pcap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># tshark: Wireshark CLI</span>
</span></span><span style=display:flex><span>tshark -i eth0 -f <span style=color:#a5d6ff>&#34;port 443&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># BPF-based tracing</span>
</span></span><span style=display:flex><span>tcpdump <span style=color:#a5d6ff>&#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39;</span>  <span style=color:#8b949e;font-style:italic># SYN packets</span>
</span></span></code></pre></div><h3 id="94-connection-tracing">9.4 Connection Tracing</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># strace for socket operations</span>
</span></span><span style=display:flex><span>strace -e network ./app
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Shows: socket, bind, connect, send, recv, etc.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># bpftrace for kernel events</span>
</span></span><span style=display:flex><span>bpftrace -e <span style=color:#a5d6ff>&#39;tracepoint:tcp:tcp_retransmit_skb {
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    printf(&#34;Retransmit: %s:%d\n&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>           ntop(args-&gt;saddr), args-&gt;dport);
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># ss for real-time connection info</span>
</span></span><span style=display:flex><span>watch -n1 <span style=color:#a5d6ff>&#39;ss -tan | grep ESTAB&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># conntrack for NAT tracking</span>
</span></span><span style=display:flex><span>conntrack -L
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Shows all tracked connections through NAT</span>
</span></span></code></pre></div><h3 id="95-performance-profiling">9.5 Performance Profiling</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Identifying network bottlenecks:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bandwidth testing:
</span></span><span style=display:flex><span>iperf3 -s                    # Server
</span></span><span style=display:flex><span>iperf3 -c server_ip -t 30    # Client, 30 second test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Results show:
</span></span><span style=display:flex><span>- Throughput (Mbps or Gbps)
</span></span><span style=display:flex><span>- Retransmits (TCP reliability issues)
</span></span><span style=display:flex><span>- CPU usage (processing bottleneck)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency measurement:
</span></span><span style=display:flex><span>ping -c 100 host             # Basic RTT
</span></span><span style=display:flex><span>mtr host                     # Traceroute with statistics
</span></span><span style=display:flex><span>hping3 -S -p 80 host         # TCP-based latency
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Connection timing breakdown:
</span></span><span style=display:flex><span>curl -w &#34;@timing.txt&#34; https://example.com -o /dev/null
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>timing.txt:
</span></span><span style=display:flex><span>time_namelookup:  %{time_namelookup}s
</span></span><span style=display:flex><span>time_connect:     %{time_connect}s
</span></span><span style=display:flex><span>time_appconnect:  %{time_appconnect}s (TLS)
</span></span><span style=display:flex><span>time_pretransfer: %{time_pretransfer}s
</span></span><span style=display:flex><span>time_starttransfer: %{time_starttransfer}s (first byte)
</span></span><span style=display:flex><span>time_total:       %{time_total}s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Flame graphs for network code:
</span></span><span style=display:flex><span>perf record -g ./network_app
</span></span><span style=display:flex><span>perf script | stackcollapse.pl | flamegraph.pl &gt; flame.svg
</span></span><span style=display:flex><span># Shows where CPU time goes in network processing
</span></span></code></pre></div><h2 id="10-summary-and-best-practices">10. Summary and Best Practices</h2><p>Key concepts and practical guidance.</p><h3 id="101-core-concepts-review">10.1 Core Concepts Review</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Socket fundamentals:
</span></span><span style=display:flex><span>✓ Sockets are file descriptors with network operations
</span></span><span style=display:flex><span>✓ TCP provides reliable, ordered, connection-oriented streams
</span></span><span style=display:flex><span>✓ UDP provides unreliable, unordered, connectionless datagrams
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TCP mechanics:
</span></span><span style=display:flex><span>✓ Three-way handshake establishes connection
</span></span><span style=display:flex><span>✓ Sequence numbers enable ordering and reliability
</span></span><span style=display:flex><span>✓ Flow control prevents receiver overload
</span></span><span style=display:flex><span>✓ Congestion control prevents network overload
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance factors:
</span></span><span style=display:flex><span>✓ Bandwidth-delay product determines buffer needs
</span></span><span style=display:flex><span>✓ RTT affects throughput (must wait for ACKs)
</span></span><span style=display:flex><span>✓ Connection reuse avoids handshake overhead
</span></span><span style=display:flex><span>✓ Kernel bypass for extreme performance
</span></span></code></pre></div><h3 id="102-practical-guidelines">10.2 Practical Guidelines</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>For application developers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Use connection pooling
</span></span><span style=display:flex><span>   - Reuse connections when possible
</span></span><span style=display:flex><span>   - Avoid setup/teardown overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Set TCP_NODELAY for interactive protocols
</span></span><span style=display:flex><span>   - Avoids Nagle delay for small messages
</span></span><span style=display:flex><span>   - Essential for request-response patterns
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Handle partial reads and writes
</span></span><span style=display:flex><span>   - read() may return less than requested
</span></span><span style=display:flex><span>   - Loop until complete or EOF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Use non-blocking I/O with event loops
</span></span><span style=display:flex><span>   - Scales to many connections
</span></span><span style=display:flex><span>   - epoll on Linux, kqueue on BSD
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. Set appropriate timeouts
</span></span><span style=display:flex><span>   - Connection timeout
</span></span><span style=display:flex><span>   - Read/write timeouts
</span></span><span style=display:flex><span>   - Keepalive for idle connections
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For system administrators:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Monitor connection states
</span></span><span style=display:flex><span>   - Many TIME_WAIT = rapid connection churn
</span></span><span style=display:flex><span>   - Many SYN_RECV = possible SYN flood
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Tune buffer sizes for high BDP
</span></span><span style=display:flex><span>   - Increase tcp_rmem/tcp_wmem max
</span></span><span style=display:flex><span>   - Let auto-tuning work
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Choose appropriate congestion control
</span></span><span style=display:flex><span>   - BBR for high latency links
</span></span><span style=display:flex><span>   - CUBIC for general use
</span></span></code></pre></div><h3 id="103-debugging-checklist">10.3 Debugging Checklist</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>When investigating network issues:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>□ Check connection state (ss -tan)
</span></span><span style=display:flex><span>□ Verify routing (ip route get &lt;dest&gt;)
</span></span><span style=display:flex><span>□ Test connectivity (ping, traceroute)
</span></span><span style=display:flex><span>□ Check for packet loss (netstat -s | grep retrans)
</span></span><span style=display:flex><span>□ Verify DNS resolution (dig, nslookup)
</span></span><span style=display:flex><span>□ Capture packets (tcpdump) if needed
</span></span><span style=display:flex><span>□ Check firewall rules (iptables -L)
</span></span><span style=display:flex><span>□ Monitor bandwidth utilization
</span></span><span style=display:flex><span>□ Check for buffer overflows (netstat -s)
</span></span><span style=display:flex><span>□ Review application logs for timeouts
</span></span><span style=display:flex><span>□ Examine socket options and buffer sizes
</span></span><span style=display:flex><span>□ Profile CPU usage during network operations
</span></span><span style=display:flex><span>□ Check for connection leaks (increasing fd count)
</span></span><span style=display:flex><span>□ Verify MTU settings match across path
</span></span><span style=display:flex><span>□ Test with different congestion control algorithms
</span></span></code></pre></div><h3 id="104-security-considerations">10.4 Security Considerations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Network security fundamentals:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Socket-level protection:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Bind to specific interfaces:                           │
</span></span><span style=display:flex><span>│  - INADDR_LOOPBACK for local-only services             │
</span></span><span style=display:flex><span>│  - Specific IP for multi-homed hosts                   │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Set socket options:                                    │
</span></span><span style=display:flex><span>│  - SO_REUSEADDR carefully (can mask issues)           │
</span></span><span style=display:flex><span>│  - TCP_DEFER_ACCEPT (delay accept until data)         │
</span></span><span style=display:flex><span>│                                                         │
</span></span><span style=display:flex><span>│  Validate client addresses:                             │
</span></span><span style=display:flex><span>│  - Check source IP/port in accept()                    │
</span></span><span style=display:flex><span>│  - Implement connection rate limiting                  │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Common attack vectors:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SYN Flood:
</span></span><span style=display:flex><span>- Attacker sends many SYNs, never completes handshake
</span></span><span style=display:flex><span>- Fills SYN queue, prevents legitimate connections
</span></span><span style=display:flex><span>- Mitigation: SYN cookies, increase backlog, rate limiting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TCP Reset Attacks:
</span></span><span style=display:flex><span>- Inject RST packets to close connections
</span></span><span style=display:flex><span>- Requires guessing sequence numbers
</span></span><span style=display:flex><span>- Mitigation: Randomized ISN, TCP-AO authentication
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Connection Hijacking:
</span></span><span style=display:flex><span>- Predict sequence numbers to inject data
</span></span><span style=display:flex><span>- Modern TCP uses random ISN to prevent
</span></span><span style=display:flex><span>- Mitigation: TLS for application-layer security
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Slow Read/Slowloris:
</span></span><span style=display:flex><span>- Attacker reads data very slowly
</span></span><span style=display:flex><span>- Ties up server resources
</span></span><span style=display:flex><span>- Mitigation: Timeouts, connection limits
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Kernel hardening:
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_syncookies=1          # SYN flood protection
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_max_syn_backlog=4096  # Larger SYN queue
</span></span><span style=display:flex><span>sysctl net.core.somaxconn=4096            # Larger accept queue
</span></span></code></pre></div><p>Network programming bridges the gap between application logic and the physical reality of data transmission across wires and through the air. From the elegant abstraction of sockets through the intricate state machines of TCP to the raw speed of kernel bypass techniques, the network stack represents decades of engineering refinement. Understanding these internals empowers you to build efficient networked applications, diagnose mysterious connectivity problems, and optimize for the specific characteristics of your network environment. Whether you&rsquo;re building real-time systems demanding microsecond latencies or web services handling millions of connections, the principles of the TCP/IP stack inform every packet that crosses the wire.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/fundamentals/>fundamentals</a>, <a href=/categories/systems/>systems</a></div><div>Tags:
<a href=/tags/networking/>#networking</a>, <a href=/tags/tcp-ip/>#tcp-ip</a>, <a href=/tags/sockets/>#sockets</a>, <a href=/tags/kernel/>#kernel</a>, <a href=/tags/protocols/>#protocols</a>, <a href=/tags/fundamentals/>#fundamentals</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>