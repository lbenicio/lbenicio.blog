<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>File Systems and Storage Internals: How Data Persists on Disk · Leonardo Benicio</title><meta name=description content="A comprehensive exploration of file system architecture, from inodes and directories to journaling and copy-on-write. Understand how operating systems organize, protect, and efficiently access persistent data."><link rel=alternate type=application/rss+xml title=RSS href=https://lbenicio.dev/index.xml><link rel=canonical href=https://blog.lbenicio.dev/blog/file-systems-and-storage-internals-how-data-persists-on-disk/><link rel=preload href=/static/fonts/OpenSans-Regular.ttf as=font type=font/ttf crossorigin><link rel="stylesheet" href="/assets/css/fonts.min.40e2054b739ac45a0f9c940f4b44ec00c3b372356ebf61440a413c0337c5512e.css" crossorigin="anonymous" integrity="sha256-QOIFS3OaxFoPnJQPS0TsAMOzcjVuv2FECkE8AzfFUS4="><link rel="shortcut icon" href=/static/assets/favicon/favicon.ico><link rel=icon type=image/x-icon href=/static/assets/favicon/favicon.ico><link rel=icon href=/static/assets/favicon/favicon.svg type=image/svg+xml><link rel=icon href=/static/assets/favicon/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/static/assets/favicon/favicon-16x16.png sizes=16x16 type=image/png><link rel=apple-touch-icon href=/static/assets/favicon/apple-touch-icon.png><link rel=manifest href=/static/assets/favicon/site.webmanifest><link rel=mask-icon href=/static/assets/favicon/safari-pinned-tab.svg color=#209cee><meta name=msapplication-TileColor content="#209cee"><meta name=msapplication-config content="/static/assets/favicon/browserconfig.xml"><meta name=theme-color content="#d2e9f8"><meta property="og:title" content="File Systems and Storage Internals: How Data Persists on Disk · Leonardo Benicio"><meta property="og:description" content="A comprehensive exploration of file system architecture, from inodes and directories to journaling and copy-on-write. Understand how operating systems organize, protect, and efficiently access persistent data."><meta property="og:url" content="https://blog.lbenicio.dev/blog/file-systems-and-storage-internals-how-data-persists-on-disk/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.lbenicio.dev/static/assets/images/blog/file-systems-storage-internals-disk.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="File Systems and Storage Internals: How Data Persists on Disk · Leonardo Benicio"><meta name=twitter:description content="A comprehensive exploration of file system architecture, from inodes and directories to journaling and copy-on-write. Understand how operating systems organize, protect, and efficiently access persistent data."><meta name=twitter:site content="@lbenicio_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"About Leonardo Benicio","url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"Leonardo Benicio","sameAs":["https://github.com/lbenicio","https://www.linkedin.com/in/leonardo-benicio","https://twitter.com/lbenicio_"],"url":"https://blog.lbenicio.dev"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.lbenicio.dev/","name":"Blog","position":2},{"@type":"ListItem","item":"https://blog.lbenicio.dev/blog/file-systems-and-storage-internals-how-data-persists-on-disk/","name":"File Systems and Storage Internals How Data Persists on Disk","position":3}]}</script><link rel="stylesheet" href="/assets/css/main.min.1e8a566ac8bc3f0664d0db4ec8a015b07421c33fa11d336a6b914522a9cabf30.css" crossorigin="anonymous" integrity="sha256-6lhUOpwCHMSMROmggsVSp3AHKud6gBrIFGTzl3GV4BY="></head><body class="c6942b3 c03620d cf3bd2e"><script>(function(){try{document.addEventListener("gesturestart",function(e){e.preventDefault()}),document.addEventListener("touchstart",function(e){e.touches&&e.touches.length>1&&e.preventDefault()},{passive:!1});var e=0;document.addEventListener("touchend",function(t){var n=Date.now();n-e<=300&&t.preventDefault(),e=n},{passive:!1})}catch{}})()</script><a href=#content class="cba5854 c21e770 caffa6e cc5f604 cf2c31d cdd44dd c10dda9 c43876e c787e9b cddc2d2 cf55a7b c6dfb1e c9391e2">Skip to content</a>
<script>(function(){try{const e=localStorage.getItem("theme");e==="dark"&&document.documentElement.classList.add("dark");const t=document.querySelector('button[aria-label="Toggle theme"]');t&&t.setAttribute("aria-pressed",String(e==="dark"))}catch{}})();function toggleTheme(e){const s=document.documentElement,t=s.classList.toggle("dark");try{localStorage.setItem("theme",t?"dark":"light")}catch{}try{var n=e&&e.nodeType===1?e:document.querySelector('button[aria-label="Toggle theme"]');n&&n.setAttribute("aria-pressed",String(!!t))}catch{}}(function(){function e(){try{return document.documentElement.classList.contains("dark")?"dark":"light"}catch{return"light"}}function n(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(0)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!1,s.style.display="block"}catch{}o.setAttribute("aria-expanded","true"),n.setAttribute("aria-hidden","false");try{document.body.classList.add("c150bbe")}catch{}const i=document.getElementById("i190984");i&&i.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_open",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function t(t){const n=document.getElementById("i98aca2"),s=document.getElementById("iad2af0"),o=document.getElementById("i975fb5");if(!n||!s||!o)return;try{n.style.transform="translateX(100%)",n.style.transition||(n.style.transition="transform 200ms ease-out")}catch{}try{s.hidden=!0,s.style.display="none"}catch{}o.setAttribute("aria-expanded","false"),n.setAttribute("aria-hidden","true");try{document.body.classList.remove("c150bbe")}catch{}o.focus();try{window.umami&&typeof window.umami.track=="function"&&window.umami.track("mobile_menu_close",{page:location.pathname,theme:e(),source:t||"programmatic"})}catch{}}function s(e){e.key==="Escape"&&t("escape")}window.__openMobileMenu=n,window.__closeMobileMenu=t;try{window.addEventListener("keydown",s,!0)}catch{}})()</script><header class="cd019ba c98dfae cdd44dd cfdda01 c9ee25d ce2dc7a cd72dd7 cc0dc37" role=banner><div class="cfdda01 c6942b3 ccf47f4 c7c11d8"><a href=/ class="c87e2b0 c6942b3 c7c11d8 c1838fa cb594e4" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=32 height=32 class="c3de71a c4d5191">
<span class="cf8f011 c4d1253 cbd72bc cd7e69e">Leonardo Benicio</span></a><div class="c6942b3 c85cbd4 c7c11d8 ca798da c1838fa c7a0580"><nav class="cc1689c cd9b445 c75065d c04bab1" aria-label=Main><a href=/ class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Home</a>
<a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">About</a>
<a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Timeline</a>
<a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Reading</a>
<a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Publications</a>
<a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c4d1253 c9e4539 cbbda39 c01f421 c19ee42 c3ecea6">Contact</a></nav><button id="i1d73d4" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 c097fa1 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" onclick=toggleTheme(this) aria-label="Toggle theme" aria-pressed=false title="Toggle theme">
<svg class="cb26e41 c50ceea cb69a5c c4f45c8 c8c2c40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg class="cb26e41 c8fca2b cb69a5c c4f45c8 cc1689c c9c27ff" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M6.34 17.66l2.83-2.83"/><path d="M14.83 9.17l2.83-2.83"/></svg>
<span class="cba5854">Toggle theme</span></button><div class="c658bcf c097fa1"><button id="i975fb5" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c8e184d c514027 c88daee c7a66a6 cfc01c7 c286dd7 c2bd687 cfdce1d cfef18f" aria-label="Open menu" aria-controls="i98aca2" aria-expanded=false onclick='window.__openMobileMenu("button")' data-d38f920=mobile_menu_open_click>
<svg class="c20e4eb cb58471" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
<span class="cba5854">Open menu</span></button></div></div></div></header><div id="iad2af0" class="caffa6e ce4b5f4 c14639a" style=background-color:hsl(var(--background)) hidden onclick='window.__closeMobileMenu("overlay")' data-d38f920=mobile_menu_overlay_click></div><aside id="i98aca2" class="caffa6e c9efbc5 c437fa9 c49e97e c6c6936 c7cacca c7b34a4 c787e9b c88daee cad071a c6942b3 c03620d" role=dialog aria-modal=true aria-hidden=true aria-label="Mobile navigation" style="transform:translateX(100%);transition:transform 200ms ease-out;will-change:transform"><div class="c6942b3 c7c11d8 c82c52d c5df473 ccf47f4 c9ee25d"><a href=/ class="c6942b3 c7c11d8 c1838fa" aria-label=Home><img src=/static/assets/favicon/favicon.svg alt=Logo width=24 height=24 class="c20e4eb cb58471">
<span class="c62aaf0 c7c1b66 cbd72bc">Leonardo Benicio</span>
</a><button id="i190984" type=button class="c1d6c20 c81ac7c c6a899b c7c11d8 c1d0018 c10dda9 c514027 c286dd7 c2bd687 cfdce1d" aria-label="Close menu" onclick='window.__closeMobileMenu("button")' data-d38f920=mobile_menu_close_click>
<svg class="c16e528 c61f467" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
<span class="cba5854">Close</span></button></div><nav class="c85cbd4 ca0eaa4 c5df473 c6689b9"><ul class="cd69733"><li><a href=/ class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Home</a></li><li><a href=https://lbenicio.dev/about target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>About</a></li><li><a href=https://lbenicio.dev/timeline target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Timeline</a></li><li><a href=https://lbenicio.dev/reading target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Reading</a></li><li><a href=https://publications.lbenicio.dev target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Publications</a></li><li><a href=https://lbenicio.dev/contact target=_blank rel="noopener noreferrer" class="c3b5299 c10dda9 cddc2d2 cf55a7b c7c1b66 cbbda39 c3ecea6 c19ee42 c514027" onclick=window.__closeMobileMenu()>Contact</a></li></ul></nav><div class="c60a4cc ccdf0e8 c277478 c13044e"><p>&copy; 2026 Leonardo Benicio</p></div></aside><div class="caffa6e c437fa9 ce9aced c97bba6 c15da2a c975cba" role=complementary aria-label="GitHub repository"><div class="c9d056d c252f85 ca22532 ca88a1a c876315"><div class="c6942b3 c7c11d8 c1d0018 cd1fd22 c6066e4 c43876e ce3d5b6 caa20d2 c3ecea6 c0cd2e2 cddc2d2 c3ed5c9 cd4074c c876315"><a href=https://github.com/lbenicio/aboutme target=_blank rel="noopener noreferrer" class="c6942b3 c7c11d8 cd1fd22 c71bae8 cfac1ac c19ee42 c25dc7c cb40739 cbbda39 cf55a7b" aria-label="View source on GitHub"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cb26e41 c41bcd4 cf17690 cfa4e34 c78d562" aria-hidden="true"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
<span class="cb5c327 cd7e69e">Fork me</span></a></div></div></div><main id="i7eccc0" class="cfdda01 c5df473 c0eecc8 c85cbd4" role=main aria-label=Content><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">File Systems and Storage Internals How Data Persists on Disk</span></li></ol></nav><article class="c461ba0 c1c203f cfb6084 c995404 c6ca165"><nav class="cb545ce c8d8ae4 c277478" aria-label=Breadcrumb><ol class="c6942b3 c3adaf2 c7c11d8 cd365ee c3ecea6"><li><a href=/ class="c19ee42 c71bae8 cfac1ac">Home</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><a href=/ class="c19ee42 c71bae8 cfac1ac">Blog</a></li><li class="c6942b3 c7c11d8 cd365ee"><span class="cb82ddd">/</span><span class="c88daee">File Systems and Storage Internals How Data Persists on Disk</span></li></ol></nav><header class="c8aedc7"><h1 class="cf304bc c6fb0fe cf8f011 cc484e1">File Systems and Storage Internals: How Data Persists on Disk</h1><div class="c277478 c3ecea6 c8fb24a">2023-09-22
· Leonardo Benicio</div><div class="c1a1a3f c8124f2"><img src=/static/assets/images/blog/file-systems-storage-internals-disk.png alt class="cfdda01 c524300 c677556"></div><p class="lead c3ecea6">A comprehensive exploration of file system architecture, from inodes and directories to journaling and copy-on-write. Understand how operating systems organize, protect, and efficiently access persistent data.</p></header><div class="content"><p>Every file you save, every application you install, every database record—all must survive power failures and system crashes. File systems provide this durability guarantee while making storage appear as a simple hierarchy of named files and directories. Behind this abstraction lies sophisticated machinery for organizing billions of bytes, recovering from failures, and optimizing access patterns. Understanding file system internals illuminates why some operations are fast and others slow, why disks fill up unexpectedly, and how your data survives the unexpected.</p><h2 id="1-the-storage-stack">1. The Storage Stack</h2><p>Before examining file systems, let&rsquo;s understand the full storage hierarchy.</p><h3 id="11-layers-of-abstraction">1.1 Layers of Abstraction</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Application Layer:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  open(&#34;/home/user/data.txt&#34;, O_RDWR)               │
</span></span><span style=display:flex><span>│  read(fd, buffer, 4096)                            │
</span></span><span style=display:flex><span>│  write(fd, buffer, 4096)                           │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>                        │
</span></span><span style=display:flex><span>                        ▼
</span></span><span style=display:flex><span>VFS (Virtual File System):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Unified interface for all file systems            │
</span></span><span style=display:flex><span>│  inode cache, dentry cache, page cache             │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>                        │
</span></span><span style=display:flex><span>                        ▼
</span></span><span style=display:flex><span>File System (ext4, XFS, btrfs):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Files → blocks mapping                            │
</span></span><span style=display:flex><span>│  Directories, permissions, journaling              │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>                        │
</span></span><span style=display:flex><span>                        ▼
</span></span><span style=display:flex><span>Block Layer:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  I/O scheduling, request merging                   │
</span></span><span style=display:flex><span>│  Block device abstraction                          │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>                        │
</span></span><span style=display:flex><span>                        ▼
</span></span><span style=display:flex><span>Device Driver:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  SATA, NVMe, SCSI protocols                        │
</span></span><span style=display:flex><span>│  Hardware-specific commands                        │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>                        │
</span></span><span style=display:flex><span>                        ▼
</span></span><span style=display:flex><span>Physical Storage:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  HDD: Spinning platters, seek time, rotational     │
</span></span><span style=display:flex><span>│  SSD: Flash cells, FTL, wear leveling             │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span></code></pre></div><h3 id="12-block-devices">1.2 Block Devices</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Storage devices expose fixed-size blocks:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traditional block size: 512 bytes (sector)
</span></span><span style=display:flex><span>Modern devices: 4096 bytes (4K native)
</span></span><span style=display:flex><span>File system block: Usually 4096 bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Block addressing:
</span></span><span style=display:flex><span>┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>│  0  │  1  │  2  │  3  │  4  │  5  │  6  │ ... │
</span></span><span style=display:flex><span>└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</span></span><span style=display:flex><span>  4KB   4KB   4KB   4KB   4KB   4KB   4KB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Device capacity = block count × block size
</span></span><span style=display:flex><span>1TB drive with 4KB blocks = ~244 million blocks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Operations:
</span></span><span style=display:flex><span>- Read block N
</span></span><span style=display:flex><span>- Write block N
</span></span><span style=display:flex><span>- Flush (ensure writes hit persistent media)
</span></span><span style=display:flex><span>- Trim/Discard (inform device blocks are unused)
</span></span></code></pre></div><h3 id="13-hdd-vs-ssd-characteristics">1.3 HDD vs SSD Characteristics</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Hard Disk Drive (HDD):
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Spinning platters + moving head                 │
</span></span><span style=display:flex><span>│                                                  │
</span></span><span style=display:flex><span>│  Seek time: 5-15ms (move head to track)          │
</span></span><span style=display:flex><span>│  Rotational latency: 2-8ms (wait for sector)     │
</span></span><span style=display:flex><span>│  Transfer: 100-200 MB/s sequential               │
</span></span><span style=display:flex><span>│                                                  │
</span></span><span style=display:flex><span>│  Random I/O: ~100 IOPS (dominated by seek)       │
</span></span><span style=display:flex><span>│  Sequential I/O: Much faster (no seeking)        │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solid State Drive (SSD):
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Flash memory + controller                       │
</span></span><span style=display:flex><span>│                                                  │
</span></span><span style=display:flex><span>│  No moving parts, no seek time                   │
</span></span><span style=display:flex><span>│  Random read: ~100µs latency                     │
</span></span><span style=display:flex><span>│  Transfer: 500-7000 MB/s                         │
</span></span><span style=display:flex><span>│                                                  │
</span></span><span style=display:flex><span>│  Random I/O: 10,000-1,000,000 IOPS               │
</span></span><span style=display:flex><span>│  Write amplification: Erase before write         │
</span></span><span style=display:flex><span>│  Wear: Limited program/erase cycles              │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NVMe SSD:
</span></span><span style=display:flex><span>- Direct PCIe connection (no SATA bottleneck)
</span></span><span style=display:flex><span>- Multiple queues (64K commands per queue)
</span></span><span style=display:flex><span>- Even lower latency (~10µs)
</span></span></code></pre></div><h2 id="2-file-system-fundamentals">2. File System Fundamentals</h2><p>Core concepts that all file systems share.</p><h3 id="21-inodes-file-metadata">2.1 Inodes: File Metadata</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Each file has an inode containing metadata:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Inode 12345                                        │
</span></span><span style=display:flex><span>├─────────────────────────────────────────────────────┤
</span></span><span style=display:flex><span>│  Type:        Regular file                          │
</span></span><span style=display:flex><span>│  Permissions: rwxr-xr-x (755)                       │
</span></span><span style=display:flex><span>│  Owner UID:   1000                                  │
</span></span><span style=display:flex><span>│  Group GID:   1000                                  │
</span></span><span style=display:flex><span>│  Size:        28,672 bytes                          │
</span></span><span style=display:flex><span>│  Link count:  1                                     │
</span></span><span style=display:flex><span>│  Timestamps:                                        │
</span></span><span style=display:flex><span>│    - atime: Last access                             │
</span></span><span style=display:flex><span>│    - mtime: Last modification                       │
</span></span><span style=display:flex><span>│    - ctime: Last inode change                       │
</span></span><span style=display:flex><span>│  Block pointers:                                    │
</span></span><span style=display:flex><span>│    [0]: Block 1000                                  │
</span></span><span style=display:flex><span>│    [1]: Block 1001                                  │
</span></span><span style=display:flex><span>│    [2]: Block 1005                                  │
</span></span><span style=display:flex><span>│    [3]: Block 1006                                  │
</span></span><span style=display:flex><span>│    [4]: Block 1007                                  │
</span></span><span style=display:flex><span>│    [5]: Block 1008                                  │
</span></span><span style=display:flex><span>│    [6]: Block 1009                                  │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Note: Filename is NOT in inode!
</span></span><span style=display:flex><span>      Filename is in directory entry
</span></span></code></pre></div><h3 id="22-directories">2.2 Directories</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>A directory is a file containing name→inode mappings:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Directory /home/user (inode 5000):
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Entry           │ Inode Number                  │
</span></span><span style=display:flex><span>├──────────────────┼───────────────────────────────┤
</span></span><span style=display:flex><span>│  .               │ 5000 (self)                   │
</span></span><span style=display:flex><span>│  ..              │ 4000 (parent: /home)          │
</span></span><span style=display:flex><span>│  documents       │ 5001 (subdirectory)           │
</span></span><span style=display:flex><span>│  data.txt        │ 12345                         │
</span></span><span style=display:flex><span>│  config.json     │ 12346                         │
</span></span><span style=display:flex><span>│  script.sh       │ 12347                         │
</span></span><span style=display:flex><span>└──────────────────┴───────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Path resolution for /home/user/data.txt:
</span></span><span style=display:flex><span>1. Start at root inode (inode 2)
</span></span><span style=display:flex><span>2. Read root directory, find &#34;home&#34; → inode 4000
</span></span><span style=display:flex><span>3. Read inode 4000 directory, find &#34;user&#34; → inode 5000
</span></span><span style=display:flex><span>4. Read inode 5000 directory, find &#34;data.txt&#34; → inode 12345
</span></span><span style=display:flex><span>5. Read inode 12345 for file metadata
</span></span></code></pre></div><h3 id="23-hard-links-and-soft-links">2.3 Hard Links and Soft Links</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Hard link: Multiple directory entries → same inode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/home/user/file1.txt ───┐
</span></span><span style=display:flex><span>                        ├──► Inode 12345 ──► Data blocks
</span></span><span style=display:flex><span>/home/user/file2.txt ───┘
</span></span><span style=display:flex><span>                        Link count: 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- Same file, different names
</span></span><span style=display:flex><span>- Cannot span file systems
</span></span><span style=display:flex><span>- Cannot link directories (except . and ..)
</span></span><span style=display:flex><span>- File exists until link count = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Soft (symbolic) link: File containing path to target
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/home/user/shortcut ──► Inode 12350 ──► &#34;/home/user/actual/file&#34;
</span></span><span style=display:flex><span>                                              │
</span></span><span style=display:flex><span>                                              ▼
</span></span><span style=display:flex><span>                                        Inode 12400 ──► Data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- Points to path, not inode
</span></span><span style=display:flex><span>- Can span file systems
</span></span><span style=display:flex><span>- Can link directories
</span></span><span style=display:flex><span>- Can be &#34;dangling&#34; if target deleted
</span></span></code></pre></div><h3 id="24-file-holes-sparse-files">2.4 File Holes (Sparse Files)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Files can have &#34;holes&#34; - unallocated regions:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sparse file with 1MB written at offset 0 and offset 100MB:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Logical view:
</span></span><span style=display:flex><span>┌──────────┬────────────────────────────────┬──────────┐
</span></span><span style=display:flex><span>│  1MB     │           (hole)               │   1MB    │
</span></span><span style=display:flex><span>│  data    │         ~99MB zeros            │   data   │
</span></span><span style=display:flex><span>└──────────┴────────────────────────────────┴──────────┘
</span></span><span style=display:flex><span>Offset: 0                                        100MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Physical storage:
</span></span><span style=display:flex><span>┌──────────┐                                ┌──────────┐
</span></span><span style=display:flex><span>│  1MB     │                                │   1MB    │
</span></span><span style=display:flex><span>│  blocks  │                                │  blocks  │
</span></span><span style=display:flex><span>└──────────┘                                └──────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Apparent size: 101 MB
</span></span><span style=display:flex><span>Actual disk usage: 2 MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Creating sparse file:
</span></span><span style=display:flex><span>fd = open(&#34;sparse&#34;, O_WRONLY | O_CREAT);
</span></span><span style=display:flex><span>lseek(fd, 100 * 1024 * 1024, SEEK_SET);
</span></span><span style=display:flex><span>write(fd, data, 1024 * 1024);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reading hole returns zeros (no I/O needed)
</span></span></code></pre></div><h2 id="3-block-allocation-strategies">3. Block Allocation Strategies</h2><p>How file systems map files to disk blocks.</p><h3 id="31-direct-indirect-and-doubly-indirect">3.1 Direct, Indirect, and Doubly Indirect</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Traditional Unix (ext2/ext3) inode block pointers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Inode:
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Direct blocks [0-11]    → 12 × 4KB = 48KB directly      │
</span></span><span style=display:flex><span>│  Single indirect [12]    → Points to block of pointers   │
</span></span><span style=display:flex><span>│  Double indirect [13]    → Points to block of indirect   │
</span></span><span style=display:flex><span>│  Triple indirect [14]    → Points to block of double     │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Single indirect (4KB block, 4-byte pointers = 1024 pointers):
</span></span><span style=display:flex><span>┌────────┐    ┌────────────────┐
</span></span><span style=display:flex><span>│ Ptr 12 │───►│ Block 5000     │
</span></span><span style=display:flex><span>└────────┘    │ ┌────────────┐ │
</span></span><span style=display:flex><span>              │ │ Ptr to 100 │ │──► Data block 100
</span></span><span style=display:flex><span>              │ │ Ptr to 101 │ │──► Data block 101
</span></span><span style=display:flex><span>              │ │ ...        │ │
</span></span><span style=display:flex><span>              │ │ Ptr to 1123│ │──► Data block 1123
</span></span><span style=display:flex><span>              │ └────────────┘ │
</span></span><span style=display:flex><span>              └────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Maximum file size with 4KB blocks:
</span></span><span style=display:flex><span>Direct:         12 × 4KB                    = 48 KB
</span></span><span style=display:flex><span>Single:         1024 × 4KB                  = 4 MB
</span></span><span style=display:flex><span>Double:         1024 × 1024 × 4KB           = 4 GB
</span></span><span style=display:flex><span>Triple:         1024 × 1024 × 1024 × 4KB    = 4 TB
</span></span><span style=display:flex><span>                                              ───────
</span></span><span style=display:flex><span>                                              ~4 TB total
</span></span></code></pre></div><h3 id="32-extents-modern-approach">3.2 Extents (Modern Approach)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>ext4 and modern file systems use extents:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Extent: Contiguous range of blocks
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Start block: 10000                                  │
</span></span><span style=display:flex><span>│  Length: 256 blocks                                  │
</span></span><span style=display:flex><span>│  Logical start: 0                                    │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>File mapped by few extents vs many block pointers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traditional (1000 blocks):
</span></span><span style=display:flex><span>┌────┬────┬────┬────┬────┬─────────────────────┬────┐
</span></span><span style=display:flex><span>│ 10 │ 11 │ 12 │ 15 │ 16 │        ...          │1099│
</span></span><span style=display:flex><span>└────┴────┴────┴────┴────┴─────────────────────┴────┘
</span></span><span style=display:flex><span>     1000 individual pointers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Extents (same file, contiguously allocated):
</span></span><span style=display:flex><span>┌─────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Start: 10, Length: 3                    │  (blocks 10-12)
</span></span><span style=display:flex><span>│ Start: 15, Length: 2                    │  (blocks 15-16)
</span></span><span style=display:flex><span>│ Start: 100, Length: 995                 │  (blocks 100-1094)
</span></span><span style=display:flex><span>└─────────────────────────────────────────┘
</span></span><span style=display:flex><span>     Only 3 extent descriptors!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benefits:
</span></span><span style=display:flex><span>- Less metadata for large contiguous files
</span></span><span style=display:flex><span>- Better describes sequential allocation
</span></span><span style=display:flex><span>- Faster file operations (less indirection)
</span></span></code></pre></div><h3 id="33-block-allocation-policies">3.3 Block Allocation Policies</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Goals of block allocation:
</span></span><span style=display:flex><span>1. Locality: Related blocks should be near each other
</span></span><span style=display:flex><span>2. Contiguity: Files should be contiguous when possible
</span></span><span style=display:flex><span>3. Fairness: All files get reasonable placement
</span></span><span style=display:flex><span>4. Efficiency: Minimize fragmentation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ext4 block allocation:
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Block Groups:                                        │
</span></span><span style=display:flex><span>│ ┌─────────┬─────────┬─────────┬─────────┐           │
</span></span><span style=display:flex><span>│ │ Group 0 │ Group 1 │ Group 2 │ Group 3 │ ...       │
</span></span><span style=display:flex><span>│ └─────────┴─────────┴─────────┴─────────┘           │
</span></span><span style=display:flex><span>│                                                      │
</span></span><span style=display:flex><span>│ Each group has:                                      │
</span></span><span style=display:flex><span>│ - Superblock copy (or backup)                        │
</span></span><span style=display:flex><span>│ - Group descriptors                                  │
</span></span><span style=display:flex><span>│ - Block bitmap                                       │
</span></span><span style=display:flex><span>│ - Inode bitmap                                       │
</span></span><span style=display:flex><span>│ - Inode table                                        │
</span></span><span style=display:flex><span>│ - Data blocks                                        │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Allocation heuristics:
</span></span><span style=display:flex><span>- Put file&#39;s blocks in same group as inode
</span></span><span style=display:flex><span>- Put related files (same directory) in same group
</span></span><span style=display:flex><span>- Spread directories across groups
</span></span><span style=display:flex><span>- Pre-allocate blocks for growing files
</span></span></code></pre></div><h3 id="34-fragmentation">3.4 Fragmentation</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>File system fragmentation over time:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fresh file system:
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ File A ████████████                                    │
</span></span><span style=display:flex><span>│ File B             ████████                            │
</span></span><span style=display:flex><span>│ File C                      ████████████████           │
</span></span><span style=display:flex><span>│ Free                                        ░░░░░░░░░░░│
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After deletions and new writes:
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ File A ████░░░░████████░░░░████                        │
</span></span><span style=display:flex><span>│ File D     ████            ████░░░░████                │
</span></span><span style=display:flex><span>│ File C                           ░░░░████████████      │
</span></span><span style=display:flex><span>│ Free   ░░░░    ░░░░░░░░░░░░    ░░░░            ░░░░░░░░│
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Impact:
</span></span><span style=display:flex><span>- HDD: Severe (each fragment = seek time)
</span></span><span style=display:flex><span>- SSD: Minor (no seek time, but may affect read-ahead)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Mitigation:
</span></span><span style=display:flex><span>- Delayed allocation (wait to choose blocks)
</span></span><span style=display:flex><span>- Pre-allocation (reserve contiguous space)
</span></span><span style=display:flex><span>- Online defragmentation
</span></span><span style=display:flex><span>- Extent-based allocation
</span></span></code></pre></div><h2 id="4-journaling-and-crash-consistency">4. Journaling and Crash Consistency</h2><p>Protecting data integrity during crashes.</p><h3 id="41-the-crash-consistency-problem">4.1 The Crash Consistency Problem</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Updating a file requires multiple writes:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Adding block to file:
</span></span><span style=display:flex><span>1. Write new data block
</span></span><span style=display:flex><span>2. Update inode (add block pointer, update size)
</span></span><span style=display:flex><span>3. Update block bitmap (mark block used)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>What if crash occurs mid-sequence?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Scenario A: Only (1) completed
</span></span><span style=display:flex><span>- Data written but lost (not linked to file)
</span></span><span style=display:flex><span>- Block bitmap says free, data orphaned
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Scenario B: Only (1) and (2) completed
</span></span><span style=display:flex><span>- File points to block
</span></span><span style=display:flex><span>- Block bitmap says free
</span></span><span style=display:flex><span>- Block could be allocated to another file!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Scenario C: Only (2) and (3) completed
</span></span><span style=display:flex><span>- File points to block with garbage
</span></span><span style=display:flex><span>- File corruption!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>All scenarios leave file system inconsistent.
</span></span></code></pre></div><h3 id="42-fsck-post-crash-recovery">4.2 fsck: Post-Crash Recovery</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Traditional approach: Check entire file system
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fsck operations:
</span></span><span style=display:flex><span>1. Verify superblock sanity
</span></span><span style=display:flex><span>2. Walk all inodes, verify block pointers
</span></span><span style=display:flex><span>3. Verify directory structure
</span></span><span style=display:flex><span>4. Check block bitmap against actual usage
</span></span><span style=display:flex><span>5. Check inode bitmap against actual usage
</span></span><span style=display:flex><span>6. Fix inconsistencies (lost+found)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Problems:
</span></span><span style=display:flex><span>- Time proportional to file system size
</span></span><span style=display:flex><span>- 1TB drive: Minutes to hours
</span></span><span style=display:flex><span>- Petabyte storage: Days!
</span></span><span style=display:flex><span>- System unavailable during check
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Modern systems: Journaling avoids most fsck
</span></span></code></pre></div><h3 id="43-journaling-approaches">4.3 Journaling Approaches</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Write-Ahead Logging (Journaling):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Before modifying file system:
</span></span><span style=display:flex><span>1. Write intended changes to journal
</span></span><span style=display:flex><span>2. Commit journal transaction
</span></span><span style=display:flex><span>3. Apply changes to file system
</span></span><span style=display:flex><span>4. Mark transaction complete
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Journal on disk:
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Journal Area                                           │
</span></span><span style=display:flex><span>│ ┌──────────┬──────────┬──────────┬──────────┬────────┐ │
</span></span><span style=display:flex><span>│ │  TXN 42  │  TXN 43  │  TXN 44  │  TXN 45  │  Free  │ │
</span></span><span style=display:flex><span>│ │ Complete │ Complete │ Committed│ Pending  │        │ │
</span></span><span style=display:flex><span>│ └──────────┴──────────┴──────────┴──────────┴────────┘ │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Recovery after crash:
</span></span><span style=display:flex><span>1. Read journal
</span></span><span style=display:flex><span>2. Replay committed but incomplete transactions
</span></span><span style=display:flex><span>3. Discard uncommitted transactions
</span></span><span style=display:flex><span>4. Done! (seconds, not hours)
</span></span></code></pre></div><h3 id="44-journaling-modes">4.4 Journaling Modes</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>ext4 journaling modes:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Journal (data=journal):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  All data and metadata written to journal first        │
</span></span><span style=display:flex><span>│  Safest but slowest (data written twice)               │
</span></span><span style=display:flex><span>│  Guarantees: Data and metadata consistent              │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Ordered (data=ordered) - Default:
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Only metadata journaled                               │
</span></span><span style=display:flex><span>│  Data written before metadata committed                │
</span></span><span style=display:flex><span>│  Guarantees: No stale data exposure                    │
</span></span><span style=display:flex><span>│  Good balance of safety and performance                │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Writeback (data=writeback):
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Only metadata journaled                               │
</span></span><span style=display:flex><span>│  Data may be written after metadata                    │
</span></span><span style=display:flex><span>│  Risk: File may contain stale/garbage data after crash │
</span></span><span style=display:flex><span>│  Fastest but least safe                                │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Mount options:
</span></span><span style=display:flex><span>mount -o data=journal /dev/sda1 /mnt
</span></span></code></pre></div><h3 id="45-checkpoints-and-journal-wrap">4.5 Checkpoints and Journal Wrap</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Journal space is limited (typically 128MB-1GB):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                    Journal                            │
</span></span><span style=display:flex><span>│ ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐  │
</span></span><span style=display:flex><span>│ │ 10 │ 11 │ 12 │ 13 │ 14 │ 15 │ 16 │ 17 │ 18 │ 19 │  │
</span></span><span style=display:flex><span>│ │Done│Done│Done│ OK │ OK │ OK │ OK │NEW │NEW │    │  │
</span></span><span style=display:flex><span>│ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘  │
</span></span><span style=display:flex><span>│   ↑                   ↑                    ↑          │
</span></span><span style=display:flex><span>│   Checkpoint         Commit               Write       │
</span></span><span style=display:flex><span>│   (can reclaim)      (must keep)          pointer    │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Checkpoint process:
</span></span><span style=display:flex><span>1. Ensure old transactions fully written to main FS
</span></span><span style=display:flex><span>2. Mark transactions as reclaimable
</span></span><span style=display:flex><span>3. Advance checkpoint pointer
</span></span><span style=display:flex><span>4. Space available for new transactions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Journal full = checkpoint forced = performance impact
</span></span></code></pre></div><h2 id="5-copy-on-write-file-systems">5. Copy-on-Write File Systems</h2><p>A different approach to consistency.</p><h3 id="51-cow-principle">5.1 COW Principle</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Never overwrite existing data:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traditional (in-place update):
</span></span><span style=display:flex><span>Block 100: [Old Data] → [New Data]
</span></span><span style=display:flex><span>           Overwritten in place
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Copy-on-Write:
</span></span><span style=display:flex><span>Block 100: [Old Data] (unchanged)
</span></span><span style=display:flex><span>Block 200: [New Data] (new location)
</span></span><span style=display:flex><span>Update parent pointer: 100 → 200
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benefits:
</span></span><span style=display:flex><span>- Old data always consistent (no partial writes)
</span></span><span style=display:flex><span>- Automatic snapshots possible
</span></span><span style=display:flex><span>- No need for journal (COW is inherently safe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cost:
</span></span><span style=display:flex><span>- Fragmentation (data scattered)
</span></span><span style=display:flex><span>- Write amplification (must update parent chain)
</span></span></code></pre></div><h3 id="52-btrfs-architecture">5.2 btrfs Architecture</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>btrfs uses copy-on-write B-trees:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    ┌──────────────┐
</span></span><span style=display:flex><span>                    │  Superblock  │
</span></span><span style=display:flex><span>                    │  (fixed loc) │
</span></span><span style=display:flex><span>                    └──────┬───────┘
</span></span><span style=display:flex><span>                           │
</span></span><span style=display:flex><span>                    ┌──────▼───────┐
</span></span><span style=display:flex><span>                    │   Root Tree  │
</span></span><span style=display:flex><span>                    │   (COW)      │
</span></span><span style=display:flex><span>                    └──────┬───────┘
</span></span><span style=display:flex><span>           ┌───────────────┼───────────────┐
</span></span><span style=display:flex><span>           ▼               ▼               ▼
</span></span><span style=display:flex><span>    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
</span></span><span style=display:flex><span>    │  FS Tree     │ │ Extent Tree  │ │ Checksum Tree│
</span></span><span style=display:flex><span>    │  (files)     │ │ (allocation) │ │  (integrity) │
</span></span><span style=display:flex><span>    └──────────────┘ └──────────────┘ └──────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Write operation:
</span></span><span style=display:flex><span>1. Write new leaf node with data
</span></span><span style=display:flex><span>2. COW path from leaf to root
</span></span><span style=display:flex><span>3. Atomically update superblock
</span></span><span style=display:flex><span>4. Old tree still valid until superblock changes
</span></span></code></pre></div><h3 id="53-snapshots">5.3 Snapshots</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>COW enables efficient snapshots:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Before snapshot:
</span></span><span style=display:flex><span>            ┌───────────┐
</span></span><span style=display:flex><span>            │   Root    │
</span></span><span style=display:flex><span>            └─────┬─────┘
</span></span><span style=display:flex><span>                  │
</span></span><span style=display:flex><span>        ┌─────────┴─────────┐
</span></span><span style=display:flex><span>        ▼                   ▼
</span></span><span style=display:flex><span>   ┌─────────┐         ┌─────────┐
</span></span><span style=display:flex><span>   │ Dir A   │         │ Dir B   │
</span></span><span style=display:flex><span>   └────┬────┘         └────┬────┘
</span></span><span style=display:flex><span>        │                   │
</span></span><span style=display:flex><span>        ▼                   ▼
</span></span><span style=display:flex><span>   ┌─────────┐         ┌─────────┐
</span></span><span style=display:flex><span>   │ File 1  │         │ File 2  │
</span></span><span style=display:flex><span>   └─────────┘         └─────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After snapshot (just copy root pointer):
</span></span><span style=display:flex><span>Live:     Root ─────────────────┐
</span></span><span style=display:flex><span>                                │
</span></span><span style=display:flex><span>Snapshot: Root&#39; ────────────────┤
</span></span><span style=display:flex><span>                                ▼
</span></span><span style=display:flex><span>                          [Same tree]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After modifying File 1:
</span></span><span style=display:flex><span>Live:     Root ──► Dir A&#39; ──► File 1&#39; (modified)
</span></span><span style=display:flex><span>               ╲
</span></span><span style=display:flex><span>                ► Dir B ──► File 2 (shared)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Snapshot: Root&#39; ──► Dir A ──► File 1 (original)
</span></span><span style=display:flex><span>               ╲
</span></span><span style=display:flex><span>                ► Dir B ──► File 2 (shared)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Only changed paths duplicated!
</span></span></code></pre></div><h3 id="54-zfs-features">5.4 ZFS Features</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>ZFS: Enterprise-grade COW file system
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Key features:
</span></span><span style=display:flex><span>┌────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│ Pooled Storage:                                        │
</span></span><span style=display:flex><span>│   Multiple disks → one storage pool                    │
</span></span><span style=display:flex><span>│   File systems share pool space dynamically            │
</span></span><span style=display:flex><span>│                                                        │
</span></span><span style=display:flex><span>│ End-to-End Checksums:                                  │
</span></span><span style=display:flex><span>│   Every block checksummed                              │
</span></span><span style=display:flex><span>│   Detects silent data corruption                       │
</span></span><span style=display:flex><span>│   Self-healing with redundancy                         │
</span></span><span style=display:flex><span>│                                                        │
</span></span><span style=display:flex><span>│ Built-in RAID (RAID-Z):                               │
</span></span><span style=display:flex><span>│   RAID-Z1 (single parity), Z2 (double), Z3 (triple)   │
</span></span><span style=display:flex><span>│   No write hole problem (COW)                         │
</span></span><span style=display:flex><span>│                                                        │
</span></span><span style=display:flex><span>│ Compression:                                           │
</span></span><span style=display:flex><span>│   LZ4, ZSTD, GZIP per-dataset                         │
</span></span><span style=display:flex><span>│   Transparent to applications                          │
</span></span><span style=display:flex><span>│                                                        │
</span></span><span style=display:flex><span>│ Deduplication:                                         │
</span></span><span style=display:flex><span>│   Identify duplicate blocks                            │
</span></span><span style=display:flex><span>│   Store once, reference many times                     │
</span></span><span style=display:flex><span>│   Memory intensive (DDT in RAM)                       │
</span></span><span style=display:flex><span>└────────────────────────────────────────────────────────┘
</span></span></code></pre></div><h2 id="6-the-page-cache">6. The Page Cache</h2><p>RAM as a cache for disk data.</p><h3 id="61-read-caching">6.1 Read Caching</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Page cache sits between file system and disk:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Application read request:
</span></span><span style=display:flex><span>┌──────────┐
</span></span><span style=display:flex><span>│   App    │──── read(fd, buf, 4096) ────┐
</span></span><span style=display:flex><span>└──────────┘                              │
</span></span><span style=display:flex><span>                                          ▼
</span></span><span style=display:flex><span>                              ┌───────────────────┐
</span></span><span style=display:flex><span>                              │    Page Cache     │
</span></span><span style=display:flex><span>                              │  ┌─────────────┐  │
</span></span><span style=display:flex><span>                              │  │ Page: Hit!  │──┼──► Return immediately
</span></span><span style=display:flex><span>                              │  └─────────────┘  │
</span></span><span style=display:flex><span>                              │  ┌─────────────┐  │
</span></span><span style=display:flex><span>                              │  │ Page: Miss  │──┼──► Read from disk
</span></span><span style=display:flex><span>                              │  └─────────────┘  │     then cache
</span></span><span style=display:flex><span>                              └───────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cache lookup: O(1) via radix tree
</span></span><span style=display:flex><span>Hit latency: ~1μs (memory speed)
</span></span><span style=display:flex><span>Miss latency: ~10μs-10ms (storage speed)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Memory pressure → eviction:
</span></span><span style=display:flex><span>- LRU-like algorithm (actually more sophisticated)
</span></span><span style=display:flex><span>- Dirty pages written back before eviction
</span></span><span style=display:flex><span>- Active vs inactive lists
</span></span></code></pre></div><h3 id="62-write-caching-and-writeback">6.2 Write Caching and Writeback</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Writes go to page cache, not disk:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Application write:
</span></span><span style=display:flex><span>┌──────────┐
</span></span><span style=display:flex><span>│   App    │──── write(fd, buf, 4096) ────┐
</span></span><span style=display:flex><span>└──────────┘                               │
</span></span><span style=display:flex><span>                                           ▼
</span></span><span style=display:flex><span>                              ┌───────────────────────┐
</span></span><span style=display:flex><span>                              │     Page Cache        │
</span></span><span style=display:flex><span>                              │  ┌─────────────────┐  │
</span></span><span style=display:flex><span>                              │  │ Page (dirty)    │  │
</span></span><span style=display:flex><span>                              │  │ Modified in RAM │  │
</span></span><span style=display:flex><span>                              │  └─────────────────┘  │
</span></span><span style=display:flex><span>                              └───────────────────────┘
</span></span><span style=display:flex><span>                                           │
</span></span><span style=display:flex><span>                              Writeback (later, async)
</span></span><span style=display:flex><span>                                           │
</span></span><span style=display:flex><span>                                           ▼
</span></span><span style=display:flex><span>                              ┌───────────────────────┐
</span></span><span style=display:flex><span>                              │        Disk           │
</span></span><span style=display:flex><span>                              └───────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Write returns immediately (data in RAM)
</span></span><span style=display:flex><span>Data persists only after writeback or sync
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Writeback triggers:
</span></span><span style=display:flex><span>- Timer (default ~30 seconds)
</span></span><span style=display:flex><span>- Dirty ratio exceeded (dirty_ratio, dirty_background_ratio)
</span></span><span style=display:flex><span>- Explicit fsync/fdatasync
</span></span><span style=display:flex><span>- Memory pressure
</span></span></code></pre></div><h3 id="63-read-ahead">6.3 Read-Ahead</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Kernel predicts future reads:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sequential read pattern detected:
</span></span><span style=display:flex><span>Read block 0 → Prefetch blocks 1, 2, 3, 4
</span></span><span style=display:flex><span>Read block 1 → Already cached! Prefetch 5, 6, 7, 8
</span></span><span style=display:flex><span>Read block 2 → Already cached! Prefetch 9, 10, 11, 12
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Read-ahead window grows with sequential access:
</span></span><span style=display:flex><span>Initial: 128 KB
</span></span><span style=display:flex><span>Growing: 256 KB, 512 KB, up to 2 MB (configurable)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benefits:
</span></span><span style=display:flex><span>- Hides disk latency
</span></span><span style=display:flex><span>- Converts random I/O to sequential (for disk)
</span></span><span style=display:flex><span>- Dramatically improves sequential read throughput
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tuning:
</span></span><span style=display:flex><span>blockdev --setra 8192 /dev/sda  # Set read-ahead (sectors)
</span></span><span style=display:flex><span>cat /sys/block/sda/queue/read_ahead_kb
</span></span></code></pre></div><h3 id="64-direct-io">6.4 Direct I/O</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Bypass page cache for specific use cases:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Normal I/O:
</span></span><span style=display:flex><span>App ──► Page Cache ──► Disk
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Direct I/O (O_DIRECT):
</span></span><span style=display:flex><span>App ──────────────────► Disk
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use cases:
</span></span><span style=display:flex><span>- Database buffer pools (app manages own cache)
</span></span><span style=display:flex><span>- Avoid double-buffering
</span></span><span style=display:flex><span>- Predictable latency (no cache effects)
</span></span><span style=display:flex><span>- Very large files (larger than RAM)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Requirements:
</span></span><span style=display:flex><span>- Aligned buffers (typically 512 or 4096 bytes)
</span></span><span style=display:flex><span>- Aligned offsets
</span></span><span style=display:flex><span>- Aligned lengths
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fd = open(&#34;file&#34;, O_RDWR | O_DIRECT);
</span></span><span style=display:flex><span>// Buffer must be aligned:
</span></span><span style=display:flex><span>posix_memalign(&amp;buffer, 4096, size);
</span></span><span style=display:flex><span>read(fd, buffer, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Direct I/O still uses file system metadata caching.
</span></span></code></pre></div><h2 id="7-file-system-operations">7. File System Operations</h2><p>How common operations work internally.</p><h3 id="71-creating-a-file">7.1 Creating a File</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>creat(&#34;/home/user/newfile.txt&#34;, 0644):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Path resolution
</span></span><span style=display:flex><span>   - Traverse directories to /home/user
</span></span><span style=display:flex><span>   - Each component: lookup in directory, check permissions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Allocate inode
</span></span><span style=display:flex><span>   - Find free inode in inode bitmap
</span></span><span style=display:flex><span>   - Initialize inode (permissions, timestamps, owner)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Create directory entry
</span></span><span style=display:flex><span>   - Add &#34;newfile.txt&#34; → new inode in parent directory
</span></span><span style=display:flex><span>   - Update parent directory mtime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Journal transaction (if journaling)
</span></span><span style=display:flex><span>   - Log: inode allocation, directory update
</span></span><span style=display:flex><span>   - Commit transaction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. Return file descriptor
</span></span><span style=display:flex><span>   - Allocate fd in process fd table
</span></span><span style=display:flex><span>   - Point to open file object
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Operations: Read parent inode, write parent directory,
</span></span><span style=display:flex><span>            write inode bitmap, write new inode
</span></span><span style=display:flex><span>Typically 4+ disk writes (optimized by buffering)
</span></span></code></pre></div><h3 id="72-writing-to-a-file">7.2 Writing to a File</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>write(fd, data, 4096) to middle of file:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Find file offset → block mapping
</span></span><span style=display:flex><span>   - Consult inode extent tree
</span></span><span style=display:flex><span>   - Locate target block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Check if block allocated
</span></span><span style=display:flex><span>   - Yes: Read-modify-write (if partial block)
</span></span><span style=display:flex><span>   - No: Allocate new block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Write to page cache
</span></span><span style=display:flex><span>   - Find or create cached page
</span></span><span style=display:flex><span>   - Copy data to page
</span></span><span style=display:flex><span>   - Mark page dirty
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Update file metadata
</span></span><span style=display:flex><span>   - Update mtime
</span></span><span style=display:flex><span>   - Update size (if file grew)
</span></span><span style=display:flex><span>   - Mark inode dirty
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. Return immediately
</span></span><span style=display:flex><span>   - Data in RAM, not yet on disk
</span></span><span style=display:flex><span>   - Writeback happens later
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For durability: fsync(fd) forces to disk
</span></span></code></pre></div><h3 id="73-reading-a-file">7.3 Reading a File</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>read(fd, buffer, 4096):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Check page cache
</span></span><span style=display:flex><span>   - Hash (inode, offset) → cache lookup
</span></span><span style=display:flex><span>   - Hit: Copy to user buffer, done
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Cache miss: Issue disk read
</span></span><span style=display:flex><span>   - Calculate physical block from file offset
</span></span><span style=display:flex><span>   - Submit I/O request to block layer
</span></span><span style=display:flex><span>   - Process sleeps waiting for completion
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Read-ahead check
</span></span><span style=display:flex><span>   - Was this sequential access?
</span></span><span style=display:flex><span>   - Issue async reads for upcoming blocks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. I/O completion
</span></span><span style=display:flex><span>   - Data arrives in page cache
</span></span><span style=display:flex><span>   - Copy to user buffer
</span></span><span style=display:flex><span>   - Wake up process
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. Return bytes read
</span></span><span style=display:flex><span>   - May be less than requested (EOF, etc.)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Cache hot: ~1μs
</span></span><span style=display:flex><span>Cache cold, SSD: ~100μs
</span></span><span style=display:flex><span>Cache cold, HDD: ~10ms
</span></span></code></pre></div><h3 id="74-deleting-a-file">7.4 Deleting a File</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>unlink(&#34;/home/user/file.txt&#34;):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Path resolution
</span></span><span style=display:flex><span>   - Find parent directory
</span></span><span style=display:flex><span>   - Find directory entry for &#34;file.txt&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Remove directory entry
</span></span><span style=display:flex><span>   - Remove name→inode mapping
</span></span><span style=display:flex><span>   - Update parent directory mtime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Decrement link count
</span></span><span style=display:flex><span>   - inode.nlink -= 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. If link count == 0 AND no open file descriptors:
</span></span><span style=display:flex><span>   - Deallocate all data blocks (update block bitmap)
</span></span><span style=display:flex><span>   - Deallocate inode (update inode bitmap)
</span></span><span style=display:flex><span>   - Free space immediately available
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5. If link count == 0 BUT file still open:
</span></span><span style=display:flex><span>   - Mark inode for deletion
</span></span><span style=display:flex><span>   - Actual deletion when last fd closed
</span></span><span style=display:flex><span>   - &#34;Deleted but still accessible&#34; state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Note: File contents not actually zeroed!
</span></span><span style=display:flex><span>      Just metadata updated.
</span></span><span style=display:flex><span>      Data recoverable until overwritten.
</span></span></code></pre></div><h2 id="8-special-file-systems">8. Special File Systems</h2><p>Not all file systems store data on disk.</p><h3 id="81-procfs-proc">8.1 procfs (/proc)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Virtual file system exposing kernel data:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/proc/
</span></span><span style=display:flex><span>├── 1/                    # Process 1 (init)
</span></span><span style=display:flex><span>│   ├── cmdline          # Command line
</span></span><span style=display:flex><span>│   ├── environ          # Environment variables
</span></span><span style=display:flex><span>│   ├── fd/              # Open file descriptors
</span></span><span style=display:flex><span>│   ├── maps             # Memory mappings
</span></span><span style=display:flex><span>│   ├── stat             # Process statistics
</span></span><span style=display:flex><span>│   └── ...
</span></span><span style=display:flex><span>├── cpuinfo              # CPU information
</span></span><span style=display:flex><span>├── meminfo              # Memory statistics
</span></span><span style=display:flex><span>├── filesystems          # Supported file systems
</span></span><span style=display:flex><span>├── sys/                 # Kernel parameters (sysctl)
</span></span><span style=display:flex><span>│   ├── vm/
</span></span><span style=display:flex><span>│   │   ├── swappiness
</span></span><span style=display:flex><span>│   │   └── dirty_ratio
</span></span><span style=display:flex><span>│   └── kernel/
</span></span><span style=display:flex><span>│       └── hostname
</span></span><span style=display:flex><span>└── ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Reading /proc/meminfo:
</span></span><span style=display:flex><span>- No disk I/O
</span></span><span style=display:flex><span>- Kernel generates content on read
</span></span><span style=display:flex><span>- Each read fetches fresh data
</span></span><span style=display:flex><span>- File &#34;size&#34; is 0 (content generated dynamically)
</span></span></code></pre></div><h3 id="82-sysfs-sys">8.2 sysfs (/sys)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Structured view of kernel objects:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sys/
</span></span><span style=display:flex><span>├── block/               # Block devices
</span></span><span style=display:flex><span>│   ├── sda/
</span></span><span style=display:flex><span>│   │   ├── queue/
</span></span><span style=display:flex><span>│   │   │   ├── scheduler
</span></span><span style=display:flex><span>│   │   │   └── read_ahead_kb
</span></span><span style=display:flex><span>│   │   └── stat
</span></span><span style=display:flex><span>│   └── nvme0n1/
</span></span><span style=display:flex><span>├── devices/             # Device hierarchy
</span></span><span style=display:flex><span>│   ├── system/
</span></span><span style=display:flex><span>│   │   └── cpu/
</span></span><span style=display:flex><span>│   │       ├── cpu0/
</span></span><span style=display:flex><span>│   │       └── cpu1/
</span></span><span style=display:flex><span>│   └── pci0000:00/
</span></span><span style=display:flex><span>├── class/               # Device classes
</span></span><span style=display:flex><span>│   ├── net/
</span></span><span style=display:flex><span>│   │   ├── eth0 -&gt; ../../../devices/...
</span></span><span style=display:flex><span>│   │   └── lo
</span></span><span style=display:flex><span>│   └── block/
</span></span><span style=display:flex><span>└── fs/                  # File system info
</span></span><span style=display:flex><span>    ├── ext4/
</span></span><span style=display:flex><span>    └── btrfs/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Many files writable for configuration:
</span></span><span style=display:flex><span>echo mq-deadline &gt; /sys/block/sda/queue/scheduler
</span></span></code></pre></div><h3 id="83-tmpfs">8.3 tmpfs</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>RAM-based file system:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mount -t tmpfs -o size=1G tmpfs /mnt/ramdisk
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Characteristics:
</span></span><span style=display:flex><span>- Data stored in page cache (RAM)
</span></span><span style=display:flex><span>- Extremely fast (memory speed)
</span></span><span style=display:flex><span>- Lost on reboot (no persistence)
</span></span><span style=display:flex><span>- Can be swapped under memory pressure
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use cases:
</span></span><span style=display:flex><span>- /tmp (temporary files)
</span></span><span style=display:flex><span>- /run (runtime data)
</span></span><span style=display:flex><span>- /dev/shm (POSIX shared memory)
</span></span><span style=display:flex><span>- Build directories (speed up compilation)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance:
</span></span><span style=display:flex><span>- Read/write: Memory bandwidth (GB/s)
</span></span><span style=display:flex><span>- No disk I/O whatsoever
</span></span><span style=display:flex><span>- Latency: Nanoseconds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Size limit:
</span></span><span style=display:flex><span>- Prevents one application consuming all RAM
</span></span><span style=display:flex><span>- Default: Half of RAM
</span></span><span style=display:flex><span>- Configurable per mount
</span></span></code></pre></div><h3 id="84-fuse-filesystem-in-userspace">8.4 FUSE (Filesystem in Userspace)</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>User-space file system framework:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                   Application                        │
</span></span><span style=display:flex><span>│              open(&#34;/mnt/fuse/file&#34;)                  │
</span></span><span style=display:flex><span>└────────────────────────┬────────────────────────────┘
</span></span><span style=display:flex><span>                         │
</span></span><span style=display:flex><span>                         ▼
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                      VFS                             │
</span></span><span style=display:flex><span>└────────────────────────┬────────────────────────────┘
</span></span><span style=display:flex><span>                         │
</span></span><span style=display:flex><span>                         ▼
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│              FUSE Kernel Module                      │
</span></span><span style=display:flex><span>│           (forwards to user space)                   │
</span></span><span style=display:flex><span>└────────────────────────┬────────────────────────────┘
</span></span><span style=display:flex><span>                         │ /dev/fuse
</span></span><span style=display:flex><span>                         ▼
</span></span><span style=display:flex><span>┌─────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│              FUSE User Process                       │
</span></span><span style=display:flex><span>│         (implements file operations)                 │
</span></span><span style=display:flex><span>│                                                      │
</span></span><span style=display:flex><span>│   Examples:                                          │
</span></span><span style=display:flex><span>│   - sshfs (remote files via SSH)                    │
</span></span><span style=display:flex><span>│   - s3fs (Amazon S3 as file system)                 │
</span></span><span style=display:flex><span>│   - encfs (encrypted file system)                   │
</span></span><span style=display:flex><span>│   - ntfs-3g (NTFS driver)                           │
</span></span><span style=display:flex><span>└─────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Overhead: Context switches, but enables flexible FS development
</span></span></code></pre></div><h2 id="9-performance-tuning">9. Performance Tuning</h2><p>Optimizing file system performance.</p><h3 id="91-mount-options">9.1 Mount Options</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Performance-relevant mount options:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>noatime:
</span></span><span style=display:flex><span>  Don&#39;t update access time on read
</span></span><span style=display:flex><span>  Eliminates write for every read
</span></span><span style=display:flex><span>  Highly recommended for most systems
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nodiratime:
</span></span><span style=display:flex><span>  Don&#39;t update access time on directories
</span></span><span style=display:flex><span>  Subset of noatime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>relatime:
</span></span><span style=display:flex><span>  Update atime only if older than mtime
</span></span><span style=display:flex><span>  Default in modern Linux
</span></span><span style=display:flex><span>  Compromise between noatime and atime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit=N:
</span></span><span style=display:flex><span>  Journal commit interval (seconds)
</span></span><span style=display:flex><span>  Higher = fewer syncs, more risk
</span></span><span style=display:flex><span>  Lower = safer, more overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>barrier=0/1:
</span></span><span style=display:flex><span>  Write barriers for integrity
</span></span><span style=display:flex><span>  Disable only with battery-backed cache
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>discard:
</span></span><span style=display:flex><span>  Issue TRIM commands for deleted blocks
</span></span><span style=display:flex><span>  Important for SSD longevity
</span></span><span style=display:flex><span>  Can be done periodically (fstrim) instead
</span></span></code></pre></div><h3 id="92-io-schedulers">9.2 I/O Schedulers</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Block layer I/O schedulers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>none (noop):
</span></span><span style=display:flex><span>  No reordering, FIFO
</span></span><span style=display:flex><span>  Best for NVMe SSDs (no seek time anyway)
</span></span><span style=display:flex><span>  Low CPU overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mq-deadline:
</span></span><span style=display:flex><span>  Deadline guarantee, merge adjacent requests
</span></span><span style=display:flex><span>  Good for SSDs and HDDs
</span></span><span style=display:flex><span>  Prevents starvation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bfq (Budget Fair Queueing):
</span></span><span style=display:flex><span>  Fair scheduling for interactive use
</span></span><span style=display:flex><span>  Good for desktop with HDD
</span></span><span style=display:flex><span>  Higher CPU overhead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kyber:
</span></span><span style=display:flex><span>  Designed for fast SSDs
</span></span><span style=display:flex><span>  Low latency focus
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Check/set scheduler:
</span></span><span style=display:flex><span>cat /sys/block/sda/queue/scheduler
</span></span><span style=display:flex><span>echo mq-deadline &gt; /sys/block/sda/queue/scheduler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Persistent via udev rules:
</span></span><span style=display:flex><span>ACTION==&#34;add|change&#34;, KERNEL==&#34;sd[a-z]&#34;, ATTR{queue/scheduler}=&#34;mq-deadline&#34;
</span></span></code></pre></div><h3 id="93-file-system-choice">9.3 File System Choice</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Choosing the right file system:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ext4:
</span></span><span style=display:flex><span>  - Mature, stable, well-understood
</span></span><span style=display:flex><span>  - Good all-around performance
</span></span><span style=display:flex><span>  - Best for: General purpose, boot partitions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>XFS:
</span></span><span style=display:flex><span>  - Excellent for large files
</span></span><span style=display:flex><span>  - Scales well with many CPUs
</span></span><span style=display:flex><span>  - Best for: Servers, large storage, databases
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>btrfs:
</span></span><span style=display:flex><span>  - Snapshots, compression, checksums
</span></span><span style=display:flex><span>  - Flexible storage management
</span></span><span style=display:flex><span>  - Best for: Desktop, NAS, when features needed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ZFS:
</span></span><span style=display:flex><span>  - Enterprise features, bulletproof
</span></span><span style=display:flex><span>  - High memory requirements
</span></span><span style=display:flex><span>  - Best for: Data integrity critical, storage servers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>F2FS:
</span></span><span style=display:flex><span>  - Designed for flash storage
</span></span><span style=display:flex><span>  - Log-structured writes
</span></span><span style=display:flex><span>  - Best for: SD cards, USB drives, SSDs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance comparison (highly workload-dependent):
</span></span><span style=display:flex><span>Sequential writes: XFS ≈ ext4 &gt; btrfs
</span></span><span style=display:flex><span>Random writes: ext4 ≈ XFS &gt; btrfs
</span></span><span style=display:flex><span>Metadata ops: ext4 &gt; XFS ≈ btrfs
</span></span></code></pre></div><h3 id="94-monitoring-and-debugging">9.4 Monitoring and Debugging</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-bash" data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># I/O statistics</span>
</span></span><span style=display:flex><span>iostat -x <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># %util, await, r/s, w/s per device</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Per-process I/O</span>
</span></span><span style=display:flex><span>iotop -o
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Shows processes doing I/O</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># File system usage</span>
</span></span><span style=display:flex><span>df -h
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Space usage per mount</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Inode usage</span>
</span></span><span style=display:flex><span>df -i
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Can run out of inodes before space!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Block layer stats</span>
</span></span><span style=display:flex><span>cat /proc/diskstats
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Detailed file system stats</span>
</span></span><span style=display:flex><span>tune2fs -l /dev/sda1  <span style=color:#8b949e;font-style:italic># ext4</span>
</span></span><span style=display:flex><span>xfs_info /mount/point <span style=color:#8b949e;font-style:italic># XFS</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Trace I/O operations</span>
</span></span><span style=display:flex><span>blktrace -d /dev/sda -o - | blkparse -i -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># File fragmentation</span>
</span></span><span style=display:flex><span>filefrag filename
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Shows extent count and fragmentation</span>
</span></span></code></pre></div><h2 id="10-durability-and-data-integrity">10. Durability and Data Integrity</h2><p>Ensuring data survives failures.</p><h3 id="101-the-fsync-dance">10.1 The fsync Dance</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Ensuring data reaches disk:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>write() only puts data in page cache:
</span></span><span style=display:flex><span>write(fd, data, size);  // Returns success
</span></span><span style=display:flex><span>                        // Data may only be in RAM!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For durability, must call fsync:
</span></span><span style=display:flex><span>write(fd, data, size);
</span></span><span style=display:flex><span>fsync(fd);              // Waits for disk write
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Even fsync isn&#39;t always enough:
</span></span><span style=display:flex><span>write(fd, data, size);
</span></span><span style=display:flex><span>fsync(fd);
</span></span><span style=display:flex><span>rename(tmpfile, realfile);  // Atomic rename
</span></span><span style=display:flex><span>fsync(directory_fd);        // Sync directory too!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fsync vs fdatasync:
</span></span><span style=display:flex><span>fsync: Syncs data AND metadata (mtime, etc.)
</span></span><span style=display:flex><span>fdatasync: Syncs data, metadata only if size changed
</span></span><span style=display:flex><span>           Faster when only content changes
</span></span></code></pre></div><h3 id="102-atomic-operations">10.2 Atomic Operations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Making updates atomic:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Problem: Writing file in place isn&#39;t atomic
</span></span><span style=display:flex><span>- Crash during write = partial/corrupt file
</span></span><span style=display:flex><span>- No way to &#34;rollback&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Solution: Write-then-rename pattern
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Write to temporary file
</span></span><span style=display:flex><span>   tmpfile = open(&#34;file.tmp&#34;, O_CREAT | O_EXCL);
</span></span><span style=display:flex><span>   write(tmpfile, data, size);
</span></span><span style=display:flex><span>   fsync(tmpfile);
</span></span><span style=display:flex><span>   close(tmpfile);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Atomic rename
</span></span><span style=display:flex><span>   rename(&#34;file.tmp&#34;, &#34;file&#34;);  // Atomic in POSIX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Sync directory (for full durability)
</span></span><span style=display:flex><span>   dirfd = open(&#34;.&#34;, O_DIRECTORY);
</span></span><span style=display:flex><span>   fsync(dirfd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Result:
</span></span><span style=display:flex><span>- &#34;file&#34; always contains complete old or new content
</span></span><span style=display:flex><span>- Never partial or corrupt
</span></span><span style=display:flex><span>- rename() is atomic by POSIX guarantee
</span></span></code></pre></div><h3 id="103-data-integrity-features">10.3 Data Integrity Features</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>Detecting and correcting corruption:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Checksums (btrfs, ZFS):
</span></span><span style=display:flex><span>┌──────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│  Every block has checksum                            │
</span></span><span style=display:flex><span>│  Read: Verify checksum matches data                  │
</span></span><span style=display:flex><span>│  Mismatch: Silent corruption detected!               │
</span></span><span style=display:flex><span>│  With redundancy: Reconstruct from good copy         │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Scrubbing:
</span></span><span style=display:flex><span>- Background process reads all data
</span></span><span style=display:flex><span>- Verifies checksums
</span></span><span style=display:flex><span>- Repairs from redundancy if available
</span></span><span style=display:flex><span>- Schedule regularly: btrfs scrub start /mount
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DIF/DIX (hardware):
</span></span><span style=display:flex><span>- Data Integrity Field
</span></span><span style=display:flex><span>- Controller-level checksums
</span></span><span style=display:flex><span>- Protects data in flight (cable errors, etc.)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RAID:
</span></span><span style=display:flex><span>- RAID1: Mirror, survives one disk failure
</span></span><span style=display:flex><span>- RAID5/6: Parity, survives 1-2 disk failures
</span></span><span style=display:flex><span>- RAID10: Mirror + stripe, performance + redundancy
</span></span></code></pre></div><h3 id="104-backup-considerations">10.4 Backup Considerations</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>File system aware backup:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Snapshot-based backup:
</span></span><span style=display:flex><span>1. Create atomic snapshot (btrfs/ZFS)
</span></span><span style=display:flex><span>2. Backup from snapshot (consistent point-in-time)
</span></span><span style=display:flex><span>3. Delete snapshot after backup
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Send/receive (btrfs, ZFS):
</span></span><span style=display:flex><span>btrfs send /mnt/@snapshot | btrfs receive /backup/
</span></span><span style=display:flex><span>zfs send pool/dataset@snap | zfs receive backup/dataset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Incremental:
</span></span><span style=display:flex><span>btrfs send -p @old_snap @new_snap | btrfs receive /backup/
</span></span><span style=display:flex><span>zfs send -i @old @new | zfs receive backup/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Block-level vs file-level:
</span></span><span style=display:flex><span>- Block-level (dd): Copies everything including free space
</span></span><span style=display:flex><span>- File-level (rsync): Skips deleted files, more flexible
</span></span><span style=display:flex><span>- Snapshot-based: Best of both (consistency + efficiency)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Testing restores:
</span></span><span style=display:flex><span>- Untested backup is no backup
</span></span><span style=display:flex><span>- Periodically verify restore process works
</span></span><span style=display:flex><span>- Check restored data integrity
</span></span></code></pre></div><h2 id="11-summary-and-key-concepts">11. Summary and Key Concepts</h2><p>Consolidating file system knowledge.</p><h3 id="111-core-concepts-review">11.1 Core Concepts Review</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>File system fundamentals:
</span></span><span style=display:flex><span>✓ Inodes store metadata, directories map names to inodes
</span></span><span style=display:flex><span>✓ Block allocation maps files to disk blocks
</span></span><span style=display:flex><span>✓ Extents more efficient than individual block pointers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data integrity:
</span></span><span style=display:flex><span>✓ Journaling ensures crash consistency for metadata
</span></span><span style=display:flex><span>✓ COW file systems inherently crash consistent
</span></span><span style=display:flex><span>✓ Page cache buffers I/O for performance
</span></span><span style=display:flex><span>✓ fsync required for application-level durability
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Performance factors:
</span></span><span style=display:flex><span>✓ HDD: Seek time dominates, sequential access crucial
</span></span><span style=display:flex><span>✓ SSD: Random access fast, but write amplification
</span></span><span style=display:flex><span>✓ Page cache: Hot data served from RAM
</span></span><span style=display:flex><span>✓ Read-ahead: Predicts and prefetches sequential data
</span></span></code></pre></div><h3 id="112-practical-guidelines">11.2 Practical Guidelines</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>For application developers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Call fsync after critical writes
</span></span><span style=display:flex><span>   - write() alone doesn&#39;t guarantee durability
</span></span><span style=display:flex><span>   - Use write-rename pattern for atomic updates
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Consider direct I/O for large sequential access
</span></span><span style=display:flex><span>   - Avoids double-buffering with app cache
</span></span><span style=display:flex><span>   - Requires aligned buffers and offsets
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Understand read-ahead behavior
</span></span><span style=display:flex><span>   - Sequential access is heavily optimized
</span></span><span style=display:flex><span>   - Random access may benefit from madvise()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. Handle ENOSPC and disk errors gracefully
</span></span><span style=display:flex><span>   - Disk full is recoverable
</span></span><span style=display:flex><span>   - I/O errors need careful handling
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For system administrators:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1. Choose file system based on workload
</span></span><span style=display:flex><span>   - ext4: General purpose
</span></span><span style=display:flex><span>   - XFS: Large files, parallel I/O
</span></span><span style=display:flex><span>   - btrfs/ZFS: Snapshots, checksums
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Monitor disk health
</span></span><span style=display:flex><span>   - SMART attributes
</span></span><span style=display:flex><span>   - File system errors in dmesg
</span></span><span style=display:flex><span>   - Regular scrubs for checksumming FS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. Tune mount options
</span></span><span style=display:flex><span>   - noatime for read-heavy workloads
</span></span><span style=display:flex><span>   - Appropriate commit interval
</span></span><span style=display:flex><span>   - Match I/O scheduler to device type
</span></span></code></pre></div><h3 id="113-debugging-checklist">11.3 Debugging Checklist</h3><div class="highlight"><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class="language-text" data-lang=text><span style=display:flex><span>When investigating file system issues:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>□ Check disk space (df -h) and inode usage (df -i)
</span></span><span style=display:flex><span>□ Review mount options (mount | grep device)
</span></span><span style=display:flex><span>□ Check I/O scheduler (cat /sys/block/dev/queue/scheduler)
</span></span><span style=display:flex><span>□ Monitor I/O patterns (iostat -x, iotop)
</span></span><span style=display:flex><span>□ Look for errors in dmesg/journal
</span></span><span style=display:flex><span>□ Verify file fragmentation (filefrag)
</span></span><span style=display:flex><span>□ Check SMART health (smartctl -a /dev/sda)
</span></span><span style=display:flex><span>□ Test write durability (write, sync, read back)
</span></span><span style=display:flex><span>□ Examine page cache stats (/proc/meminfo)
</span></span><span style=display:flex><span>□ Profile with blktrace for detailed analysis
</span></span><span style=display:flex><span>□ Verify permissions and ownership (ls -la)
</span></span><span style=display:flex><span>□ Check for filesystem corruption (fsck in read-only)
</span></span></code></pre></div><p>File systems bridge the critical gap between application data needs and the underlying reality of physical storage hardware, transforming raw disk blocks into organized, named, and protected files. From the elegant simplicity of inodes and directories to the sophisticated crash recovery mechanisms of journaling and copy-on-write architectures, these systems embody decades of engineering wisdom accumulated through countless production incidents and research breakthroughs. Understanding file system internals empowers you to make informed choices about storage architecture, debug mysterious performance problems, and ensure your data survives the unexpected. Whether you&rsquo;re designing database storage engines, optimizing build systems for faster compilation, or simply curious about what happens when you click save, the principles of file system design illuminate one of computing&rsquo;s most essential and enduring abstractions that touches every aspect of how we work with computers.</p></div><footer class="ce1a612 c6dfb1e c3ecea6"><div class="c364589">Categories:
<a href=/categories/fundamentals/>fundamentals</a>, <a href=/categories/systems/>systems</a></div><div>Tags:
<a href=/tags/file-systems/>#file-systems</a>, <a href=/tags/storage/>#storage</a>, <a href=/tags/ext4/>#ext4</a>, <a href=/tags/btrfs/>#btrfs</a>, <a href=/tags/journaling/>#journaling</a>, <a href=/tags/fundamentals/>#fundamentals</a></div></footer></article></main><footer class="ccdf0e8" role=contentinfo aria-label=Footer><div class="cfdda01 c133889 c5df473 c0eecc8 c69618a c6942b3 c03620d c2a9f27 c7c11d8 c82c52d c14527b"><div class="c6dfb1e c3ecea6 c39ef11 c88ae6f">&copy; 2026 Leonardo Benicio. All rights
reserved.</div><div class="c6942b3 c7c11d8 cd1fd22"><a href=https://github.com/lbenicio target=_blank rel="noopener noreferrer" aria-label=GitHub class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22v-4a4.8 4.8.0 00-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35.0-3.5.0.0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35.0 3.5A5.403 5.403.0 004 9c0 3.5 3 5.5 6 5.5-.39.5-.67 1.08-.82 1.7s-.2 1.27-.18 1.9V22"/></svg>
<span class="cba5854">GitHub</span>
</a><a href=https://www.linkedin.com/in/leonardo-benicio target=_blank rel="noopener noreferrer" aria-label=LinkedIn class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452H17.21V14.86c0-1.333-.027-3.046-1.858-3.046-1.86.0-2.145 1.45-2.145 2.948v5.69H9.069V9h3.112v1.561h.044c.434-.82 1.494-1.686 3.074-1.686 3.29.0 3.897 2.165 3.897 4.983v6.594zM5.337 7.433a1.805 1.805.0 11-.002-3.61 1.805 1.805.0 01.002 3.61zM6.763 20.452H3.911V9h2.852v11.452z"/></svg>
<span class="cba5854">LinkedIn</span>
</a><a href=https://twitter.com/lbenicio_ target=_blank rel="noopener noreferrer" aria-label=Twitter class="c1d6c20 c7c11d8 c1d0018 cd1fd22 cb5c327 c10dda9 c6dfb1e cbbda39 cfc01c7 c01f421 c286dd7 c2bd687 cfdce1d cfef18f c000b66 cf55a7b c514027"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.633 7.997c.013.177.013.354.013.53.0 5.386-4.099 11.599-11.6 11.599-2.31.0-4.457-.676-6.265-1.842.324.038.636.05.972.05 1.91.0 3.67-.65 5.07-1.755a4.099 4.099.0 01-3.827-2.84c.25.039.5.064.763.064.363.0.726-.051 1.065-.139A4.091 4.091.0 012.542 9.649v-.051c.538.3 1.162.482 1.824.507A4.082 4.082.0 012.54 6.7c0-.751.2-1.435.551-2.034a11.63 11.63.0 008.44 4.281 4.615 4.615.0 01-.101-.938 4.091 4.091.0 017.078-2.799 8.1 8.1.0 002.595-.988 4.112 4.112.0 01-1.8 2.261 8.2 8.2.0 002.357-.638A8.824 8.824.0 0119.613 7.96z"/></svg>
<span class="cba5854">Twitter</span></a></div></div></footer></body></html>